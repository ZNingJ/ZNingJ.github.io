<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库知识点</title>
      <link href="/2021/01/20/shu-ju-ku-zhi-shi-dian/"/>
      <url>/2021/01/20/shu-ju-ku-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<p><b><span style="color:#FF4500;">写在最前面：本文章所有内容是本人从网络整理而得，并非商用，仅供学习交流使用。</span></b></p><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h4 id="1-主键、外键、超键、候选键"><a href="#1-主键、外键、超键、候选键" class="headerlink" title="1.主键、外键、超键、候选键"></a><strong>1.主键、外键、超键、候选键</strong></h4><blockquote><p><strong>超键</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p><p><strong>候选键</strong>：是最小超键，即没有冗余元素的超键。</p><p><strong>主键</strong>：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p><p><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。</p></blockquote><h4 id="2-为什么用自增列作为主键"><a href="#2-为什么用自增列作为主键" class="headerlink" title="2.为什么用自增列作为主键"></a><strong>2.为什么用自增列作为主键</strong></h4><blockquote><p>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、</p><p>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、</p><p>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</p><p>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）</p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p></blockquote><h4 id="3-触发器的作用？"><a href="#3-触发器的作用？" class="headerlink" title="3.触发器的作用？"></a><strong>3.触发器的作用？</strong></h4><blockquote><p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p></blockquote><h4 id="4-什么是存储过程？用什么来调用？"><a href="#4-什么是存储过程？用什么来调用？" class="headerlink" title="4.什么是存储过程？用什么来调用？"></a><strong>4.什么是存储过程？用什么来调用？</strong></h4><blockquote><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><p><strong>调用：</strong></p><p>1）可以用一个命令对象来调用存储过程。</p><p>2）可以供外部程序调用，比如：java程序。</p></blockquote><h4 id="5-存储过程的优缺点？"><a href="#5-存储过程的优缺点？" class="headerlink" title="5.存储过程的优缺点？"></a><strong>5.存储过程的优缺点？</strong></h4><blockquote><p><strong>优点：</strong></p><p>1）存储过程是预编译过的，执行效率高。</p><p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p><p>3）安全性高，执行存储过程需要有一定权限的用户。</p><p>4）存储过程可以重复使用，可减少数据库开发人员的工作量。</p><p><strong>缺点：</strong>移植性差</p></blockquote><h4 id="6-存储过程与函数的区别"><a href="#6-存储过程与函数的区别" class="headerlink" title="6.存储过程与函数的区别"></a><strong>6.存储过程与函数的区别</strong></h4><p><img src="https://i.imgur.com/ymE9HPJ.png" alt="img"></p><h4 id="7-什么叫视图？游标是什么？"><a href="#7-什么叫视图？游标是什么？" class="headerlink" title="7.什么叫视图？游标是什么？"></a><strong>7.什么叫视图？游标是什么？</strong></h4><blockquote><p><strong>视图：</strong></p><p>是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。</p><p><strong>游标：</strong></p><p>是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p></blockquote><h4 id="8-视图的优缺点"><a href="#8-视图的优缺点" class="headerlink" title="8.视图的优缺点"></a><strong>8.视图的优缺点</strong></h4><blockquote><p><strong>优点：</strong></p><p>1对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。</p><p>2)用户通过简单的查询可以从复杂查询中得到结果。</p><p>3)维护数据的独立性，试图可从多个表检索数据。</p><p>4)对于相同的数据可产生不同的视图。</p><p><strong>缺点：</strong></p><p>性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据</p></blockquote><h4 id="9-drop、truncate、-delete区别"><a href="#9-drop、truncate、-delete区别" class="headerlink" title="9.drop、truncate、 delete区别"></a><strong>9.drop、truncate、 delete区别</strong></h4><blockquote><p><strong>最基本：</strong></p><ul><li>drop直接删掉表。</li><li>truncate删除表中数据，再插入时自增长id又从1开始。</li><li>delete删除表中数据，可以加where字句。</li></ul><p>（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p><p>（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</p><p>（3） 一般而言，drop &gt; truncate &gt; delete</p><p>（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view</p><p>（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。</p><p>（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</p><p>（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</p><p>（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。</p><p>（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。</p><p>（10） Truncate table 表名 速度快,而且效率高,因为:?truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p><p>（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</p><p>（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p></blockquote><h4 id="10-什么是临时表，临时表什么时候删除"><a href="#10-什么是临时表，临时表什么时候删除" class="headerlink" title="10.什么是临时表，临时表什么时候删除?"></a><strong>10.什么是临时表，临时表什么时候删除?</strong></h4><blockquote><p><strong>临时表可以手动删除：</strong><br>DROP TEMPORARY TABLE IF EXISTS temp_tb;</p><p><strong>临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。<br>创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY，</strong></p><p>如：</p><p>CREATE TEMPORARY TABLE tmp_table (</p><p>NAME VARCHAR (10) NOT NULL,</p><p>time date NOT NULL<br>);</p><p>select * from tmp_table;</p></blockquote><h4 id="11-非关系型数据库和关系型数据库区别，优势比较"><a href="#11-非关系型数据库和关系型数据库区别，优势比较" class="headerlink" title="11.非关系型数据库和关系型数据库区别，优势比较?"></a><strong>11.非关系型数据库和关系型数据库区别，优势比较?</strong></h4><blockquote><p><strong>非关系型数据库的优势：</strong></p><ul><li><strong>性能：</strong>NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li><li><strong>可扩展性：</strong>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li></ul><p><strong>关系型数据库的优势：</strong></p><ul><li><strong>复杂查询：</strong>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li><strong>事务支持：</strong>使得对于安全性能很高的数据访问要求得以实现。</li></ul><p><strong>其他：</strong></p><p>**1.**对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p><p>**2.**NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。</p><p>**3.**对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。</p></blockquote><h4 id="12-数据库范式，根据某个场景设计数据表"><a href="#12-数据库范式，根据某个场景设计数据表" class="headerlink" title="12.数据库范式，根据某个场景设计数据表?"></a><strong>12.数据库范式，根据某个场景设计数据表?</strong></h4><blockquote><p><strong>第一范式:</strong>(确保每列保持原子性)所有字段值都是不可分解的原子值。</p><p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。<br>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。<br>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p><p><strong>第二范式:</strong>(确保表中的每列都和主键相关)在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。<br>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。</p><p><strong>第三范式:</strong>(确保每列都和主键列直接相关,而不是间接相关) 数据表中的每一列数据都和主键直接相关，而不能间接相关。</p><p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。<br>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p><p>**BCNF:**符合3NF，并且，主属性不依赖于主属性。</p><p>若关系模式属于第二范式，且每个属性都不传递依赖于键码，则R属于BC范式。<br>通常BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。<br>BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。<br>还可以这么说：若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。<br>一般，一个数据库设计符合3NF或BCNF就可以了。</p><p>**第四范式:**要求把同一表内的多对多关系删除。</p><p>**第五范式:**从最终结构重新建立原始结构。</p></blockquote><h4 id="13-什么是-内连接、外连接、交叉连接、笛卡尔积等"><a href="#13-什么是-内连接、外连接、交叉连接、笛卡尔积等" class="headerlink" title="13.什么是 内连接、外连接、交叉连接、笛卡尔积等?"></a><strong>13.什么是 内连接、外连接、交叉连接、笛卡尔积等?</strong></h4><blockquote><p><strong>内连接:</strong> 只连接匹配的行</p><p><strong>左外连接:</strong> 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行</p><p><strong>右外连接:</strong> 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行</p><p>例如1：<br>SELECT a.<em>,b.</em> FROM luntan LEFT JOIN usertable as b ON a.username=b.username</p><p>例如2：<br>SELECT a.<em>,b.</em> FROM city as a FULL OUTER JOIN user as b ON a.username=b.username</p><p><strong>全外连接:</strong> 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。</p><p><strong>交叉连接:</strong> 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</p><p>例如：<br>SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type</p><p><strong>注意：</strong></p><p>很多公司都只是考察是否知道其概念，但是也有很多公司需要不仅仅知道概念，还需要动手写sql,一般都是简单的连接查询，具体关于连接查询的sql练习，参见以下链接：</p><p><a href="https://www.nowcoder.com/ta/sql">牛客网数据库SQL实战</a></p><p><a href="https://leetcode-cn.com/problemset/database/">leetcode中文网站数据库练习</a></p><p><a href="http://www.baidu.com/">我的另一篇文章，常用sql练习50题</a></p></blockquote><h4 id="14-varchar和char的使用场景"><a href="#14-varchar和char的使用场景" class="headerlink" title="14.varchar和char的使用场景?"></a><strong>14.varchar和char的使用场景?</strong></h4><blockquote></blockquote><blockquote><p>**1.**char的长度是不可变的，而varchar的长度是可变的。</p><p>定义一个char[10]和varchar[10]。<br>如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。</p><p>**2.**char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。<br>char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。<br>varchar是以空间效率为首位。</p><p>**3.**char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。<br>varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。</p><p>**4.**两者的存储数据都非unicode的字符数据。</p></blockquote><h4 id="15-SQL语言分类"><a href="#15-SQL语言分类" class="headerlink" title="15.SQL语言分类"></a><strong>15.SQL语言分类</strong></h4><blockquote><p><strong>SQL语言共分为四大类：</strong></p><ul><li>数据查询语言DQL</li><li>数据操纵语言DML</li><li>数据定义语言DDL</li><li>数据控制语言DCL。</li></ul><p><strong>1. 数据查询语言DQL</strong></p><p>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：</p><p>SELECT<br>FROM<br>WHERE</p><p><strong>2 .数据操纵语言DML</strong></p><p>数据操纵语言DML主要有三种形式：</p><ol><li>插入：INSERT</li><li>更新：UPDATE</li><li>删除：DELETE</li></ol><p><strong>3. 数据定义语言DDL</strong></p><p>数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等如：<br>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER</p><p>表 视图 索引 同义词 簇</p><p>DDL操作是隐性提交的！不能rollback</p><p><strong>4. 数据控制语言DCL</strong></p><p>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p><ol><li>GRANT：授权。</li><li>ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚—ROLLBACK；回滚命令使数据库状态回到上次最后提交的状态。其格式为：<br>SQL&gt;ROLLBACK;</li><li>COMMIT [WORK]：提交。</li></ol><p>在数据库的插入、删除和修改操作时，只有当事务在提交到数据<br>库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看<br>到所做的事情，别人只有在最后提交完成后才可以看到。<br>提交数据有三种类型：显式提交、隐式提交及自动提交。下面分<br>别说明这三种类型。</p><p>(1) 显式提交<br>用COMMIT命令直接完成的提交为显式提交。其格式为：<br>SQL&gt;COMMIT；</p><p>(2) 隐式提交<br>用SQL命令间接完成的提交为隐式提交。这些命令是：<br>ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，<br>EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。</p><p>(3) 自动提交<br>若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，<br>系统将自动进行提交，这就是自动提交。其格式为：<br>SQL&gt;SET AUTOCOMMIT ON；</p><p>参考文章：<br><a href="https://www.cnblogs.com/study-s/p/5287529.html">https://www.cnblogs.com/study-s/p/5287529.html</a></p></blockquote><h4 id="16-like-和-的区别"><a href="#16-like-和-的区别" class="headerlink" title="16.like %和-的区别"></a><strong>16.like %和-的区别</strong></h4><blockquote><p><strong>通配符的分类:</strong></p><p>**%百分号通配符:**表示任何字符出现任意次数(可以是0次).</p><p>**_下划线通配符:**表示只能匹配单个字符,不能多也不能少,就是一个字符.</p><p><strong>like操作符:</strong> LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.</p><p><strong>注意:</strong> 如果在使用like操作符时,后面的没有使用通用匹配符效果是和=一致的,SELECT * FROM products WHERE products.prod_name like ‘1000’;<br>只能匹配的结果为1000,而不能匹配像JetPack 1000这样的结果.</p><ul><li>%通配符使用: 匹配以”yves”开头的记录:(包括记录”yves”) SELECT <em>FROM products WHERE products.prod_name like ‘yves%’;<br>匹配包含”yves”的记录(包括记录”yves”) SELECT</em> FROM products WHERE products.prod_name like ‘%yves%’;<br>匹配以”yves”结尾的记录(包括记录”yves”,不包括记录”yves “,也就是yves后面有空格的记录,这里需要注意) SELECT * FROM products WHERE products.prod_name like ‘%yves’;</li><li><em>通配符使用: SELECT *FROM products WHERE products.prod_name like ‘_yves’; 匹配结果为: 像”yyves”这样记录.<br>SELECT* FROM products WHERE products.prod*name like ‘yves</em>*’; 匹配结果为: 像”yvesHe”这样的记录.(一个下划线只能匹配一个字符,不能多也不能少)</li></ul><p><strong>注意事项:</strong></p><ul><li>注意大小写,在使用模糊匹配时,也就是匹配文本时,mysql是可能区分大小的,也可能是不区分大小写的,这个结果是取决于用户对MySQL的配置方式.如果是区分大小写,那么像YvesHe这样记录是不能被”yves__”这样的匹配条件匹配的.</li><li>注意尾部空格,”%yves”是不能匹配”heyves “这样的记录的.</li><li>注意NULL,%通配符可以匹配任意字符,但是不能匹配NULL,也就是说SELECT * FROM products WHERE products.prod_name like ‘%;是匹配不到products.prod_name为NULL的的记录.</li></ul><p><strong>技巧与建议:</strong></p><p>正如所见， MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。</p><ul><li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该 使用其他操作符。</li><li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起 来是最慢的。</li><li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数.</li></ul></blockquote><p>参考博文：<a href="https://blog.csdn.net/u011479200/article/details/78513632">https://blog.csdn.net/u011479200/article/details/78513632</a></p><h4 id="17-count-、count-1-、count-column-的区别"><a href="#17-count-、count-1-、count-column-的区别" class="headerlink" title="17.count(*)、count(1)、count(column)的区别"></a><strong>17.count(*)、count(1)、count(column)的区别</strong></h4><blockquote><ul><li>count(*)对行的数目进行计算,包含NULL</li><li>count(column)对特定的列的值具有的行数进行计算,不包含NULL值。</li><li>count()还有一种使用方式,count(1)这个用法和count(*)的结果是一样的。</li></ul><p><strong>性能问题:</strong></p><p>1.任何情况下SELECT COUNT(*) FROM tablename是最优选择;</p><p>2.尽量减少SELECT COUNT(*) FROM tablename WHERE COL = ‘value’ 这种查询;</p><p>3.杜绝SELECT COUNT(COL) FROM tablename WHERE COL2 = ‘value’ 的出现。</p><ul><li>如果表没有主键,那么count(1)比count(*)快。</li><li>如果有主键,那么count(主键,联合主键)比count(*)快。</li><li>如果表只有一个字段,count(*)最快。</li></ul><p>count(1)跟count(主键)一样,只扫描主键。count(*)跟count(非主键)一样,扫描整个表。明显前者更快一些。</p></blockquote><h4 id="18-最左前缀原则"><a href="#18-最左前缀原则" class="headerlink" title="18.最左前缀原则"></a><strong>18.最左前缀原则</strong></h4><blockquote><p><strong>多列索引：</strong></p><p>ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);</p><p>为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。</p><p>注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。</p><p><strong>最左前缀原则：</strong>顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。</p></blockquote><h2 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h2><h4 id="1-什么是索引？"><a href="#1-什么是索引？" class="headerlink" title="1.什么是索引？"></a><strong>1.什么是索引？</strong></h4><blockquote><p><strong>何为索引：</strong></p><p>数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其变种B+树。</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p></blockquote><h4 id="2-索引的作用？它的优点缺点是什么？"><a href="#2-索引的作用？它的优点缺点是什么？" class="headerlink" title="2.索引的作用？它的优点缺点是什么？"></a><strong>2.索引的作用？它的优点缺点是什么？</strong></h4><blockquote><p><strong>索引作用：</strong></p><p>协助快速查询、更新数据库表中数据。</p><p>为表设置索引要付出代价的：</p><ul><li><p>一是增加了数据库的存储空间</p></li><li><p>二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p><h4 id="3-索引的优缺点？"><a href="#3-索引的优缺点？" class="headerlink" title="3.索引的优缺点？"></a><strong>3.索引的优缺点？</strong></h4></li></ul><p><strong>创建索引可以大大提高系统的性能（优点）：</strong></p><p>1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><p>2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p>3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><p>4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p><p>5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p><strong>增加索引也有许多不利的方面(缺点)：</strong></p><p>1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><p>2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p>3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p></blockquote><h4 id="4-哪些列适合建立索引、哪些不适合建索引？"><a href="#4-哪些列适合建立索引、哪些不适合建索引？" class="headerlink" title="4.哪些列适合建立索引、哪些不适合建索引？"></a><strong>4.哪些列适合建立索引、哪些不适合建索引？</strong></h4><blockquote><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。</p><p><strong>一般来说，应该在这些列上创建索引：</strong></p><p>（1）在经常需要搜索的列上，可以加快搜索的速度；</p><p>（2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</p><p>（3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</p><p>（4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</p><p>（5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p><p>（6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p><p><strong>对于有些列不应该创建索引：</strong></p><p>（1）对于那些在查询中很少使用或者参考的列不应该创建索引。</p><p>这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p>（2）对于那些只有很少数据值的列也不应该增加索引。</p><p>这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p><p>（3）对于那些定义为text, image和bit数据类型的列不应该增加索引。</p><p>这是因为，这些列的数据量要么相当大，要么取值很少。</p><p>(4)当修改性能远远大于检索性能时，不应该创建索引。</p><p>这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p></blockquote><h4 id="5-什么样的字段适合建索引"><a href="#5-什么样的字段适合建索引" class="headerlink" title="5.什么样的字段适合建索引"></a><strong>5.什么样的字段适合建索引</strong></h4><blockquote><p>唯一、不为空、经常被查询的字段</p><h4 id="6-MySQL-B-Tree索引和Hash索引的区别"><a href="#6-MySQL-B-Tree索引和Hash索引的区别" class="headerlink" title="6.MySQL B+Tree索引和Hash索引的区别?"></a><strong>6.MySQL B+Tree索引和Hash索引的区别?</strong></h4><p><strong>Hash索引和B+树索引的特点：</strong></p><ul><li>Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位;</li><li>B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问;</li></ul><p><strong>为什么不都用Hash索引而使用B+树索引？</strong></p><ol><li>Hash索引仅仅能满足”=”,”IN”和””查询，不能使用范围查询,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样；</li><li>Hash索引无法被用来避免数据的排序操作，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样；</li><li>Hash索引不能利用部分索引键查询，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用；</li><li>Hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据；</li><li>Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高。</li></ol><p><strong>补充：</strong></p><p>1.MySQL中，只有HEAP/MEMORY引擎才显示支持Hash索引。</p><p>2.常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。<br>B+树索引和哈希索引的明显区别是：</p><p>3.如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</p><p>4.如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；<br>同理，哈希索引没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</p><p>5.哈希索引也不支持多列联合索引的最左匹配规则；</p><p>6.B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</p><p>7.在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。</p></blockquote><h4 id="7-B树和B-树的区别"><a href="#7-B树和B-树的区别" class="headerlink" title="7.B树和B+树的区别"></a><strong>7.B树和B+树的区别</strong></h4><blockquote><ol><li>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。<br><img src="https://i.imgur.com/RbzI0R8.jpg" alt="img"></li><li>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)<br><img src="https://i.imgur.com/9VbnDME.jpg" alt="img"></li></ol></blockquote><h4 id="8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a><strong>8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</strong></h4><blockquote><p><strong>1.B+的磁盘读写代价更低</strong></p><p>B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p><strong>2.B+tree的查询效率更加稳定</strong></p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></blockquote><h4 id="9-聚集索引和非聚集索引区别"><a href="#9-聚集索引和非聚集索引区别" class="headerlink" title="9.聚集索引和非聚集索引区别?"></a><strong>9.聚集索引和非聚集索引区别?</strong></h4><blockquote><p><strong>聚合索引(clustered index):</strong></p><p>聚集索引<strong>表记录的排列顺序和索引的排列顺序一致，所以查询效率快，</strong>只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。<br>聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。</p><p><strong>非聚合索引(nonclustered index):</strong></p><p>非聚集索引<strong>指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，</strong>两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。<br>非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。</p><p><strong>根本区别：</strong></p><p>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</p></blockquote><h2 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h2><h4 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1.什么是事务？"></a><strong>1.什么是事务？</strong></h4><blockquote><p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p></blockquote><h4 id="2-事务四大特性（ACID）原子性、一致性、隔离性、持久性"><a href="#2-事务四大特性（ACID）原子性、一致性、隔离性、持久性" class="headerlink" title="2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?"></a><strong>2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?</strong></h4><blockquote><p><strong>原子性（Atomicity）:</strong><br>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><p><strong>一致性（Consistency）:</strong><br>事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p><p><strong>隔离性（Isolation）:</strong><br>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p><p><strong>持久性（Durability）:</strong><br>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p></blockquote><h4 id="3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别"><a href="#3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别" class="headerlink" title="3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?"></a><strong>3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?</strong></h4><blockquote><p>从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。<br><strong>事务的并发问题</strong></p><p><strong>1、脏读：</strong>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p><p><strong>2、不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p><p><strong>3、幻读：</strong>幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。</p><p>例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。<br><strong>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</strong></p><p><strong>事务的隔离级别</strong></p><p><img src="https://i.imgur.com/xAeWTSp.png" alt="img"></p><p><strong>读未提交：</strong>另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读</p><p><strong>不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p><p><strong>可重复读：</strong>在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象</p><p><strong>串行化：</strong>最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样</p></blockquote><p><strong>特别注意：</strong></p><blockquote><p>MySQL默认的事务隔离级别为repeatable-read</p><p>MySQL 支持 4 中事务隔离级别.</p><p>事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持.</p><p>Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE</p><p>SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异</p><p><strong>MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行</strong></p><p><strong>事务隔离级别：</strong>未提交读时，写数据只会锁住相应的行。</p><p><strong>事务隔离级别为：</strong>可重复读时，写数据会锁住整张表。</p><p><strong>事务隔离级别为：</strong>串行化时，读写数据都会锁住整张表。</p><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p></blockquote><h4 id="4-事务传播行为"><a href="#4-事务传播行为" class="headerlink" title="4.事务传播行为"></a><strong>4.事务传播行为</strong></h4><blockquote><p><strong>1.PROPAGATION_REQUIRED：</strong>如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p><strong>2.PROPAGATION_SUPPORTS：</strong>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p><p><strong>3.PROPAGATION_MANDATORY：</strong>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p><strong>4.PROPAGATION_REQUIRES_NEW：</strong>创建新事务，无论当前存不存在事务，都创建新事务。</p><p><strong>5.PROPAGATION_NOT_SUPPORTED：</strong>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p><strong>6.PROPAGATION_NEVER：</strong>以非事务方式执行，如果当前存在事务，则抛出异常。</p><p><strong>7.PROPAGATION_NESTED：</strong>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p></blockquote><h4 id="5-嵌套事务"><a href="#5-嵌套事务" class="headerlink" title="5.嵌套事务"></a><strong>5.嵌套事务</strong></h4><blockquote><p><strong>什么是嵌套事务？</strong></p><p>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了：</p><p><strong>如果子事务回滚，会发生什么？</strong></p><p>父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</p><p><strong>如果父事务回滚，会发生什么？</strong></p><p>父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：</p><p><strong>事务的提交，是什么情况？</strong></p><p>是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</p></blockquote><p>参考文章：<a href="https://blog.csdn.net/liangxw1/article/details/51197560">https://blog.csdn.net/liangxw1/article/details/51197560</a></p><h2 id="四、存储引擎"><a href="#四、存储引擎" class="headerlink" title="四、存储引擎"></a>四、存储引擎</h2><h4 id="1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别"><a href="#1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别" class="headerlink" title="1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?"></a><strong>1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?</strong></h4><blockquote><p><strong>两种存储引擎的大致区别表现在：</strong></p><p>1.<strong>InnoDB支持事务，MyISAM不支持，</strong> <strong>这一点是非常之重要。</strong>事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</p><p>2.MyISAM适合查询以及插入为主的应用。</p><p>3.InnoDB适合频繁修改以及涉及到安全性较高的应用。</p><p>4.InnoDB支持外键，MyISAM不支持。</p><p>5.从MySQL5.5.5以后，InnoDB是默认引擎。</p><p>6.InnoDB不支持FULLTEXT类型的索引。</p><p>7.InnoDB中不保存表的行数，如select count(<em>) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含where条件时MyISAM也需要扫描整个表。</p><p>8.对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。</p><p>9.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除，效率非常慢。MyISAM则会重建表。</p><p>10.InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’。</p></blockquote><h4 id="2-MySQL存储引擎MyISAM与InnoDB如何选择"><a href="#2-MySQL存储引擎MyISAM与InnoDB如何选择" class="headerlink" title="2.MySQL存储引擎MyISAM与InnoDB如何选择"></a><strong>2.MySQL存储引擎MyISAM与InnoDB如何选择</strong></h4><blockquote><p>MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。</p><p>虽然MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个。<br>关于MySQL数据库提供的两种存储引擎，MyISAM与InnoDB选择使用：</p></blockquote><ul><li>1.INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MyISAM不支持。</li><li>2.MyISAM的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。</li></ul><blockquote><p>如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句。</p><p>如果你的应用程序对查询性能要求较高，就要使用MyISAM了。MyISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MyISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。</p><p>有人说MyISAM只能用于小型应用，其实这只是一种偏见。如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，而不是单纯地依赖存储引擎。</p><p>现在一般都是选用innodb了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。<br>MEMORY存储引擎</p><p>MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。<br>每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。</p><p>MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。</p><p>注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。</p></blockquote><h4 id="3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景"><a href="#3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景" class="headerlink" title="3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?"></a><strong>3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?</strong></h4><blockquote><p><strong>事务处理上方面</strong></p></blockquote><ul><li>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</li><li>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li></ul><blockquote><p><strong>锁级别</strong></p></blockquote><ul><li>MyISAM：只支持表级锁，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</li><li>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</li></ul><blockquote><p><strong>关于存储引擎MyISAM和InnoDB的其他参考资料如下：</strong></p><p><a href="http://blog.csdn.net/lc0817/article/details/52757194">MySQL存储引擎中的MyISAM和InnoDB区别详解</a></p><p><a href="https://www.cnblogs.com/kevingrace/p/5685355.html">MySQL存储引擎之MyISAM和Innodb总结性梳理</a></p></blockquote><h2 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h2><h4 id="1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?"></a><strong>1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?</strong></h4><ul><li>1.查询中用到的关键词主要包含<strong>六个</strong>，并且他们的顺序依次为 <strong>select–from–where–group by–having–order by</strong></li></ul><blockquote><p><strong>其中select和from是必须的，其他关键词是可选的，这六个关键词的执行顺序 与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行</strong></p><p>**from:**需要从哪个数据表检索数据</p></blockquote><blockquote><p>**where:**过滤表中数据的条件</p><p>**group by:**如何将上面过滤出的数据分组</p><p>**having:**对上面已经分组的数据进行过滤的条件</p><p>**select:**查看结果集中的哪个列，或列的计算结果</p><p>**order by :**按照什么样的顺序来查看返回的数据</p></blockquote><ul><li>2.<strong>from后面的表关联，是自右向左解析 而where条件的解析顺序是自下而上的。</strong></li></ul><blockquote><p>也就是说，在写SQL语句的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在where语句的最左边 （用小表去匹配大表）</p><p>其他参考资源：<br><a href="http://www.cnblogs.com/huminxxl/p/3149097.html">http://www.cnblogs.com/huminxxl/p/3149097.html</a></p></blockquote><h4 id="2-使用explain优化sql和索引"><a href="#2-使用explain优化sql和索引" class="headerlink" title="2.使用explain优化sql和索引?"></a><strong>2.使用explain优化sql和索引?</strong></h4><blockquote><p><strong>对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化</strong></p><p><strong>table：</strong>显示这一行的数据是关于哪张表的</p><p><strong>type：</strong>这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL</p><p>**all:**full table scan ;MySQL将遍历全表以找到匹配的行；</p><p><strong>index:</strong> index scan; index 和 all的区别在于index类型只遍历索引；</p><p><strong>range：</strong>索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，等查询；</p><p><strong>ref：</strong>非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；</p><p><strong>eq_ref：</strong>唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；</p><p><strong>const，system：</strong>当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。</p><p><strong>possible_keys：</strong>显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p><p><strong>key：</strong> 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引</p><p><strong>key_len：</strong>使用的索引的长度。在不损失精确性的情况下，长度越短越好</p><p><strong>ref：</strong>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><p><strong>rows：</strong>MySQL认为必须检查的用来返回请求数据的行数</p><p><strong>Extra：</strong>关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。</p></blockquote><h4 id="3-MySQL慢查询怎么解决"><a href="#3-MySQL慢查询怎么解决" class="headerlink" title="3.MySQL慢查询怎么解决?"></a><strong>3.MySQL慢查询怎么解决?</strong></h4><blockquote><ul><li>slow_query_log 慢查询开启状态。</li><li>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。</li><li>long_query_time 查询超过多少秒才记录。</li></ul></blockquote><h2 id="六、数据库锁"><a href="#六、数据库锁" class="headerlink" title="六、数据库锁"></a>六、数据库锁</h2><h4 id="1-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决"><a href="#1-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决" class="headerlink" title="1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?"></a><strong>1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?</strong></h4><blockquote><p><strong>MySQL有三种锁的级别：</strong>页级、表级、行级。</p><ul><li><strong>表级锁：</strong>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li><li><strong>行级锁：</strong>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li><strong>页面锁：</strong>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<br><strong>什么情况下会造成死锁?</strong></li></ul><p><strong>什么是死锁？</strong></p><p><strong>死锁:</strong> 是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。</p><p>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。</p><p><strong>死锁的关键在于：</strong>两个(或以上)的Session加锁的顺序不一致。</p><p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。</p><p><strong>死锁的解决办法?</strong></p><p>1.查出的线程杀死 kill<br>SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;</p><p>2.设置锁的超时时间<br>Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。</p><p>生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值<br>该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：<br>set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。</p><p>3.指定获取锁的顺序</p></blockquote><h4 id="2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁"><a href="#2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁" class="headerlink" title="2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?"></a><strong>2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?</strong></h4><blockquote><p><strong>悲观锁（Pessimistic Lock）:</strong></p><p>**悲观锁特点:**先获取锁，再进行业务操作。</p><p>即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的<strong>“一锁二查三更新”即指的是使用悲观锁。</strong>通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p><p><strong>补充：</strong><br>不同的数据库对select for update的实现和支持都是有所区别的，</p><ul><li>oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有no wait这个选项。</li><li>MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。</li></ul><p><strong>乐观锁（Optimistic Lock）:</strong></p><p>**1.**乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。</p><p>*<em>2.*</em>**乐观锁的特点先进行业务操作，不到万不得已不去拿锁。**即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。<br>乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。</p><p><strong>3.<strong>一般的做法是</strong>在需要锁的数据上增加一个版本号，或者时间戳</strong>，</p><p><strong>实现方式举例如下：</strong></p><p><strong>乐观锁（给表加一个版本号字段）</strong> 这个并不是乐观锁的定义，给表加版本号，是<strong>数据库实现乐观锁的一种方式</strong>。</p><ol><li>SELECT data AS old_data, version AS old_version FROM …;</li><li>根据获取的数据进行业务操作，得到new_data和new_version</li><li>UPDATE SET data = new_data, version = new_version WHERE version = old_version</li></ol><p>if (updated row &gt; 0) {</p><p>// 乐观锁获取成功，操作完成</p><p>} else {</p><p>// 乐观锁获取失败，回滚并重试</p><p>}</p><p><strong>注意：</strong></p><ul><li>乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能</li><li>乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。</li></ul><p><strong>总结：</strong><br>悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select … for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。</p><ul><li><strong>响应速度：</strong> 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。’</li><li><strong>冲突频率：</strong> 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。</li><li><strong>重试代价：</strong> 如果重试代价大，建议采用悲观锁。</li></ul></blockquote><h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><h4 id="1-数据库的主从复制"><a href="#1-数据库的主从复制" class="headerlink" title="1.数据库的主从复制"></a><strong>1.数据库的主从复制</strong></h4><blockquote><p><strong>主从复制的几种方式:</strong></p><p><strong>同步复制:</strong></p><p>所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。 这样，显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。</p><p><strong>异步复制:</strong></p><p>如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。</p><p><strong>半同步复制:</strong></p><p>master只保证slaves中的一个操作成功，就返回，其他slave不管。 这个功能，是由google为MySQL引入的。</p></blockquote><h4 id="2-数据库主从复制分析的-7-个问题"><a href="#2-数据库主从复制分析的-7-个问题" class="headerlink" title="2.数据库主从复制分析的 7 个问题?"></a><strong>2.数据库主从复制分析的 7 个问题?</strong></h4><p><strong>问题1：</strong>master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？</p><blockquote><p>假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此slave不应该进行写操作，至少是slave上涉及到复制的数据库不可以写。实际上，这里已经揭示了读写分离的概念。</p></blockquote><p><strong>问题2：</strong>主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？</p><blockquote><p><strong>实现数据备份:</strong><br>类似于高可用的功能，一旦master挂了，可以让slave顶上去，同时slave提升为master。</p><p>**异地容灾:**比如master在北京，地震挂了，那么在上海的slave还可以继续。<br>主要用于实现scale out,分担负载,可以将读的任务分散到slaves上。<br>【很可能的情况是，一个系统的读操作远远多于写操作，因此写操作发向master，读操作发向slaves进行操作】</p></blockquote><p><strong>问题3：</strong>主从复制中有master,slave1,slave2,…等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?</p><blockquote><p>我们在应用程序中可以这样，insert/delete/update这些更新数据库的操作，用connection(for master)进行操作，</p><p>select用connection(for slaves)进行操作。那我们的应用程序还要完成怎么从slaves选择一个来执行select，例如使用简单的轮循算法。</p><p>这样的话，相当于应用程序完成了SQL语句的路由，而且与MySQL的主从复制架构非常关联，一旦master挂了，某些slave挂了，那么应用程序就要修改了。能不能让应用程序与MySQL的主从复制架构没有什么太多关系呢？<br>找一个组件，application program只需要与它打交道，用它来完成MySQL的代理，实现SQL语句的路由。<br>MySQL proxy并不负责，怎么从众多的slaves挑一个？可以交给另一个组件(比如haproxy)来完成。</p><p>这就是所谓的MySQL READ WRITE SPLITE，MySQL的读写分离。</p></blockquote><p><strong>问题4：</strong>如果MySQL proxy , direct , master他们中的某些挂了怎么办？</p><blockquote><p>总统一般都会弄个副总统，以防不测。同样的，可以给这些关键的节点来个备份。</p></blockquote><p><strong>问题5：</strong>当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？如果只发一次，发给了slave-1，那slave-2,slave-3,…它们怎么办？</p><blockquote><p>显 然，应该发N次。实际上，在MySQL master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,…的主，同时slave-1不再负责select。 slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。</p></blockquote><p><strong>问题6：</strong>当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。</p><blockquote><p>应该找一个共享式的缓存，比如memcache来解决。将slave-2,slave-3,…这些查询的结果都缓存至mamcache中。</p></blockquote><p><strong>问题7：</strong>随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？</p><blockquote><p>scale on ?更好的服务器？ 没有最好的，只有更好的，太贵了。。。<br>scale out ? 主从复制架构已经满足不了。<br>可以分库【垂直拆分】，分表【水平拆分】。</p></blockquote><h4 id="3-mysql-高并发环境解决方案"><a href="#3-mysql-高并发环境解决方案" class="headerlink" title="3.mysql 高并发环境解决方案?"></a><strong>3.mysql 高并发环境解决方案?</strong></h4><blockquote><p><strong>MySQL 高并发环境解决方案：</strong> 分库 分表 分布式 增加二级缓存。。。。。</p><p><strong>需求分析：</strong>互联网单位 每天大量数据读取，写入，并发性高。</p><p><strong>现有解决方式：</strong>水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。</p><p><strong>集群方案：</strong>解决DB宕机带来的单点DB不能访问问题。</p><p><strong>读写分离策略：</strong>极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。</p></blockquote><h4 id="4-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）"><a href="#4-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）" class="headerlink" title="4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?"></a><strong>4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?</strong></h4><p>转载：<a href="https://www.cnblogs.com/Bozh/archive/2013/03/18/2966494.html">MySQL REDO日志和UNDO日志</a></p><blockquote><p><strong>Undo Log:</strong></p><p>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用了Undo Log来实现多版本并发控制(简称：MVCC)。</p><p>事务的原子性(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。<br>原理Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。</p><p>之所以能同时保证原子性和持久化，是因为以下<strong>特点：</strong></p><p>更新数据前记录Undo log。<br>为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。<br>Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务。<br>如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。</p><p><strong>缺陷：</strong>每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log。</p><p><strong>Redo Log:</strong></p><p>原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。</p></blockquote><h4 id="八、整理时参考的资料"><a href="#八、整理时参考的资料" class="headerlink" title="八、整理时参考的资料"></a><strong>八、整理时参考的资料</strong></h4><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMTY0NDU3Nw==&amp;mid=2651936134&amp;idx=1&amp;sn=5213a59104f6d2a90bc18d878cafe417&amp;chksm=8d0f3ac8ba78b3deb2ea3473906a37dd205b6e64bfbebe86cc00108242bfa4c49a7d1e509eca&amp;mpshare=1&amp;scene=1&amp;srcid=0707k8Bdz85tDHyVotxEQ9of#rd">java团长 数据库整理</a></p><p><a href="https://my.oschina.net/yanpenglei/blog/1650277">20个数据库常见面试题讲解 - 鹏磊 - 开源中国”</a></p><p><a href="https://m.2cto.com/database/201710/688377.html">34个数据库常见面试题讲解</a></p><p><a href="https://kb.cnblogs.com/page/45712/">漫谈数据库索引<em>知识库</em>博客园</a></p><p><a href="https://blog.csdn.net/u011479200/article/details/78513632">Mysql| 使用通配符进行模糊查询(like,%,_)</a></p><p><a href="http://blog.csdn.net/lc0817/article/details/52757194">MySQL存储引擎中的MyISAM和InnoDB区别详解</a></p><p><a href="https://www.cnblogs.com/kevingrace/p/5685355.html">MySQL存储引擎之MyISAM和Innodb总结性梳理</a></p><p><a href="https://blog.csdn.net/liangxw1/article/details/51197560">https://blog.csdn.net/liangxw1/article/details/51197560</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识点整理（二）</title>
      <link href="/2020/12/22/ji-suan-ji-wang-luo-zhi-shi-dian-zheng-li-er/"/>
      <url>/2020/12/22/ji-suan-ji-wang-luo-zhi-shi-dian-zheng-li-er/</url>
      
        <content type="html"><![CDATA[<p><b><span style="color:#FF4500;">写在最前面：本文章所有内容是本人从网络整理而得，并非商用，仅供学习交流使用。</span></b></p><p><b><span style="color:#FF4500">另一部分参见：</span></b><a href="https://zningj.github.io/2020/12/21/ji-suan-ji-wang-luo-zhi-shi-dian-zheng-li-yi/">计算机网络知识点整理（一） | 不吃香菜的博客</a></p><p><strong>DNS：</strong>Domain Name System，域名系统，是互联网使用的命名系统，用来便于把人们使用的机器名字转换为IP地址。</p><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626677436_5d3a5c6a9457872609.png" alt="5d3a5c6a9457872609">如上图，m.xyz.com需要查找y.abc.com的IP地址：</p><blockquote><ul><li><p>主机m.xyz.com向本地域名服务器进行递归查询。</p><blockquote><p>主机向本地域名服务器查询时一般使用递归查询。</p><ul><li><strong>递归查询</strong>：就是如果本地域名服务器没有所需域名的IP地址，本地域名服务器就以客户的方式向其他根域名服务器继续查询，而不是主机自己进行查询。</li></ul><p>本地域名服务器向其他根域名服务器进行查询的时一般使用迭代查询。</p><ul><li><strong>迭代查询：</strong> 当某个根域名服务器收到本地域名服务器的请求报文时，要么告诉它所需域名的IP地址，要么告诉它下一步应该向哪个服务器发起询问。然后让本地域名服务器自己去查询。</li></ul></blockquote></li><li><p>本地域名服务器迭代查询，先向一个根域名服务器查询。</p></li><li><p>根域名服务器告诉本地域名服务器，下一步应该向顶级域名服务器dns.com查询。</p></li><li><p>顶级域名服务器dns.com告诉本地域名服务器，下一步查找权限域名服务器：dns.adc.com。</p></li><li><p>本地域名服务器向权限域名服务器发起查询。权限域名服务器告诉本地服务器所需的IP地址，本地服务器在告诉给本地主机。</p></li></ul></blockquote><h4 id="补充——域名服务器的分类："><a href="#补充——域名服务器的分类：" class="headerlink" title="补充——域名服务器的分类："></a>补充——域名服务器的分类：</h4><blockquote><ul><li><strong>根域名服务器：</strong> 最高层也是最重要的域名服务器，<strong>所有的根域名服务器都知道所有的顶级域名服务器的域名地址和IP地址</strong>。例如：a.rootserver.net。</li><li><strong>顶级域名服务器：</strong> 这些域名服务器负责管理在该顶级域名服务器上注册的所有的二级域名。例如：com</li><li><strong>权限域名服务器：</strong> 负责一个区的域名服务器，如果当前权限域名服务器不能给出所需的IP地址，则返回客户应该找哪一个权限服务器。</li><li><strong>本地域名服务器：</strong> 本地DNS一般是指你电脑上网时IPv4或者IPv6设置中填写的那个DNS。这个有可能是手工指定的或者是DHCP自动分配的。当一台主机发送DNS请求报文时，这个查询报文就发送给本地域名服务器。</li></ul></blockquote><hr><h3 id="简述HTTP协议以及一次HTTP操作的。"><a href="#简述HTTP协议以及一次HTTP操作的。" class="headerlink" title="简述HTTP协议以及一次HTTP操作的。"></a>简述HTTP协议以及一次HTTP操作的。</h3><p><strong>HTTP 是面向事务的(transaction-oriented)应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。</strong></p><ul><li>HTTP 是面向事务的客户服务器协议。</li><li>HTTP 1.0 协议是无状态的(stateless)。</li><li>HTTP 协议本身也是无连接的，虽然它使用了面向连接的 TCP 向上提供的服务。</li></ul><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626659403_5d3e522382fd145179.png" alt="5d3e522382fd145179"></p><p><strong>一次HTTP操作的过程：</strong></p><blockquote><ul><li>浏览器分析超链指向页面的 URL。</li><li>浏览器向 DNS 请求解析 <a href="http://www.tsinghua.edu.cn/">www.tsinghua.edu.cn</a> 的 IP 地址。</li><li>域名系统 DNS 解析出清华大学服务器的 IP 地址。</li><li>浏览器与服务器建立 TCP 连接</li><li>浏览器发出取文件命令：GET /chn/yxsz/index.htm。</li><li>服务器给出响应，把文件 index.htm 发给浏览器。</li><li>TCP 连接释放。</li><li>浏览器显示“清华大学院系设置”文件 index.htm 中的所有文本。</li></ul></blockquote><hr><h3 id="HTTP报文的格式？"><a href="#HTTP报文的格式？" class="headerlink" title="HTTP报文的格式？"></a>HTTP报文的格式？</h3><p><strong>HTTP报文分为两类：请求报文和响应报文。它们都由三部分组成：开始行、首部行、实体主体。区别就是开始行不同。</strong></p><p><img src="https://i.loli.net/2019/07/29/5d3e5c39f101f64538.png" alt="5d3e5c39f101f64538"></p><ul><li><p><strong>首部行：</strong> 用来说明服务器、浏览器、或报文主体的一些信息。</p></li><li><p><strong>实体主体：</strong> 一般不用。</p></li><li><p><strong>开始行：</strong>对于请求报文来说，就是请求行。对于响应报文来说，就是状态行。</p><blockquote><p><strong>请求行：</strong> 包括三个内容：方法，URL以及HTTP的版本。后面有关于方法的详解。</p><p><strong>状态行：</strong> 包括三个内容：HTTP版本、状态码以及状态码的简单短语。后面有关于状态码的详解。</p></blockquote></li></ul><hr><h3 id="HTTP请求报文中的方法有哪些？"><a href="#HTTP请求报文中的方法有哪些？" class="headerlink" title="HTTP请求报文中的方法有哪些？"></a>HTTP请求报文中的方法有哪些？</h3><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626659330_5d3e537d38ae253055.png" alt="5d3e537d38ae253055"></p><hr><h3 id="get与post的区别。"><a href="#get与post的区别。" class="headerlink" title="get与post的区别。"></a>get与post的区别。</h3><p><a href="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp">原博文——get与post的区别-1</a></p><p><a href="https://www.zhihu.com/question/28586791">原博文——get与post的区别-2</a></p><table><thead><tr><th></th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。</td></tr><tr><td>对数据类型的限制</td><td>只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td>数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><blockquote><p>get方法一般用于请求获取信息，post方法一般用于向服务器提交一些修改信息。比如，我们输入一个网页地址，我们使用get方法获取页面的信息。如果我们要在某个网站上购买一件商品，我们使用post方法提交一个表单，服务器就记录下了你要购买的商品。基于这样的场景，可以得出：</p><ul><li>get方法请求的内容可以添加为标签并且能被缓存，post则不能添加为标签和被缓存（因为post请求的内容如果能添加为标签和被缓存的话，你下次点击这个标签就会直接购买商品了，很不安全）。</li><li>刷新的时候，get方法可以重新请求，无害，但是post的方法会重新提交表单（服务器这时候会告知用户），有隐患。</li></ul><p>此外，get的方法携带的数据一般放在url的后面，post方法携带的数据一般在http报文里面。因此，由于浏览器的限制，get携带的数据长度一般是有限制的，而post方法则无限制。</p></blockquote><hr><h3 id="HTTP1-0、HTTP1-1和HTTP2-0的区别？"><a href="#HTTP1-0、HTTP1-1和HTTP2-0的区别？" class="headerlink" title="HTTP1.0、HTTP1.1和HTTP2.0的区别？"></a>HTTP1.0、HTTP1.1和HTTP2.0的区别？</h3><p><a href="https://www.cnblogs.com/heluan/p/8620312.html">原博文——HTTP各版本之间的区别</a></p><p><strong>HTTP1.0与HTTP1.1区别：</strong></p><blockquote><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ul><li><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li><strong>长连接、持续连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li></ul></blockquote><p><strong>HTTP1.1与HTTP2.0的区别：</strong></p><blockquote><ul><li><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li><li><strong>header压缩</strong>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能</li></ul></blockquote><hr><h3 id="HTTP的状态码以及代表的意思？"><a href="#HTTP的状态码以及代表的意思？" class="headerlink" title="HTTP的状态码以及代表的意思？"></a>HTTP的状态码以及代表的意思？</h3><p><a href="https://blog.csdn.net/qq_35689573/article/details/82120851">原博文——常见的14种HTTP状态码</a></p><p><strong>1XX——表示通知信息，如请求收到了或正在进行处理</strong></p><p><strong>2XX——表明请求被正常处理了</strong></p><blockquote><ul><li>200 OK：请求已正常处理。</li><li>204 No Content：请求处理成功，但没有任何资源可以返回给客户端，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</li><li>206 Partial Content：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</li></ul></blockquote><p><strong>3XX——表明浏览器需要执行某些特殊的处理以正确处理请求</strong></p><blockquote><ul><li>301 Moved Permanently：资源的uri已更新，你也更新下你的书签引用吧。永久性重定向，请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。</li><li>302 Found：资源的URI已临时定位到其他位置了，姑且算你已经知道了这个情况了。临时性重定向。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。</li><li>303 See Other：资源的URI已更新，你是否能临时按新的URI访问。该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。当301,302,303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。</li><li>304 Not Modified：资源已找到，但未符合条件请求。该状态码表示客户端发送附带条件的请求时（采用GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304。</li><li>307 Temporary Redirect：临时重定向。与302有相同的含义。</li></ul></blockquote><p><strong>4XX——表明客户端是发生错误的原因所在。</strong></p><blockquote><ul><li>400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。</li><li>401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。</li><li>403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）</li><li>404 Not Found：服务器上没有请求的资源。路径错误等。</li></ul></blockquote><p><strong>5XX——服务器本身发生错误</strong></p><blockquote><ul><li>500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。</li><li>503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。</li></ul></blockquote><hr><h3 id="简述HTTPS以及实现过程。（为什么要使用HTTPS、HTTPS基本概念、加密方式、实现过程）"><a href="#简述HTTPS以及实现过程。（为什么要使用HTTPS、HTTPS基本概念、加密方式、实现过程）" class="headerlink" title="简述HTTPS以及实现过程。（为什么要使用HTTPS、HTTPS基本概念、加密方式、实现过程）"></a>简述HTTPS以及实现过程。（为什么要使用HTTPS、HTTPS基本概念、加密方式、实现过程）</h3><p><strong>为什么需要HTTPS（HTTP Secure 或者 HTTP over SSL）：</strong></p><blockquote><p>HTTP有很多<strong>安全漏洞</strong>：</p><ul><li>通信使用明文（不加密），内容可能会被窃听。</li><li>不验证通信方的身份，因此有可能遭遇伪装。</li><li>无法证明报文的完整性，所以有可能已遭篡改。</li></ul></blockquote><p><strong>也就是说：HTTP+加密+认证+完整性保护=HTTPS</strong></p><p><strong>HTTPS是身披SSL外壳的HTTP：</strong></p><blockquote><ul><li>HTTPS并非是应用层的一种新协议。只是通信接口部分用SSL和TLS协议代替而已。</li><li>通常情况下，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信。</li></ul></blockquote><p><strong>加密方式：对称加密与非对称加密</strong></p><blockquote><ul><li><p><strong>对称加密：</strong>加密和解密都是同一个密匙。</p><blockquote><p>对称加密速度快，适合Https加密算法，但是服务器和浏览器之间<strong>传递密钥的过程</strong>被人监听，相当明文传输。</p></blockquote></li><li><p><strong>非对称加密：</strong>密钥成对出现，分为公钥和私钥，公钥加密需要私钥解密，私钥加密需要公钥解密。</p><blockquote><p>服务端只将公钥暴露，浏览器使用公钥对消息进行非对称加密，服务端用私钥解密。但是服务端向浏览器回复的时候，只能用私钥进行加密，浏览器只能用公钥解密。但是：公钥是所有人都知道的，所有人都可以读取服务端回复的消息来进行解密，所以<strong>解决不了服务端向浏览器传递消息</strong>。</p></blockquote></li></ul><p><strong>HTTPS加密方式：混合加密方式，对称加密与非对称加密结合使用。</strong></p><blockquote><ul><li>使用非对称加密方式安全地交换在稍后的共享密钥加密中要使用的密钥。</li><li>确保交换的密钥是安全的前提下，使用共享密钥加密方式进行通信。</li></ul></blockquote></blockquote><p><strong>HTTPS工作流程：</strong></p><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626669165_5d3e9cdc64fcb16806.png" alt="5d3e9cdc64fcb16806"></p><blockquote><p>步骤 <strong>1</strong>： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p><p>步骤 <strong>2</strong>： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p><p>步骤 <strong>3</strong>： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p><p>步骤 <strong>4</strong>： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</p><p>步骤 <strong>5</strong>： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p><p>步骤 <strong>6</strong>： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</p><p>步骤 <strong>7</strong>： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p><p>步骤 <strong>8</strong>： 服务器同样发送 Change Cipher Spec 报文。</p><p>步骤 <strong>9</strong>： 服务器同样发送 Finished 报文。</p><p>步骤 <strong>10</strong>： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接</p><p>就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p><p>步骤 <strong>11</strong>： 应用层协议通信，即发送 HTTP 响应。</p><p>步骤 <strong>12</strong>： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。</p></blockquote><hr><h3 id="简述HTTPS与HTTP的区别？"><a href="#简述HTTPS与HTTP的区别？" class="headerlink" title="简述HTTPS与HTTP的区别？"></a>简述HTTPS与HTTP的区别？</h3><p><a href="https://www.cnblogs.com/wqhwe/p/5407468.html">原博文——HTTPS与HTTP的区别</a></p><p><strong>HTTP：</strong>是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p><strong>HTTPS：</strong>是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li></ul><hr><h3 id="IP数据报格式？"><a href="#IP数据报格式？" class="headerlink" title="IP数据报格式？"></a>IP数据报格式？</h3><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626659313_5d4234f6c54cb34330.png" alt="5d4234f6c54cb34330"></p><p>IP数据报首部可以分为固定长度（20字节）和可选长度。固定长度是所有IP数据报所必须的。<strong>固定部分个字段的意义如下：</strong></p><blockquote><ul><li><p><strong>版本：</strong> 占4位，指IP协议的版本，通信双方的协议版本必须一致。</p></li><li><p><strong>首部长度：</strong> 占4位，可表示的最大十进制数是15（1111）。它的单位是4字节（也就是32位），因此首部长度最小值为5（固定长度部分），可选长度最长为40字节。</p></li><li><p><strong>区分服务：</strong> 占8位，用来获得更好的服务。</p></li><li><p><strong>总长度：</strong> 占16位，首部和数据部分的总长度，单位为字节。因此IP数据报的最大长度为2^16-1。</p></li><li><p><strong>标识：</strong> 占16位。当数据报的长度超过网络的最大传送单元使，就给该数据报的所有分片赋值相同的标识，相同的标识字段的值使分片后的各数据报片能正确的重装成原来的数据报。</p></li><li><p><strong>标志：</strong> 占3位，但是只有两位具有意义。</p><blockquote><ul><li>标记字段中的最低位记为MF。MF=1表示后面还有分片，MF=0表示这是最后一个分片。</li><li>标志字段中间的一位记为DF，意思是能否分片，只有DF=0时才能分片。</li></ul></blockquote></li><li><p><strong>片偏移：</strong> 占13位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，数据片相对于初始位置的距离。单位是8字节。因此，除去最后一个数据片，每个数据片的长度都是8字节的倍数。</p></li><li><p><strong>生存时间：</strong> 占8位，TTL（Time To Live），单位为跳数，跳数表明该数据报至多能在互联网中经过多少个路由器，每经过一个路由器就减1。</p></li><li><p><strong>协议：</strong> 占8位，协议字段指出该数据报携带的数据是使用哪种协议，以便使目的主机的IP层知道应将数据部分上交给哪个协议进行处理。</p><blockquote><table><thead><tr><th>协议名</th><th>ICMP</th><th>IGMP</th><th>IP</th><th>TCP</th><th>EGP</th><th>IGP</th><th>UDP</th><th>IPv6</th><th>ESP</th><th>OSPF</th></tr></thead><tbody><tr><td>协议字段值</td><td>1</td><td>2</td><td>4</td><td>6</td><td>8</td><td>9</td><td>17</td><td>41</td><td>50</td><td>89</td></tr></tbody></table></blockquote></li><li><p><strong>首部校验和：</strong> 占16位，这个字段只检验数据报的首部，但是不包括数据部分。</p><blockquote><p><img src="https://i.loli.net/2019/08/01/5d423d384cdf496110.png" alt="5d423d384cdf496110"></p><ul><li>在发送方，先把数据报划分为许多16位的字的序列，并把校验和字段置为0，。</li><li>用反码算术运算（从低位到高位计算，0+0等于0,0+1等于1,1+1等于0，但是要进1。）把所有的16位字相加后，将得到的反码写入校验和字段。</li><li>接收方接收到数据报之后，将首部的所有16位字再使用反码运算相加一次，将得到的和取反码，即得出接收方的检验和的计算结果。如果结果全为0，则代表首部未发生变化，保留该数据报，反之则丢弃。</li></ul><p>参考：<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">原码、补码、反码详解</a></p></blockquote></li><li><p><strong>源地址：</strong> 占32位。</p></li><li><p><strong>目的地址：</strong> 占32位。</p></li></ul></blockquote><hr><h3 id="UDP数据报格式？"><a href="#UDP数据报格式？" class="headerlink" title="UDP数据报格式？"></a>UDP数据报格式？</h3><p><a href="https://www.cnblogs.com/anzhengyu/p/11232699.html">原博文——UDP数据报格式</a></p><p>UDP用户数据报分为 = 首部字段 （8个字节，4个字段，每个字段2个字节）+ 数字字段。</p><p>首部字段：</p><ul><li>源端口： 源端口号。在需要对方回信的时候选用，不需要填0。</li><li>目的端口： 目的端口号。必填。</li><li>长度： UDP用户数据报的长度。最小为8。</li><li>检验和：检测UDP用户数据报传输过程中是否有错。有错就丢弃。</li></ul><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626659129_5d3524ef4841844167.png" alt="5d3524ef4841844167"></p><p><strong>补充：UDP检验首部校验和的方法：</strong></p><blockquote><p>在计算检验和时，需要在用户数据报之前加12字节的伪首部。</p><p>所谓伪首部，是指他并不是UDP用户数据报的真正首部，只是在计算检验和的时候，临时加上的，检验和就是按照这个临时的用户数据报计算的。既不下传也不向上提交。伪首部的格式如上图。</p><p>UDP计算检验和与IP数据报类似，只是UDP的首部校验和把首部和数据一起都检验了。步骤如下：</p><ul><li>在发送方，首先先把全零放到检验和字段；</li><li>再把伪首部和UDP用户数据报看成是由许多16位的字串连接起来的；</li><li>然后按二进制反码计算出这些16位字的和，并将此和的反码写入检验和字段后，就发送这样的用户数据报。</li><li>在接收方，把收到的UDP用户数据报连同伪首部（以及可能的填充全零字节）一起，按二进制反码求这些16位字的和。</li><li>若无差错时其结果应全为1；否则就是有差错出现，可以选择丢失，可以上传（但是要附上错误信息）。</li></ul><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626662009_5d354dcc35e6338961.png" alt="5d354dcc35e6338961"></p></blockquote><hr><h3 id="TCP报文段格式？"><a href="#TCP报文段格式？" class="headerlink" title="TCP报文段格式？"></a>TCP报文段格式？</h3><p><a href="https://www.cnblogs.com/anzhengyu/p/11232770.html">原博文——TCP报文首部格式</a></p><p>TCP虽然是面向字节流的，但是TCP传输的数据单元却是报文段。一个报文段可以分为首部和数据两部分。</p><p>TCP报文段的首部的前20个字节是固定的，后面的4n字节是需要增加的选项。因此TCP首部的最小长度是20字节。</p><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626659105_5d356311a685317386.png" alt="5d356311a685317386"><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626659105_5d356311a685317386.png" alt="5d356311a685317386"></p><p>首部部分字段的意义如下：</p><blockquote><ul><li><p>源端口和目的端口：各占2个字节，分别写入源端口号和目的端口号。TCP的分用功能也是通过端口号实现的。</p></li><li><p>序号：占4字节。在TCP连接中传送的字节流中的每一个字节都按照顺序编号。首部中的序号字段值则代表本报文段所发送的数据的第一个字节的序号。</p></li><li><p>确认号：占4字节。代表期望收到对方下一个报文段的第一个数据字节的序号。需要注意：<code>若确认号=N，则表明：到序号N-1为止的所有数据都已正确收到</code></p></li><li><p>数据偏移：占4位。他指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。一般情况下为20字节，但是首部中还有不确定的选项字段。它的单位是4字节，而它的最大值是15，因此数据偏移最大值为60字节，也就是说选项不能超过40字节。</p></li><li><p>保留：占6位。以防后续使用。</p><p><strong>下面是6个控制位，每个占一位：</strong></p></li><li><p>紧急URG：当URG=1时，表明紧急字段有效，它告诉系统此报文中有紧急数据，应该尽快传送。</p></li><li><p>确认ACK：仅当ACK=1时确认号字段才有效。</p></li><li><p>推送PSH：当两个应用进程进行交互式的通信时，有时一端的应用进程希望在键入一个命令后立即就能收到对方的相应，这时设置PSH=1。</p></li><li><p>复位RST：当RST=1时，表明TCP连接中出现严重错误，必须释放连接，再重新建立运输连接。RST=1还可以用来拒绝一个非法的报文段或拒绝打开一个连接。</p></li><li><p>同步SYN：在建立连接时用来同步序号。当SYN=1，ACK=0时代表是连接请求报文段。若对方同意建立连接，则应在相应报文段中使SYN=1，ACK=1。也就是说，SYN=1代表连接请求或者连接接受报文。</p></li><li><p>终止FIN。用于释放一个连接。当FIN=1时，代表此报文段的发送方的数据已发送完毕，并且请求释放运输连接。</p><p><strong>控制位到这结束。</strong></p></li><li><p>窗口：占2字节。窗口值告诉对方：从本报文段中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以设置这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其窗口大小的依据。</p></li><li><p>检验和：占2字节。检验的范围包括首部字段和数据字段。和UDP检验的方法一样，只不过把伪首部第四个字段的17改成6.</p></li><li><p>紧急指针：占2字节。只有在紧急URG=1时才有效，它指出本报文段中的紧急数据的字节数。</p></li><li><p>选项：长度可变，最大40字节</p><blockquote><p>TCP最初只规定了一种选项，即最大报文长度MSS。MSS是每一个TCP报文段中的数据字段的最大长度，而并不是整个TCP报文段的长度。</p></blockquote></li></ul></blockquote><hr><h3 id="以太网MAC帧格式？"><a href="#以太网MAC帧格式？" class="headerlink" title="以太网MAC帧格式？"></a>以太网MAC帧格式？</h3><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626664984_5d424c85e043a98902.png" alt="5d424c85e043a98902"></p><p>以太网MAC帧较为简单，由五个字段组成，前两个字段分别为6字节长的<strong>目的地址</strong>和<strong>源地址</strong>。第三个字段是2字节的<strong>类型字段</strong>，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。第四个字段是<strong>数据字段</strong>，其长度为46~1500字节（46字节是因为最小长度64字节减去18字节的首部和尾部）。最后一个字段是4字节的<strong>帧检测</strong>序列FCS（使用CRC检测）。</p><p>如果对你有帮助，就推荐+收藏吧！😜😜</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识点整理（一）</title>
      <link href="/2020/12/21/ji-suan-ji-wang-luo-zhi-shi-dian-zheng-li-yi/"/>
      <url>/2020/12/21/ji-suan-ji-wang-luo-zhi-shi-dian-zheng-li-yi/</url>
      
        <content type="html"><![CDATA[<p><b><span style="color:#FF4500;">写在最前面：本文章所有内容是本人从网络整理而得，并非商用，仅供学习交流使用。</span></b></p><p><b><span style="color:#FF4500">另一部分参见：</span></b><a href="https://zningj.github.io/2020/12/22/ji-suan-ji-wang-luo-zhi-shi-dian-zheng-li-er/">计算机网络知识点整理（二） | 不吃香菜的博客</a></p><p><img src="/2020/12/21/ji-suan-ji-wang-luo-zhi-shi-dian-zheng-li-yi/1.jpg" alt="计算机网络体系结构"></p><ul><li><p><strong>OSI七层协议体系：</strong> 概念清楚，理论也比较完整，但是它既复杂也不实用。</p></li><li><ul><li><p>物理层：</p><blockquote><ul><li>计算机网络体系中最底层，为所有网络/数据数据通信提供物理的通信线路。另外通信线路可以通过信道复用方式在一条物理线路中划分多条信道。默认情况下，一条物理线路就是一条信道。</li><li><strong>常用协议：</strong> ISO2110，IEEE802，IEEE802.2</li><li><strong>常用硬件：</strong> 中继器、集线器、还有我们通常说的双绞线也工作在物理层</li></ul></blockquote></li><li><p>数据链路层：</p><blockquote><ul><li>为同一局域网内部的网络/数据通信提供点到点的数据传输通道，通过MAC地址寻址把数据传输到目的节点。</li><li>数据链路层的通信只能在同一网段进行，要在不同网段间进行，必须依靠网络层和传输层。</li><li>数据链路层提供的不是物理线路，而是在物理层的物理线路基础之上，通过数据链路层协议构建的虚拟数据传输通道，并且只能在同一段内进行数据转发。</li><li><strong>常用协议：</strong>SLIP，CSLIP，PPP，ARP，RARP，MTU。<strong>（在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层。）</strong></li><li><strong>常用硬件：</strong>网桥、以太网交换机、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层）</li></ul></blockquote></li><li><p>网络层：</p><blockquote><ul><li>为不同网段之间的数据转发提供路径选择，通过IP地址（也有可能是其他网络地址）把数据包转发到目的节点。网络层这种寻址功能我们称为“路由寻址”，就是选择哪一条路径到达下一个节点。</li><li>网络层的功能仅起到不同网络间转发数据包的功能，最终数据还是要在目的网络的数据链路层进行传输，在到达下一个节点设备（如路由器）再进行转发。</li><li><strong>常用协议：</strong>IP，ICMP，RIP，OSPF，BGP，IGMP</li><li><strong>常用硬件：</strong>路由器</li></ul></blockquote></li><li><p>运输层：</p><blockquote><ul><li>是在下面三层构建的网络平台基础上专门为通信双方构建端到端（不是点到点）的数据传输通道，使通信双方就像在直接进行数据传输一样。这个端到端的传输通道是可以跨网络的。</li><li><strong>常用协议：</strong> TCP，UDP</li><li><strong>常用硬件：</strong>网关</li></ul></blockquote></li><li><p>会话层：</p><blockquote><ul><li>为具体的用户建立会话进程。</li><li><strong>常用协议：</strong> 无</li><li><strong>常用硬件：</strong>网关</li></ul></blockquote></li><li><p>表示层：</p><blockquote><ul><li>是对用户网络应用数据的具体解释，包括在网络通信中可采用的信息技术、可采用的加密方式等。</li><li><strong>常用协议：</strong> 无</li><li><strong>常用硬件：</strong>网关</li></ul></blockquote></li><li><p>应用层：</p><blockquote><ul><li>用户进行具体网络应用的层次，是具体网络应用的体现者，负责接受用户的各种网络应用进程的调用。</li><li><strong>常用协议：</strong> TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</li><li><strong>常用硬件：</strong>网关</li></ul></blockquote></li></ul></li><li><p><strong>TCP/IP四层协议体系：</strong> 实际应用非常广泛，从实质上讲，TCP/IP体系只有最上面的三层，最底下的网络接口层实际上没有什么内容。</p></li><li><ul><li>网络接口层：合并了原来OSI中的物理层和数据链路层，提供局域网的功能。</li><li>网际层：同OSI网络层</li><li>运输层：同OSI运输层</li><li>应用层：合并了OSI中最上面的三层。</li></ul></li><li><p><strong>五层协议体系：</strong> 《计算机网络第七版》中，为了方便介绍网络原理，而引人的体系。实际应用还是TCP/IP协议体系。</p></li><li><ul><li>物理层：同OSI物理层</li><li>数据链路层：同OSI数据链路层</li><li>网络层：同OSI网络层</li><li>运输层：同OSI运输层</li><li>应用层：合并了OSI中最上面的三层。</li></ul></li></ul><hr><h3 id="OSI体系与TCP-IP体系的联系与区别？"><a href="#OSI体系与TCP-IP体系的联系与区别？" class="headerlink" title="OSI体系与TCP/IP体系的联系与区别？"></a>OSI体系与TCP/IP体系的联系与区别？</h3><ul><li><p>相同点：</p><blockquote><ul><li>层次结构划分思想相同；</li><li>总体层次结构相同；</li><li>核心组成一样，都定义了“服务“、”接口“、”协议“上重要核心。</li></ul></blockquote></li><li><p>不同点：</p><blockquote><ul><li>适用范围不同：OSI在标准协议发明前就产生了，不偏重于任何特定的网络类型，具有最广泛的理论参考性，是一个理想代的模型；而TCP/IP则相反，它是针对TCP/IP协议簇产生的，最具实践性；</li><li>层次结构不同：TCP/IP体系中没有会话层和表示层；</li><li>支持通信模式不同：OSI同时支持无连接和面向连接的网络通信（不仅支持TCP/IP协议网络中无连接的IP网络协议，同时支持NetWare SPX/IPX网络中的面向连接的SPX协议等）。TCP/IP模型的网络层只提供无连接的服务。</li><li>所包括的通信协议不同。</li></ul></blockquote></li></ul><hr><h3 id="路由器、中继器、集线器、交换机、网关、网桥各自的概念以及作用？"><a href="#路由器、中继器、集线器、交换机、网关、网桥各自的概念以及作用？" class="headerlink" title="路由器、中继器、集线器、交换机、网关、网桥各自的概念以及作用？"></a>路由器、中继器、集线器、交换机、网关、网桥各自的概念以及作用？</h3><ul><li><p>路由器（Router）：</p><blockquote><ul><li>工作范围：网络层，不同网络之间</li><li>功能：是一种计算机网络设备，提供了<strong>路由与转送</strong>两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。</li></ul></blockquote></li><li><p>中继器：</p><blockquote><ul><li>工作范围：物理层</li><li>功能：中继器是将一条电缆传输过来的信号经过放大和调整以后再传输给另一个电缆。因此，它是物理层上的网络延长设备。一般而言，中继器连接的双方是相同的物理介质，但是有些也可以完成不同媒介之间的连接。但是中继器只是完成了信号的转换，而不能完成转发。也就是说，中继器不能再传输速度不同的介质之间完成转发。</li></ul></blockquote></li><li><p>集线器：</p><blockquote><ul><li>工作范围：物理层</li><li>功能：如果每个设备只有一个对外接口，那么意味着只能建立一对一的点到点的通信。为了能够让通信“一对多”，需要将信号复制广播，于是，产生了集线器。集线器的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。</li></ul></blockquote></li><li><p>交换机：</p><blockquote><ul><li>工作范围：数据链路层</li><li>功能：交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。也就是说，交换机也有一张表，记录的是port-mac。按照传输数据包的层次，交换机可以分为一、二…..七层交换机。</li></ul></blockquote></li><li><p>网桥：</p><blockquote><ul><li>工作范围：数据链路层</li><li>功能：网桥能够连接两个不同的数据链路，即使他们的传输速度不同。它能够识别数据链路中的数据帧，并将这些数据帧临时存储在内存中，然后在重新生成一个新的数据帧转发给另外一个网段。网桥还具有检错功能。因此，网桥有时候也会被称为2层交换机。（数据链路层设备）有些网桥能够记住曾今通过自己转发的数据帧的MAC地址，并保存在内部的内存表中。这种网桥被称为自学式网桥。</li></ul></blockquote></li><li><p>网卡：</p><blockquote><ul><li><p>工作范围：物理层、数据链路层</p></li><li><p>功能：又称<strong>网络接口控制器</strong>，<strong>网络适配器</strong>（network adapter），<strong>网卡</strong>（network interface card），或<strong>局域网接收器</strong>（LAN adapter），是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件。网卡的作用是负责接收网络上的数据包，通过和自己本身的物理地址相比较决定是否为本机应接信息，解包后将数据通过主板上的总线传输给本地计算机，另一方面将本地计算机上的数据打包后送出网络。</p><blockquote><ul><li>实现与主机总线的网络通讯连接，网卡相当于桥梁设备</li><li>实现主机与介质之间的电信号匹配</li><li>提供数据缓冲能力</li></ul></blockquote></li></ul></blockquote></li><li><p>网关：</p><blockquote><ul><li>工作范围：运输层、应用层</li><li>功能：网关（Gateway）负责第三层（网络层）以上的数据中继，实现不同体系结构的网络协议转换，它通常采用软件的方法实现，并且与特定的应用服务一一对应。比如：OSI的文件传输服务FTAM和TCP/IP的文件传输服务FTP，尽管二者都是文件传输但是由于所执行的协议不同不能直接进行通信，而需要网关将两个文件传输系统互连，达到相互进行文件传输的目的。</li></ul></blockquote></li></ul><hr><h3 id="交换机与路由器的区别？"><a href="#交换机与路由器的区别？" class="headerlink" title="交换机与路由器的区别？"></a>交换机与路由器的区别？</h3><ul><li><p>工作层次不同</p><blockquote><p>交换机是工作在OSI/RM体系结构的第二层（数据链路层），而路由器一开始就设计工作在OSI模型的网络层。由于交换机工作在OSI的第二层（数据链路层），所以它的工作原理比较简单，而路由器工作在OSI的第三层（网络层），可以得到更多的协议信息，路由器可以做出更加智能的转发决策。</p></blockquote></li><li><p>数据转发所依据的对象不同</p><blockquote><p>交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用不同网络的ID号（即IP地址）来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络，有时这些第三层的地址也称为协议地址或者网络地址。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。</p></blockquote></li><li><p>传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域</p><blockquote><p>由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。</p></blockquote></li><li><p>路由器提供了防火墙的服务</p><blockquote><p>路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。 交换机一般用于LAN-WAN的连接，交换机归于网桥，是数据链路层的设备，有些交换机也可实现第三层的交换。路由器用于WAN-WAN之间的连接，可以解决异性网络之间转发分组，作用于网络层。他们只是从一条线路上接受输入分组，然后向另一条线路转发。这两条线路可能分属于不同的网络，并采用不同协议。相比较而言，路由器的功能较交换机要强大，但速度相对也慢，价格昂贵，第三层交换机既有交换机线速转发报文能力，又有路由器良好的控制功能，因此得以广泛应用。</p></blockquote></li></ul><hr><h3 id="IP地址是如何分类的？"><a href="#IP地址是如何分类的？" class="headerlink" title="IP地址是如何分类的？"></a>IP地址是如何分类的？</h3><p><strong>IP地址 = 网络号 + 主机号</strong></p><blockquote><ul><li>A、B、C类IP地址的网络号字段分别是1、2、3个字节长，而在网络号的1-3位是类别位，分别是：0、10、110。</li><li>A、B、C类IP地址的主机号字段分别为3、2、1个字节。</li><li>A、B、C类IP地址是单播地址，D类IP地址（前四位为1110）为多播地址，E类IP地址（前四位1111）保留为以后使用。</li></ul></blockquote><hr><h3 id="A、B、C三类常用的IP地址的指派范围？有哪些特殊的IP地址以及它们的含义？"><a href="#A、B、C三类常用的IP地址的指派范围？有哪些特殊的IP地址以及它们的含义？" class="headerlink" title="A、B、C三类常用的IP地址的指派范围？有哪些特殊的IP地址以及它们的含义？"></a>A、B、C三类常用的IP地址的指派范围？有哪些特殊的IP地址以及它们的含义？</h3><p><img src="https://i.loli.net/2019/07/25/5d3903a142c0641505.jpg" alt="5d3903a142c0641505"></p><p><strong>特殊的IP地址</strong>：</p><blockquote><ul><li>网络号全0代表“this，这个”，也就是本网络的意思，当网络号和主机号全为0时则代表本网络上的本主机。网络号为0，主机号为host-id，则代表本网络上的某个主机（主机号为host-id）。这类IP地址只能作为源地址，不能作为目的地址。</li><li>网络号和主机号全为1，代表只在本网络上进行广播，路由器不转发，不可以作为源地址，可以作为目的地址。</li><li>网络号为net-id，主机号为全1，代表对net-id上所有的主机进行广播。可以作为目的地址，不可以作为源地址。</li><li>网络号为127（01111111），保留作为本地环回测试本主机的进程之间的通信只用。主机号可以为非全0或者全1的任何数，可以作为源地址，也可以作为目的地址。</li></ul></blockquote><p><strong>可以指派的IP地址：</strong></p><blockquote><ul><li>A类地址的网络号中：全0和127是不指派的；主机号中：全0代表本主机所连接的单个网络地址，全1代表网络上的所有主机，也是不指派的。</li><li>B类IP地址网络号中：<strong>128.0.0.0不指派</strong>；主机号中：全0和全1也不指派。</li><li>C类IP地址网络号中：<strong>192.0.0.0不指派</strong>；主机号中：全0和全1也不指派。</li></ul></blockquote><p><strong>总结：</strong></p><blockquote><ul><li>网络号全为0：本网络</li><li>主机号全为0：代表单个网络地址</li><li>主机号全为1：代表某个网络上的所有主机</li></ul></blockquote><hr><h3 id="简述ARP协议的工作原理。"><a href="#简述ARP协议的工作原理。" class="headerlink" title="简述ARP协议的工作原理。"></a>简述ARP协议的工作原理。</h3><blockquote><ul><li><p><strong>ARP：</strong>Address Resolution Protocol，地址解析协议</p></li><li><p><strong>功能：</strong>为了从网络层的IP地址，解析出在数据链路层使用的硬件地址。注意：ARP解决的是同一局域网上的主机和路由器的IP地址和硬件地址的映射问题。</p></li><li><p><strong>工作原理：</strong></p><p>每一台主机都设有一个ARP告诉缓存，里面有本局域网上的各个主机和路由器的IP地址到硬件地址的映射。当A要向本局域网上的B发送IP数据报时，则A先查看ARP高速缓存中有无B的IP地址：</p><ul><li>如果有：就在ARP高速缓存中查出该IP地址的硬件地址，把这个硬件地址写入MAC帧，再通过局域网将MAC帧发往此硬件地址。</li><li>如果没有：ARP向本局域网广播（请求分组是广播，响应分组是单播）发送一个ARP请求分组，表明自己的IP地址和硬件地址以及要寻找的IP地址。B接收到请求分组后，收下并且向A发送相应分组，其余主机不做相应。A收到B的相应分组后再进行常规的数据传输。</li></ul></li></ul></blockquote><p><strong>补充：</strong></p><blockquote><p><strong>生存时间：</strong>ARP对每一个映射地址的项目都设有生存时间（例如10-20分钟），这是为了防止该局域网中某些主机的硬件地址发生改变的情况。</p></blockquote><hr><h3 id="简述ICMP协议和IGMP协议。"><a href="#简述ICMP协议和IGMP协议。" class="headerlink" title="简述ICMP协议和IGMP协议。"></a>简述ICMP协议和IGMP协议。</h3><p><strong>ICMP：</strong></p><blockquote><ul><li>Internet Control Message Protocol，网际控制报文协议。</li><li><strong>功能：</strong> 为了更加有效的转发IP数据报和提高交付成功的机会，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。</li></ul></blockquote><p><strong>IGMP：</strong></p><blockquote><ul><li>Internet Group Management Protocol，网际组管理协议。</li><li><strong>功能：</strong> IGMP协议是让连接在本局域网上的多播路由器知道本局域网上是否有主机（严格来讲是主机上的某个进程）参加或者退出了某个多播组。</li></ul></blockquote><hr><h3 id="TCP和UDP的区别。"><a href="#TCP和UDP的区别。" class="headerlink" title="TCP和UDP的区别。"></a><strong>TCP和UDP的区别。</strong></h3><p>TCP：传输控制协议，Transmission Control Protocol</p><p>UDP：用户数据报协议，User Datagram Protocol</p><ul><li><p><strong>TCP是面向连接的，UDP是无连接的。</strong></p><blockquote><p>TCP在传输数据之前必须建立有效的连接，数据传输后也要释放连接。而UDP在传输前不需要建立连接，远程主机接收到UDP用户数据报之后也不需要给出确认。</p></blockquote></li><li><p><strong>TCP提供可靠的全双工通信，UDP尽最大努力通信，不保证可靠。</strong></p></li><li><p><strong>TCP占用资源多，UDP占用资源少。</strong></p></li><li><p><strong>运输协议数据单元不同，TCP是TCP报文段，UDP是用户数据报。</strong></p></li><li><p><strong>TCP是面向字节流的，UDP是面向报文的。</strong></p><blockquote><ul><li><strong>面向字节流</strong>：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但是TCP把应用程序交下来的数据只看出一连串的无结构字节流。TCP不知道字节流的具体含义，也不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块之间的大小关系。但是接收方应用程序收到的字节流必须与发送方发送的字节流完全一致。</li><li><strong>面向报文</strong>：发送方的UDP对应用程序交下来的报文添加首部后直接交付给IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</li></ul></blockquote></li><li><p><strong>TCP有拥塞控制，UDP没有拥塞控制</strong></p></li><li><p><strong>TCP不提供广播和多播服务，UDP支持一对一、多对一、一对多、多对多的交互通信。</strong></p></li></ul><hr><h3 id="TCP如何保证可靠传输？"><a href="#TCP如何保证可靠传输？" class="headerlink" title="TCP如何保证可靠传输？"></a>TCP如何保证可靠传输？</h3><p><a href="https://blog.csdn.net/liuchenxia8/article/details/80428157">原博文——TCP如何保证可靠传输</a></p><ul><li><p><strong>校验和：</strong> TCP在发送报文之前，发送方要计算校验和，收到数据后，接收方也要计算校验和，如果校验和不相等则丢弃。</p></li><li><p><strong>序列号与确认应答：</strong></p><blockquote><ul><li><strong>序列号：</strong>TCP传输时将每个字节的数据都进行了编号，这就是序列号。</li><li><strong>确认应答：</strong>TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</li><li><strong>序列号的作用</strong>不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。</li></ul></blockquote></li><li><p><strong>超时重传:</strong> 在TCP传输过程中，我们在发送一部分数据后，都会等待对方的ACK确认报文，如果中间出现差错，没有收到ACK报文，这时候需要启动超时重传机制。这种超时重传机制保证了TCP在网络延迟或者报文丢失下的可靠传输。</p><blockquote><p>超时的原因：</p><ul><li>接收方没有收到TCP报文段：网络延迟或者丢包；</li><li>发送方没有收到ACK报文段：网络延迟或者ACK报文丢失。</li></ul></blockquote></li><li><p><strong>连接管理：</strong>连接管理就是三次握手与四次挥手的过程（后面有详细解释）</p></li><li><p><strong>流量控制：</strong> 流量控制的目的是让接收方来得及接收数据。这样避免了数据丢包以及网络拥塞等情况。</p></li><li><p><strong>拥塞控制：</strong> 拥塞控制就是防止过多的数据注入到网络中，这样使网络中的路由器或者链路不至于过载。</p></li></ul><hr><h3 id="TCP三次握手的过程？为什么采用三次握手？两次可以吗？"><a href="#TCP三次握手的过程？为什么采用三次握手？两次可以吗？" class="headerlink" title="TCP三次握手的过程？为什么采用三次握手？两次可以吗？"></a>TCP三次握手的过程？为什么采用三次握手？两次可以吗？</h3><p><a href="https://www.cnblogs.com/anzhengyu/p/11232813.html">原博文——TCP运输连接管理</a></p><p><img src="https://i.loli.net/2019/07/25/5d3963c32a30b71624.png" alt="5d3963c32a30b71624"></p><p><strong>TCP三次握手的过程（A向B发送数据）：</strong></p><blockquote><ul><li>A主动打开连接，B被动打开连接。B先进入收听状态，A打算建立TCP连接时，先向B发送连接请求报文段，其中<strong>同步位SYN=1，初始序号seq=x</strong>，这个报文段不能携带数据，但是要消耗一个序号。接着，A进入同步已发送状态；</li><li>B收到请求报文段，如果同意建立连接，则向A发送ACK确认报文段，其中<strong>同步位SYN=1，确认号ACK=1，初始序号seq=y，确认号ack=x+1（请求报文段消耗了一个序号）</strong>，这个ACK报文段也不能携带数据，但是要消耗一个序号。与此同时，B进入到同步收到的状态；</li><li>A收到B的确认报文后，还要给B发送确认报文。其中<strong>ACK=1，seq=x+1（上一个报文段的ack），ack = y+1（上一个报文段的seq+1，因为消耗了一个序号）</strong>，这个ACK报文段可以携带数据，但是如果不携带数据则不会消耗序号，下一次A给B发送报文段的初始序号 <strong>seq=1</strong>。此时A进入已建立连接的状态，B收到确认后也进入已建立连接的状态。</li></ul></blockquote><p><strong>为什么需要最后一次确认？</strong></p><blockquote><p>这是防止已失效的连接请求报文段突然又传送到了B而引发错误。</p><p><strong>失效的连接请求：</strong>A第一次先发送了一个请求，但是丢失了，于是A再发送一个连接请求，重新建立连接，发送数据并释放连接。</p><p>但是有可能出现异常情况，即A发送的连接请求并没有丢失，而是滞留了在网络中。如果在传输数据完成之后，这个请求又发到B，B误以为A还要发送数据，因此发送确认报文，但是A没有运输需求，因此不予理睬。如果没有最后一次确认，B一直等待A的确认，这样会造成的浪费。</p><p>采用三报文握手，如果B没有收到A的确认，则可以知道A没有建立连接的需求，就可以避免上述这种情况。</p></blockquote><hr><h3 id="TCP四次挥手的过程？为什么最后有timewait？等待时长一般是多少？"><a href="#TCP四次挥手的过程？为什么最后有timewait？等待时长一般是多少？" class="headerlink" title="TCP四次挥手的过程？为什么最后有timewait？等待时长一般是多少？"></a>TCP四次挥手的过程？为什么最后有timewait？等待时长一般是多少？</h3><p><a href="https://www.cnblogs.com/anzhengyu/p/11232813.html">原博文——TCP运输连接管理</a></p><p><img src="https://i.loli.net/2019/07/25/5d3968b13408d81781.png" alt="5d3968b13408d81781"></p><p><strong>TCP四次挥手的过程：</strong></p><blockquote><ul><li>A和B目前都处于已建立连接的状态，A的应用进程向其TCP发出连接释放报文段，并停止发送数据，主动关闭TCP连接。此时，<strong>FIN=1，seq=u，u等于前面已发送的最后一个字节的序号加1</strong>。这时A进入到FIN-WAIT-1（终止等待1）状态，等待B的确认。FIN报文段即使不携带数据，也要消耗一个序号；</li><li>B收到释放连接后立即发出确认，此时，<strong>ACK=1，确认号是ack=u+1（前面的seq+1，因为消耗了一个序号），序号seq=v，v等于B前面所有已传送数据的最后一个字节的序号加1</strong>。B进入到CLOSE-WAIT（关闭等待）状态，TCP服务器进程向<strong>B的高层应用进程</strong>告知，此时<strong>A到B的连接已经释放</strong>，TCP连接处于半关闭状态。但是，<strong>B到A这个方向的连接尚未关闭；</strong></li><li>A收到B的确认后，就进入到FIN-WAIT2（终止等待2）的状态，等待B发送连接释放报文段；</li><li>若B已经没有数据需要发送，则应用进程通知TCP释放连接，这时B发送的报文段：<strong>FIN=1，ACK=1，seq=w（可能后面又发送了一些数据），ack=u+1，</strong>并且这个报文消耗一个序号。B进入到LAST-ACK（最后确认）的状态，等待A的确认；</li><li>A收到B的确认后，必须对此发送确认报文。该报文中<strong>：ACK=1，seq=u+1，ack=w+1</strong>。然后进入到TIME-WAIT（时间等待）状态。</li><li>此时TCP连接并没有完全释放，必须经过时间等待计时器设置的时间<strong>2MSL</strong>之后，A才进入CLOSED状态。<strong>时间MSL叫做最大报文段寿命</strong>。</li></ul></blockquote><p><strong>那么，为什么要等待2MSL的时间呢？</strong></p><blockquote><ul><li>保证A最后发送的ACK报文段能够到达B。因为这个报文可能丢失，因此B会重传最后一个确认报文段，A再重新发送确认报文，并且重启计时器，直到A，B都能正常进入到CLOSED状态；</li><li>防止上面提到的“已失效的连接请求报文”。这段时间内，这些连接请求报文就可能在网络中消失。</li></ul></blockquote><p>此外，B要比A先进入CLOSED状态</p><hr><h3 id="TCP怎么计算网络延迟？"><a href="#TCP怎么计算网络延迟？" class="headerlink" title="TCP怎么计算网络延迟？"></a>TCP怎么计算网络延迟？</h3><p><a href="https://www.zhihu.com/question/266846392">知乎——计算网络时延的原理是什么？</a></p><p><img src="https://i.loli.net/2019/07/26/5d3a50aed57c293627.png" alt="5d3a50aed57c293627"></p><p>精确的时延计算十分复杂，不过可以通过ping命令进行粗略的计算，通过ping命令得出的平均往返时间除以2，就是我们的网络时延。</p><hr><h3 id="TCP怎么进行拥塞控制？（慢启动、拥塞避免、快重传、快恢复）"><a href="#TCP怎么进行拥塞控制？（慢启动、拥塞避免、快重传、快恢复）" class="headerlink" title="TCP怎么进行拥塞控制？（慢启动、拥塞避免、快重传、快恢复）"></a>TCP怎么进行拥塞控制？（慢启动、拥塞避免、快重传、快恢复）</h3><p><img src="https://i.loli.net/2019/07/26/5d3a5a9e075a842627.png" alt="5d3a5a9e075a842627"></p><p><a href="https://www.cnblogs.com/anzhengyu/p/11232804.html">原博文——TCP的流量控制与拥塞控制</a></p><p>TCP通过<strong>慢启动、拥塞避免、快重传以及快恢复</strong>这四个算法来进行拥塞控制（具体的可以参见上面那篇博文）：</p><blockquote><ul><li><strong>慢启动：</strong>一开始先设置一个比较小的拥塞窗口值cwnd（报文段的倍数），然后进行数据传输，每收到一个报文段的确认，我们就将<strong>cwnd+1</strong>，这样下来，cwnd总体上是乘以<strong>2^n</strong>的倍数增长。（慢启动非增长速度慢，只是增长的初始基数比较小）</li><li><strong>拥塞避免：</strong> 因为慢启动算法的增长比较快，当cwnd = ssthresh（预先设置好的门限值）时，我们启动拥塞避免算法，窗口值开始线性增长。</li></ul><blockquote><p>随着拥塞避免算法的进行，网络出现超时的情况（这时判断为<strong>拥塞出现</strong>）。这时将cwnd降为一开始的值，重新进行<strong>慢开始-拥塞避免</strong>，并且此时的门限值设为出现拥塞时的cwnd的一半。</p></blockquote><ul><li><strong>快重传：</strong> 快重传的目的是为了让发送方尽早知道某个报文段的丢失。如何知道呢？<strong>当我们重复收到某一个报文段的3次确认时，我们就可以判断，它的下一个报文段可能出现了丢失</strong>。这时我们启动快重传算法，立即重传丢失的报文段。</li><li><strong>快恢复：</strong> 上面快重传算法的启动只是因为个别报文段的丢失，我们这时并不判断为网络拥塞，而是启动快恢复算法。我们将cwnd=ssthresh=当前cwnd的一半，并且开始拥塞避免算法。</li></ul><blockquote><p>当然，也有的快恢复算法是将当前拥塞窗口再增大3个报文段的值，因为既然收到了3个重复的ACK，则说明有三个分组已经离开了网络，不在占用网络资源而是停留在对方缓存当中，可以适当将窗口值增大。</p></blockquote></blockquote><hr><h3 id="TCP对应的协议有哪些？UDP对应的协议有哪些？"><a href="#TCP对应的协议有哪些？UDP对应的协议有哪些？" class="headerlink" title="TCP对应的协议有哪些？UDP对应的协议有哪些？"></a>TCP对应的协议有哪些？UDP对应的协议有哪些？</h3><p><img src="https://i.loli.net/2019/07/26/5d3a54340888063337.jpg" alt="5d3a54340888063337"></p><hr><h3 id="面向连接和无连接的区别？"><a href="#面向连接和无连接的区别？" class="headerlink" title="面向连接和无连接的区别？"></a>面向连接和无连接的区别？</h3><p><strong>应该与前面TCP和UDP的区别类似。</strong></p><blockquote><ul><li>面向连接在传输之前需要先建立连接，而且传输完成后必须要释放连接。无连接则不需要事先建立连接，直接传输数据。</li><li>面向连接一般要保证数据传输的可靠性，有序性。</li></ul></blockquote><hr><h3 id="端口以及对应的服务？"><a href="#端口以及对应的服务？" class="headerlink" title="端口以及对应的服务？"></a>端口以及对应的服务？</h3><blockquote><p><strong>端口号分类：</strong></p><ul><li><p>服务器端使用的端口号。</p><blockquote><p><strong>熟知端口号</strong>：0~1023。IANA把一些端口号指派给了TCP/IP最重要的一些程序。当有一些新的应用程序出现后，IANA必须给它指定 一个熟知端口号，否则互联网上的其他应用进程无法和它进行通信。</p><table><thead><tr><th>应用程序</th><th>FTP</th><th align="center">TELNET</th><th align="center">SMTP</th><th align="center">DNS</th><th align="center">TFTP</th><th align="center">HTTP</th><th align="center">SNMP</th><th align="center">SNMP(trap)</th><th align="center">HTTPS</th></tr></thead><tbody><tr><td>熟知端口号</td><td>21</td><td align="center">23</td><td align="center">25</td><td align="center">53</td><td align="center">69</td><td align="center">80</td><td align="center">161</td><td align="center">162</td><td align="center">443</td></tr></tbody></table><p><strong>登记端口号：</strong>1024~49151。这类端口号是为没有熟知端口号的应用程序使用。这类端口号必须在IANA中按照规定的手续进行登记，以防止重复。</p></blockquote></li><li><p>客户端使用的端口号：49152~65535。只有在客户端进程运行时才动态选择，因此又叫短暂端口号。这类端口号留给客户进程选择暂时使用，通信结束后就释放，不再占用。</p></li></ul></blockquote><p>如果对你有帮助，就推荐+收藏吧！😜😜</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python django中restful框架的使用</title>
      <link href="/2020/11/22/django-zhong-restful-kuang-jia-de-shi-yong/"/>
      <url>/2020/11/22/django-zhong-restful-kuang-jia-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p><b><span style="color:#FF4500;">写在最前面：本文章所有内容是本人从网络整理而得，并非商用，仅供学习交流使用。</span></b></p><p>在使用django进行前后台分离开发时通常会搭配<code>django-rest-framework</code>框架创建RESTful风格的接口API。框架介绍及版本要求可参考官方地址：<a href="https://www.django-rest-framework.org/">https://www.django-rest-framework.org</a></p><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/Creating-Python-APIs-Like-a-BOSS-The-Django-REST-Framework-Course.jpg" alt="Creating-Python-APIs-Like-a-BOSS-The-Django-REST-Framework-Course"></p><p>本文以创建<code>man</code>包含<code>name</code>、<code>sex</code>字段的API为实例学习<code>django-rest-framework</code>框架的使用。</p><p>主要包含下面5个步骤：</p><ol><li>创建Django项目</li><li>创建ORM模型</li><li>加载Django REST Framework</li><li>序列化模型</li><li>创建加载数据的view和url</li></ol><hr><h5 id="1-创建Django项目"><a href="#1-创建Django项目" class="headerlink" title="1.创建Django项目"></a>1.创建Django项目</h5><p>创建django_rest</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">django-admin startproject django_rest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入django_rest，创建虚拟环境env</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">virtualenv env<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>激活虚拟环境,并安装django</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">source ./env/bin/activate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 django</p><pre class="line-numbers language-none"><code class="language-none">pip install django<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建rest_app</p><pre class="line-numbers language-none"><code class="language-none">python manage.py startapp rest_app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注册app，将app添加到INSTALLED_APPS</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#setting.py</span>INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.contrib.admin'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.contenttypes'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.sessions'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.messages'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.staticfiles'</span><span class="token punctuation">,</span>    <span class="token string">'rest_app'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建后台admin账户用于管理</p><pre class="line-numbers language-none"><code class="language-none">$ python manage.py createsuperuserUsername (leave blank to use 'root'):admin Email address: Password: Password (again): Superuser created successfully.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="2-创建ORM模型"><a href="#2-创建ORM模型" class="headerlink" title="2.创建ORM模型"></a>2.创建ORM模型</h5><p>数据库我们使用默认sqlite3 即可，如需要变更可在setting.py中databases配置。</p><p>修改我们/django_rest/models.py添加我们<code>man</code>的模型</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#models.py</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models<span class="token comment"># Create your models here.</span><span class="token keyword">class</span> <span class="token class-name">Man</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span>    sex <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>做数据库迁移</p><pre class="line-numbers language-none"><code class="language-none">python manage.py makemigrations python manage.py migrate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/image-20210621160708390.png" alt="image-20210621160708390"></p><p>将Man这个model注册到我们的后台，以便可以通过django的后台做增删查改，编写admin.py如下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#admin.py</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> <span class="token punctuation">.</span>models <span class="token keyword">import</span> Man<span class="token comment"># Register your models here.</span>admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>register<span class="token punctuation">(</span>Man<span class="token punctuation">)</span>  <span class="token comment"># 注册Man到后台</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动django服务</p><pre class="line-numbers language-none"><code class="language-none">python manage.py runserver<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>访问 <a href="http://127.0.0.1:8000/admin/%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%EF%BC%8C%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95">http://127.0.0.1:8000/admin/可以看到登录界面，输入密码登录</a></p><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/image-20210621162254044.png" alt="image-20210621162254044"></p><p>可以看到我们的rest_app下的模型man对象mans</p><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/image-20210621163034920.png" alt="image-20210621163034920"></p><p>我们添加一个那个男人lgd.ame</p><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/image-20210621163158979.png" alt="image-20210621163158979"></p><hr><h5 id="3-加载Django-REST-Framework"><a href="#3-加载Django-REST-Framework" class="headerlink" title="3. 加载Django REST Framework"></a>3. 加载Django REST Framework</h5><p>安装工具包</p><pre class="line-numbers language-none"><code class="language-none">pip install djangorestframework<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注册rest_framework</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#setting.py</span>INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.contrib.admin'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.contenttypes'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.sessions'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.messages'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.staticfiles'</span><span class="token punctuation">,</span>    <span class="token string">'rest_app'</span>    <span class="token string">'rest_framework'</span> <span class="token comment">#注册</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-序列化模型"><a href="#4-序列化模型" class="headerlink" title="4.序列化模型"></a>4.序列化模型</h5><p>序列化器会把我们的模型数据转化（序列化）为json格式，这样就能够被请求了。同样当有josn数据提交过来的时候，序列化器会将json数据转换为模型供咋们使用。</p><p>我们在rest_app下创建文件serializer.py</p><p>我们要做三件事：</p><ol><li>导入Man模型</li><li>导入序REST Framework序列化器</li><li>创建新的类将模型和序列化器链接起来</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> rest_framework <span class="token keyword">import</span> serializers<span class="token keyword">from</span> <span class="token punctuation">.</span>models <span class="token keyword">import</span> Man<span class="token keyword">class</span> <span class="token class-name">Manserializer</span><span class="token punctuation">(</span>serializers<span class="token punctuation">.</span>HyperlinkedModelSerializer<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>        model <span class="token operator">=</span> Man        fields <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'sex'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-创建加载数据的view和url"><a href="#5-创建加载数据的view和url" class="headerlink" title="5.创建加载数据的view和url"></a>5.创建加载数据的view和url</h5><p>我们需要把序列化后的数据返回给浏览器，所以要做一下步骤：</p><ol><li>通过Man查询数据库</li><li>将查询后的数据传递给序列化器，通过序列化器转化为json</li></ol><p>我们在rest_app/views.py编写我们的视图,<code>ModelViewSet</code>由rest_framework提供，包含了get、post方法</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># views.py</span><span class="token keyword">from</span> rest_framework <span class="token keyword">import</span> viewsets<span class="token keyword">from</span> <span class="token punctuation">.</span>serializers <span class="token keyword">import</span> ManSerializer<span class="token keyword">from</span> <span class="token punctuation">.</span>models <span class="token keyword">import</span> Man<span class="token keyword">class</span> <span class="token class-name">ManViewSet</span><span class="token punctuation">(</span>viewsets<span class="token punctuation">.</span>ModelViewSet<span class="token punctuation">)</span><span class="token punctuation">:</span>    queryset <span class="token operator">=</span> Man<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>order_by<span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>  <span class="token comment">#查询结果给queryset</span>    serializer_class <span class="token operator">=</span> ManSerializer     <span class="token comment">#对结果进序列化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在django_rest目录下urls.py添加api路由</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> path<span class="token punctuation">,</span> includeurlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    path<span class="token punctuation">(</span><span class="token string">'admin/'</span><span class="token punctuation">,</span> admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>urls<span class="token punctuation">)</span><span class="token punctuation">,</span>    path<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> include<span class="token punctuation">(</span><span class="token string">'rest_app.urls'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在rest_app目录下创建urls.py添加视图路由，通过rest_framework中router确保我们的请求到正确的动态资源。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> include<span class="token punctuation">,</span> path<span class="token keyword">from</span> rest_framework <span class="token keyword">import</span> routers<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> viewsrouter <span class="token operator">=</span> routers<span class="token punctuation">.</span>DefaultRouter<span class="token punctuation">(</span><span class="token punctuation">)</span>router<span class="token punctuation">.</span>register<span class="token punctuation">(</span><span class="token string">r'man'</span><span class="token punctuation">,</span> views<span class="token punctuation">.</span>ManViewSet<span class="token punctuation">)</span>   <span class="token comment">#路由到ManViewSet视图</span><span class="token comment"># Wire up our API using automatic URL routing.</span><span class="token comment"># Additionally, we include login URLs for the browsable API.</span>urlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    path<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> include<span class="token punctuation">(</span>router<span class="token punctuation">.</span>urls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">#使用router路由</span>    path<span class="token punctuation">(</span><span class="token string">'api-auth/'</span><span class="token punctuation">,</span> include<span class="token punctuation">(</span><span class="token string">'rest_framework.urls'</span><span class="token punctuation">,</span> namespace<span class="token operator">=</span><span class="token string">'rest_framework'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后我们来启动服务,访问<a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> 可以在浏览器查看到我们api信息</p><pre class="line-numbers language-none"><code class="language-none">python manage.py runserver<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/image-20210621182048294.png" alt="image-20210621182048294"></p><p>访问<a href="http://127.0.0.1:8000/man/">http://127.0.0.1:8000/man/</a> 来查看man资源</p><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/image-20210621181859700.png" alt="image-20210621181859700"></p><p>通过id来访问api资源<a href="http://127.0.0.1:8000/man/1/">http://127.0.0.1:8000/man/1/</a></p><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/image-20210621182006651.png" alt="image-20210621182006651"></p><hr><p>这样我们一个基础restful风格的API创建完成了。感觉关键点还是理解<code>ModelViewSet</code>和内置<code>router</code>不读源码很难知其所以然。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> restful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件程序设计原则（三）</title>
      <link href="/2020/08/20/ruan-jian-she-ji-yuan-ze-san/"/>
      <url>/2020/08/20/ruan-jian-she-ji-yuan-ze-san/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。每个程序员都可以从理解编程原则和模式中受益。</p><p>软件设计原则是一组帮助我们避开不良设计的指导方针。根据Robert Martin的理论，应该避免不良设计的以下三个重要特点：</p><ul><li><strong>僵化</strong>：很难做改动，因为每一个细微的改动都会影响到系统大量的其他功能</li><li><strong>脆弱</strong>：每当你做一次改动，总会引起系统中预期之外的部分出现故障</li><li><strong>死板</strong>：代码很难在其他应用中重用，因其不能从当前应用中单独抽离出来</li></ul><p>下面这些软件设计原则是我从一些书籍和网络中收集而来，并不完整，而且你也需要在一些有“冲突的原则”之间进行权衡和取舍。本文或许会对你的编程、程序设计、讨论或评审工作有所帮助。</p><h2 id="二、通用设计原则"><a href="#二、通用设计原则" class="headerlink" title="二、通用设计原则"></a>二、通用设计原则</h2><h3 id="1-KISS"><a href="#1-KISS" class="headerlink" title="1. KISS"></a>1. KISS</h3><p>所谓KISS原则，即：Keep It Simple,Stupid，指<strong>设计时要坚持简约原则，避免不必要的复杂化，并且易于修改</strong>。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">Everything should be made as simple as possible, but not simpler. - Albert Einstein</font></td></tr></tbody></table><p>简单清晰、功能强大是软件设计最重要的原则和目标。但是软件工程天然错综复杂，而“简单”却没有一个衡量标准，判断和实现一个东西是不是简单，可以通过以下方式来参考。</p><ul><li>让别的软件工程师以一种最容易的方式使用你的方案。</li><li>简单不是走捷径，不是为手边的问题找一个最快的方案。</li><li>当系统变得更庞大更复杂的时候依然能够被理解。</li><li>如果系统无法保持简单，那么我们能做的就是保持各个局部简单，即任何单个的类、模块、应用的设计目标及工作原理都能被快速理解。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black">**我的理解**：保持简单但不能掩盖软件丰富的内涵。即**简约而不简单**！简约是对复杂的事物抽丝剥茧、去除细枝末节显露主要逻辑的过程。就像小时候老师教写文章，要求尽可能用朴实的语言，言简意赅的写出来，但却又要避免语言过于贫乏。软件的“抽象”和它的“直观性”，其实是一对矛盾的关系，软件设计就要保证这两者的平衡。代码抽象过于复杂会陷入“过度设计”不易理解的困境；为了“直观性”缺乏抽象，长此以往又会出现大量的重复、不易于扩展和难维护的困境。</font></td></tr></tbody></table><h3 id="2-DRY"><a href="#2-DRY" class="headerlink" title="2. DRY"></a>2. DRY</h3><p>所谓DRY原则，即：Don’t Repeat Yourself，<strong>不要让自己重复</strong>。</p><p><strong>重复代码是软件程序变烂的万恶之首</strong>。DRY并不是指你不能复制代码，而是你复制的代码不能包含重复的“信息”。复制的东西并不仅仅是复制了代码，而是由于你把同一个信息散播在了代码的各个部分导致了有很多相近的代码也散播在各个地方。代码之所以要写的好，不要重复某些“信息”，因为需求人员总是要改需求，不改代码你就要“死”，改代码你就要加班，所以为了减少修改代码的痛苦，我们不能重复任何信息。举个例子，有一天需求人员说，要把分隔符从分号改成顿号！一下子就要改多个地方了。</p><p>所以，<strong>去掉重复的信息会让你的代码结构发生本质的变化</strong>。</p><p>“重复代码”有很多变体：</p><ul><li>魔法数字、魔法字符串等</li><li>相同代码块</li><li>相似的代码逻辑及操作</li></ul><p>对于消除重复的代码有<strong>事不过三法则</strong>。</p><ul><li>第一次先写了一段代码。</li><li>第二次在另一个地方写了一段相同或相似逻辑的代码，你已经有消除和提取重复代码的冲动了。</li><li>再次在另一个地方写了同样的代码，你已忍无可忍，现在可以考虑抽取和消除重复代码了。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black">我的理解：解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过重构的手段来消除重复。发现和解决重复并不困难，通过提取抽象、提取方法等措施就能消除重复，但困难的是立即行动去解决重复，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。解决了重复，经过一段时间，你就会发现，你对整个系统的理解程度在不知不觉中提高了不少。</font></td></tr></tbody></table><h3 id="3-Maximize-Cohesion，-Minimize-Coupling"><a href="#3-Maximize-Cohesion，-Minimize-Coupling" class="headerlink" title="3. Maximize Cohesion， Minimize Coupling"></a>3. Maximize Cohesion， Minimize Coupling</h3><p>所谓Maximize Cohesion,Minimize Coupling原则，即：<strong>高内聚低耦合</strong>。这是判断设计好坏的标准，主要是看<strong>模块内的内聚性是否高，模块间的耦合度是否低</strong>。</p><ul><li><strong>耦合性</strong>：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</li><li><strong>内聚性</strong>：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</li></ul><p>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><p>Java中实现高内聚低耦合的常用方式：</p><ul><li>少使用类的继承，多用接口隐藏实现的细节。</li><li>模块的功能化分尽可能的单一，道理也很简单,功能单一的模块供其它模块调用的机会就少。</li><li>遵循一个定义只在一个地方出现。</li><li>少使用全局变量。</li><li>类属性和方法的声明少用public，多用private关键字，</li><li>多用设计模式，比如采用MVC的设计模式就可以降低界面与业务逻辑的耦合度。</li><li>尽量不用“硬编码”的方式写程序。</li><li>最后当然就是避免直接操作或调用其它模块或类（内容耦合）。</li></ul><h3 id="4-SOC"><a href="#4-SOC" class="headerlink" title="4. SOC"></a>4. SOC</h3><p>所谓SOC原则，即：<strong>关注点分离</strong>（Separation of Concerns）。<strong>不同领域的功能，应该由不同的代码和最小重迭的模块组成</strong>。关注点分离是处理复杂性的一个原则。由于关注点混杂在一起会导致软件程序复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。关注点分离原则不仅体现在软件程序设计等设计方法中，同时也体现在架构设计、问题求解、软件开发过程、软件项目管理以及软件开发方法学等诸多方面。</p><p>MVC就是关注点分离的一个体现，把业务逻辑、数据、界面分离，这也是组织代码结构的一个形式。MVC的基本结构：</p><ul><li>Model层表示应用程序的数据核心，通常负责在数据库中存取数据。</li><li>View是应用程序的显示层，通常是依据模型的数据而建立。</li><li>Controller是用来控制和处理输入输出的，是处理用户交互的部分，也负责向模型（Model层）发送数据。</li></ul><p>MVC的这个设计各个关注点是分开的，这样有助于我们管理和开发复杂的应用程序，我们可以在某个时间点只集中精力在其中的某一个关注点，而不是所有的部分。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。即使需要改变，也能够清晰地识别出那些部分需要改变。如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。——Ivar Jacobson(《AOSD中文版》)</font></td></tr></tbody></table><h3 id="分离方式"><a href="#分离方式" class="headerlink" title="分离方式"></a>分离方式</h3><p>下面将介绍一些分层的思想和方式:</p><ul><li><strong>纵向分离</strong>: 如常见的三层架构（逻辑控制层、业务处理层和数据持久化层）。</li><li><strong>横向分离</strong>: 如把我们的软件拆分成模块或子系统。从左到右是模块1、模块2、模块3，这是一种水平方向的切割。这跟纵向的分离是两个不同的方向，横向分离大多是模块化的过程。</li><li><strong>切面分离</strong>: 有些内容是多个层之间都需要的，比如日志（log），在你的系统里面，界面层、逻辑层、数据访问层可能都需要写日志，这种跨到多层同样逻辑就可以考虑切面分离。</li><li><strong>依赖方向分离</strong>: 按依赖方向考虑，决定某个类应该放在哪个层次里面，或者考虑将某一层切割成多层。</li><li><strong>关注数据分离</strong>: 在组织数据时，应该尽量考虑数据本身的固有属性，如果不是它们的固有属性，那么应该分离出来。比如产品的类就不应该关联customer类，应该是用订单类来把他们联系在一起。</li><li><strong>关注行为分离</strong>: 行为也应该是事物或对象的固有的本身的行为，明显偏离原来行为的，应该考虑成另外的关注点儿分离开。比如有一个函数叫做CreateNewCustomer()，那么CreateNewCustomer()的行为就应该限定在创建一个新客户上面，给新客户自动发优惠券的动作就不能放到这个函数里面。</li><li><strong>扩展分离</strong>: 如果基于某种设计，原先不具有某些行为需要增加，可以考虑通过扩展或插件的形式来完成，将这些功能放入到插件或扩展中。</li><li><strong>反转分离</strong>: 很多依赖注入的框架，如Spring、Guice等等，这些帮助我们做依赖反转，从而倒置依赖关系</li></ul><h3 id="5-YAGNI"><a href="#5-YAGNI" class="headerlink" title="5. YAGNI"></a>5. YAGNI</h3><p>所谓YAGNI原则，即：You Ain’t Gonna Need It，<strong>你不需要它</strong>。它是一种极限编程（XP）实践，表示程序员不应为目前还不需要的功能编写代码。YAGNI很像KISS原则，因为它也是致力于构建简单的方案。然而，KISS是通过尽可能容易的完成某件事情来实现精简方案；但YAGNI是通过根本就不实现它来达到精简。YAGNI的观点是你应该<strong>为了眼前的需求做设计而不是未来</strong>。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">只在真正需要某些功能的时候才去实现它，而不是仅仅因为你预见到它将出现。- XP的联合创始人Ron Jeffries</font></td></tr></tbody></table><p>即使你非常确信将来你需要某个特性，也不要现在就去实现它。在很多情况下，你会发现或许最终你不需要它了，或者是你真正所需的特性与你之前预计的有很大的出入。遵循 YAGNI 实践有两个主要原因：</p><ul><li>你节约了时间，因为你避免了编写最终证明不必要的代码。</li><li>你的代码质量更高了，因为你使代码不必为你的“推测”所污染，而这些“推测”最终可能或多或少有些错误，但此时这些错误已牢牢地依附在你的代码中了。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black"> **我的理解** ：YAGNI 原则，本质上是告诫我们**写代码不要画蛇添足，否则就会弄巧成拙了**。编写业务代码时，不要去假想一些需求或者场景，因为大多数你所设想的场景都不会发生，而你所多写的那些代码也将会长期滞留在你的系统中，收效甚微，但却让你和团队花费了更多的时间和精力去书写和维护，更可怕的是可能会对将来新的代码维护人造成困惑。另外对于没有被使用到的代码，我认为也都应该立即删除，从而保持系统的精简，如果将来需要时再去书写或恢复，而且那时侯写出的代码也绝对比之前的更为契合。</font></td></tr></tbody></table><h3 id="6-Boy-Scout-Rule"><a href="#6-Boy-Scout-Rule" class="headerlink" title="6. Boy-Scout Rule"></a>6. Boy-Scout Rule</h3><p>Boy-Scout Rule，译为：<strong>童子军规则</strong>。美国童子军有一个简单的规则：“让营地比你刚来时更干净(Always leave the campground cleaner than you found it)”。如果看到地上有垃圾，不管是谁扔的，都要清理。这样你就有意地为下一批来宿营的人改善了环境。</p><p>童子军规则告诉我们在对现有代码库进行更改时，代码质量往往会降低，从而积累技术债务。所以需要始终保持代码整洁。不管原作者是谁，如果我们努力去改进代码模块，不管是多么小的改进，我们的软件系统就再也不会持续变坏了。取而代之的是，系统在发展的同时会逐渐变得更好。我们也会看到团队们关心整体的系统，而不是各自只关心自己负责的一小部分。而且团队成员要互助，互相清理代码，他们遵从童子军规则，因为那对每个人都很好，而不仅仅是对自己好。</p><p>关于童子军规则中所提倡的<strong>对代码坏味道的尽早修复</strong>，我也想起来了我们所熟知的<strong>“破窗效应</strong>”和<strong>“讳疾忌医”</strong>的典故：</p><h3 id="破窗效应"><a href="#破窗效应" class="headerlink" title="破窗效应"></a>破窗效应</h3><table><tbody><tr><td bgcolor="lightblue"><font color="black">如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些示范性的纵容去打烂更多的窗户。久而久之，这些破窗户就给人造成一种无序的感觉，结果在这种公众麻木不仁的氛围中，犯罪就会滋生、猖獗。——政治学家威尔逊和犯罪学家凯琳提出的“破窗效应”理论</font></td></tr></tbody></table><ul><li>“环境早就脏了，我扔的这点儿垃圾根本起不到关键性作用。”</li><li>“这个代码以前的其他人也都是这样写的。”</li><li>“反正也不是只有我才这么写代码的。”</li></ul><p>不少人会像上面这样辩解自己的过错。其实，这些说法根本站不住脚，错了就是错了，影响的大小并不能改变行为错误的本质，别人的错误更不会是证明你无错的理由。任何一种不良现象的存在，都有可能传递一种错误信息。进而导致更坏的后果，正所谓“<strong>千里之堤，溃于蚁穴”、勿以善小而不为，勿以恶小而为之</strong>。</p><h3 id="讳疾忌医的典故"><a href="#讳疾忌医的典故" class="headerlink" title="讳疾忌医的典故"></a>讳疾忌医的典故</h3><p>《扁鹊见蔡桓公》的故事，我们从小就学习了，告诉我们不能盲目相信自己，不能讳疾忌医。但想想我们自己代码的坏味道和bug，也是如出一辙。</p><p>代码坏味道或者糟糕的程序代码就像隐形的“疾病”一样潜伏在项目中，也因此形成了技术债务。如果这些“疾病”在项目初期不引起注关注、不把疾病扼杀在萌芽之中，那么后期修复它的代价也就越大，也必然会使得项目的软件程序越来越难以维护，这个项目也最终会像蔡桓公一样无药可治、“无奈何也”。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">所以，请记住童子军规则对我们的启示：**始终保持代码整洁，勿以善小而不为，勿以恶小而为之，有病早治**。</font></td></tr></tbody></table><h3 id="其他原则："><a href="#其他原则：" class="headerlink" title="其他原则："></a>其他原则：</h3><ul><li>避免过早优化（Avoid Premature Optimization）: 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。“过早的优化是一切罪恶之源。”——Donald Knuth</li><li>最小惊讶原则(Principle of least astonishment): 代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。</li><li>代码重用原则（Code Reuse is Good）: 重用代码能提高代码的可读性，缩短开发时间。</li><li>别让我思考(Don’t Make Me Think): 所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</li><li>为维护者写代码(Write Code for the Maintainer): 优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。“如果一个维护者不再继续维护你的代码，很可能他就有了想杀你的冲动。”</li><li>正交原则(Orthogonality): 正交性的基本思想是，在概念上不相关的事物不应该与系统相关。设计越正交，异常越少。 这使得用编程语言更容易学习，读写程序。(反例：CSS)。</li><li>做最简单的事儿就让代码可运行（Do the simplest thing that could possibly work）: 尽可能做最简单的事就可以让代码可运行。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢？”这将有助于在设计中保持简单的路径。</li><li>隐藏实现细节（Hide Implementation Details）: 软件模块通过提供接口隐藏信息（即实现细节），而不泄漏任何不必要的信息。</li><li>科里定律(Curly’s Law): 是为任何特定的代码选择一个明确定义的目标：只做一件事。</li><li>墨菲定律（Murphy’s Law）:根本内容是：如果事情有变坏的可能，不管这种可能性有多小，它总会发生。主要内容如下：<br>&nbsp;&nbsp; - 任何事都没有表面看起来那么简单；<br>&nbsp;&nbsp; - 所有的事都会比你预计的时间长；<br>&nbsp;&nbsp; - 会出错的事总会出错；<br>&nbsp;&nbsp; - 如果你担心某种情况发生，那么它就更有可能发生。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件程序设计原则（二）</title>
      <link href="/2020/08/17/ruan-jian-she-ji-yuan-ze-er/"/>
      <url>/2020/08/17/ruan-jian-she-ji-yuan-ze-er/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。每个程序员都可以从理解编程原则和模式中受益。</p><p>软件设计原则是一组帮助我们避开不良设计的指导方针。根据Robert Martin的理论，应该避免不良设计的以下三个重要特点：</p><ul><li><strong>僵化</strong>：很难做改动，因为每一个细微的改动都会影响到系统大量的其他功能</li><li><strong>脆弱</strong>：每当你做一次改动，总会引起系统中预期之外的部分出现故障</li><li><strong>死板</strong>：代码很难在其他应用中重用，因其不能从当前应用中单独抽离出来</li></ul><p>下面这些软件设计原则是我从一些书籍和网络中收集而来，并不完整，而且你也需要在一些有“冲突的原则”之间进行权衡和取舍。本文或许会对你的编程、程序设计、讨论或评审工作有所帮助。</p><h2 id="二、通用设计原则"><a href="#二、通用设计原则" class="headerlink" title="二、通用设计原则"></a>二、通用设计原则</h2><h3 id="1-KISS"><a href="#1-KISS" class="headerlink" title="1. KISS"></a>1. KISS</h3><p>所谓KISS原则，即：Keep It Simple,Stupid，指<strong>设计时要坚持简约原则，避免不必要的复杂化，并且易于修改</strong>。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">Everything should be made as simple as possible, but not simpler. - Albert Einstein</font></td></tr></tbody></table><p>简单清晰、功能强大是软件设计最重要的原则和目标。但是软件工程天然错综复杂，而“简单”却没有一个衡量标准，判断和实现一个东西是不是简单，可以通过以下方式来参考。</p><ul><li>让别的软件工程师以一种最容易的方式使用你的方案。</li><li>简单不是走捷径，不是为手边的问题找一个最快的方案。</li><li>当系统变得更庞大更复杂的时候依然能够被理解。</li><li>如果系统无法保持简单，那么我们能做的就是保持各个局部简单，即任何单个的类、模块、应用的设计目标及工作原理都能被快速理解。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black">**我的理解**：保持简单但不能掩盖软件丰富的内涵。即**简约而不简单**！简约是对复杂的事物抽丝剥茧、去除细枝末节显露主要逻辑的过程。就像小时候老师教写文章，要求尽可能用朴实的语言，言简意赅的写出来，但却又要避免语言过于贫乏。软件的“抽象”和它的“直观性”，其实是一对矛盾的关系，软件设计就要保证这两者的平衡。代码抽象过于复杂会陷入“过度设计”不易理解的困境；为了“直观性”缺乏抽象，长此以往又会出现大量的重复、不易于扩展和难维护的困境。</font></td></tr></tbody></table><h3 id="2-DRY"><a href="#2-DRY" class="headerlink" title="2. DRY"></a>2. DRY</h3><p>所谓DRY原则，即：Don’t Repeat Yourself，<strong>不要让自己重复</strong>。</p><p><strong>重复代码是软件程序变烂的万恶之首</strong>。DRY并不是指你不能复制代码，而是你复制的代码不能包含重复的“信息”。复制的东西并不仅仅是复制了代码，而是由于你把同一个信息散播在了代码的各个部分导致了有很多相近的代码也散播在各个地方。代码之所以要写的好，不要重复某些“信息”，因为需求人员总是要改需求，不改代码你就要“死”，改代码你就要加班，所以为了减少修改代码的痛苦，我们不能重复任何信息。举个例子，有一天需求人员说，要把分隔符从分号改成顿号！一下子就要改多个地方了。</p><p>所以，<strong>去掉重复的信息会让你的代码结构发生本质的变化</strong>。</p><p>“重复代码”有很多变体：</p><ul><li>魔法数字、魔法字符串等</li><li>相同代码块</li><li>相似的代码逻辑及操作</li></ul><p>对于消除重复的代码有<strong>事不过三法则</strong>。</p><ul><li>第一次先写了一段代码。</li><li>第二次在另一个地方写了一段相同或相似逻辑的代码，你已经有消除和提取重复代码的冲动了。</li><li>再次在另一个地方写了同样的代码，你已忍无可忍，现在可以考虑抽取和消除重复代码了。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black">我的理解：解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过重构的手段来消除重复。发现和解决重复并不困难，通过提取抽象、提取方法等措施就能消除重复，但困难的是立即行动去解决重复，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。解决了重复，经过一段时间，你就会发现，你对整个系统的理解程度在不知不觉中提高了不少。</font></td></tr></tbody></table><h3 id="3-Maximize-Cohesion，-Minimize-Coupling"><a href="#3-Maximize-Cohesion，-Minimize-Coupling" class="headerlink" title="3. Maximize Cohesion， Minimize Coupling"></a>3. Maximize Cohesion， Minimize Coupling</h3><p>所谓Maximize Cohesion,Minimize Coupling原则，即：<strong>高内聚低耦合</strong>。这是判断设计好坏的标准，主要是看<strong>模块内的内聚性是否高，模块间的耦合度是否低</strong>。</p><ul><li><strong>耦合性</strong>：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</li><li><strong>内聚性</strong>：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</li></ul><p>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><p>Java中实现高内聚低耦合的常用方式：</p><ul><li>少使用类的继承，多用接口隐藏实现的细节。</li><li>模块的功能化分尽可能的单一，道理也很简单,功能单一的模块供其它模块调用的机会就少。</li><li>遵循一个定义只在一个地方出现。</li><li>少使用全局变量。</li><li>类属性和方法的声明少用public，多用private关键字，</li><li>多用设计模式，比如采用MVC的设计模式就可以降低界面与业务逻辑的耦合度。</li><li>尽量不用“硬编码”的方式写程序。</li><li>最后当然就是避免直接操作或调用其它模块或类（内容耦合）。</li></ul><h3 id="4-SOC"><a href="#4-SOC" class="headerlink" title="4. SOC"></a>4. SOC</h3><p>所谓SOC原则，即：<strong>关注点分离</strong>（Separation of Concerns）。<strong>不同领域的功能，应该由不同的代码和最小重迭的模块组成</strong>。关注点分离是处理复杂性的一个原则。由于关注点混杂在一起会导致软件程序复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。关注点分离原则不仅体现在软件程序设计等设计方法中，同时也体现在架构设计、问题求解、软件开发过程、软件项目管理以及软件开发方法学等诸多方面。</p><p>MVC就是关注点分离的一个体现，把业务逻辑、数据、界面分离，这也是组织代码结构的一个形式。MVC的基本结构：</p><ul><li>Model层表示应用程序的数据核心，通常负责在数据库中存取数据。</li><li>View是应用程序的显示层，通常是依据模型的数据而建立。</li><li>Controller是用来控制和处理输入输出的，是处理用户交互的部分，也负责向模型（Model层）发送数据。</li></ul><p>MVC的这个设计各个关注点是分开的，这样有助于我们管理和开发复杂的应用程序，我们可以在某个时间点只集中精力在其中的某一个关注点，而不是所有的部分。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。即使需要改变，也能够清晰地识别出那些部分需要改变。如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。——Ivar Jacobson(《AOSD中文版》)</font></td></tr></tbody></table><h3 id="分离方式"><a href="#分离方式" class="headerlink" title="分离方式"></a>分离方式</h3><p>下面将介绍一些分层的思想和方式:</p><ul><li><strong>纵向分离</strong>: 如常见的三层架构（逻辑控制层、业务处理层和数据持久化层）。</li><li><strong>横向分离</strong>: 如把我们的软件拆分成模块或子系统。从左到右是模块1、模块2、模块3，这是一种水平方向的切割。这跟纵向的分离是两个不同的方向，横向分离大多是模块化的过程。</li><li><strong>切面分离</strong>: 有些内容是多个层之间都需要的，比如日志（log），在你的系统里面，界面层、逻辑层、数据访问层可能都需要写日志，这种跨到多层同样逻辑就可以考虑切面分离。</li><li><strong>依赖方向分离</strong>: 按依赖方向考虑，决定某个类应该放在哪个层次里面，或者考虑将某一层切割成多层。</li><li><strong>关注数据分离</strong>: 在组织数据时，应该尽量考虑数据本身的固有属性，如果不是它们的固有属性，那么应该分离出来。比如产品的类就不应该关联customer类，应该是用订单类来把他们联系在一起。</li><li><strong>关注行为分离</strong>: 行为也应该是事物或对象的固有的本身的行为，明显偏离原来行为的，应该考虑成另外的关注点儿分离开。比如有一个函数叫做CreateNewCustomer()，那么CreateNewCustomer()的行为就应该限定在创建一个新客户上面，给新客户自动发优惠券的动作就不能放到这个函数里面。</li><li><strong>扩展分离</strong>: 如果基于某种设计，原先不具有某些行为需要增加，可以考虑通过扩展或插件的形式来完成，将这些功能放入到插件或扩展中。</li><li><strong>反转分离</strong>: 很多依赖注入的框架，如Spring、Guice等等，这些帮助我们做依赖反转，从而倒置依赖关系</li></ul><h3 id="5-YAGNI"><a href="#5-YAGNI" class="headerlink" title="5. YAGNI"></a>5. YAGNI</h3><p>所谓YAGNI原则，即：You Ain’t Gonna Need It，<strong>你不需要它</strong>。它是一种极限编程（XP）实践，表示程序员不应为目前还不需要的功能编写代码。YAGNI很像KISS原则，因为它也是致力于构建简单的方案。然而，KISS是通过尽可能容易的完成某件事情来实现精简方案；但YAGNI是通过根本就不实现它来达到精简。YAGNI的观点是你应该<strong>为了眼前的需求做设计而不是未来</strong>。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">只在真正需要某些功能的时候才去实现它，而不是仅仅因为你预见到它将出现。- XP的联合创始人Ron Jeffries</font></td></tr></tbody></table><p>即使你非常确信将来你需要某个特性，也不要现在就去实现它。在很多情况下，你会发现或许最终你不需要它了，或者是你真正所需的特性与你之前预计的有很大的出入。遵循 YAGNI 实践有两个主要原因：</p><ul><li>你节约了时间，因为你避免了编写最终证明不必要的代码。</li><li>你的代码质量更高了，因为你使代码不必为你的“推测”所污染，而这些“推测”最终可能或多或少有些错误，但此时这些错误已牢牢地依附在你的代码中了。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black"> **我的理解** ：YAGNI 原则，本质上是告诫我们**写代码不要画蛇添足，否则就会弄巧成拙了**。编写业务代码时，不要去假想一些需求或者场景，因为大多数你所设想的场景都不会发生，而你所多写的那些代码也将会长期滞留在你的系统中，收效甚微，但却让你和团队花费了更多的时间和精力去书写和维护，更可怕的是可能会对将来新的代码维护人造成困惑。另外对于没有被使用到的代码，我认为也都应该立即删除，从而保持系统的精简，如果将来需要时再去书写或恢复，而且那时侯写出的代码也绝对比之前的更为契合。</font></td></tr></tbody></table><h3 id="6-Boy-Scout-Rule"><a href="#6-Boy-Scout-Rule" class="headerlink" title="6. Boy-Scout Rule"></a>6. Boy-Scout Rule</h3><p>Boy-Scout Rule，译为：<strong>童子军规则</strong>。美国童子军有一个简单的规则：“让营地比你刚来时更干净(Always leave the campground cleaner than you found it)”。如果看到地上有垃圾，不管是谁扔的，都要清理。这样你就有意地为下一批来宿营的人改善了环境。</p><p>童子军规则告诉我们在对现有代码库进行更改时，代码质量往往会降低，从而积累技术债务。所以需要始终保持代码整洁。不管原作者是谁，如果我们努力去改进代码模块，不管是多么小的改进，我们的软件系统就再也不会持续变坏了。取而代之的是，系统在发展的同时会逐渐变得更好。我们也会看到团队们关心整体的系统，而不是各自只关心自己负责的一小部分。而且团队成员要互助，互相清理代码，他们遵从童子军规则，因为那对每个人都很好，而不仅仅是对自己好。</p><p>关于童子军规则中所提倡的<strong>对代码坏味道的尽早修复</strong>，我也想起来了我们所熟知的<strong>“破窗效应</strong>”和<strong>“讳疾忌医”</strong>的典故：</p><h3 id="破窗效应"><a href="#破窗效应" class="headerlink" title="破窗效应"></a>破窗效应</h3><table><tbody><tr><td bgcolor="lightblue"><font color="black">如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些示范性的纵容去打烂更多的窗户。久而久之，这些破窗户就给人造成一种无序的感觉，结果在这种公众麻木不仁的氛围中，犯罪就会滋生、猖獗。——政治学家威尔逊和犯罪学家凯琳提出的“破窗效应”理论</font></td></tr></tbody></table><ul><li>“环境早就脏了，我扔的这点儿垃圾根本起不到关键性作用。”</li><li>“这个代码以前的其他人也都是这样写的。”</li><li>“反正也不是只有我才这么写代码的。”</li></ul><p>不少人会像上面这样辩解自己的过错。其实，这些说法根本站不住脚，错了就是错了，影响的大小并不能改变行为错误的本质，别人的错误更不会是证明你无错的理由。任何一种不良现象的存在，都有可能传递一种错误信息。进而导致更坏的后果，正所谓“<strong>千里之堤，溃于蚁穴”、勿以善小而不为，勿以恶小而为之</strong>。</p><h3 id="讳疾忌医的典故"><a href="#讳疾忌医的典故" class="headerlink" title="讳疾忌医的典故"></a>讳疾忌医的典故</h3><p>《扁鹊见蔡桓公》的故事，我们从小就学习了，告诉我们不能盲目相信自己，不能讳疾忌医。但想想我们自己代码的坏味道和bug，也是如出一辙。</p><p>代码坏味道或者糟糕的程序代码就像隐形的“疾病”一样潜伏在项目中，也因此形成了技术债务。如果这些“疾病”在项目初期不引起注关注、不把疾病扼杀在萌芽之中，那么后期修复它的代价也就越大，也必然会使得项目的软件程序越来越难以维护，这个项目也最终会像蔡桓公一样无药可治、“无奈何也”。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">所以，请记住童子军规则对我们的启示：**始终保持代码整洁，勿以善小而不为，勿以恶小而为之，有病早治**。</font></td></tr></tbody></table><h3 id="其他原则："><a href="#其他原则：" class="headerlink" title="其他原则："></a>其他原则：</h3><ul><li>避免过早优化（Avoid Premature Optimization）: 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。“过早的优化是一切罪恶之源。”——Donald Knuth</li><li>最小惊讶原则(Principle of least astonishment): 代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。</li><li>代码重用原则（Code Reuse is Good）: 重用代码能提高代码的可读性，缩短开发时间。</li><li>别让我思考(Don’t Make Me Think): 所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</li><li>为维护者写代码(Write Code for the Maintainer): 优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。“如果一个维护者不再继续维护你的代码，很可能他就有了想杀你的冲动。”</li><li>正交原则(Orthogonality): 正交性的基本思想是，在概念上不相关的事物不应该与系统相关。设计越正交，异常越少。 这使得用编程语言更容易学习，读写程序。(反例：CSS)。</li><li>做最简单的事儿就让代码可运行（Do the simplest thing that could possibly work）: 尽可能做最简单的事就可以让代码可运行。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢？”这将有助于在设计中保持简单的路径。</li><li>隐藏实现细节（Hide Implementation Details）: 软件模块通过提供接口隐藏信息（即实现细节），而不泄漏任何不必要的信息。</li><li>科里定律(Curly’s Law): 是为任何特定的代码选择一个明确定义的目标：只做一件事。</li><li>墨菲定律（Murphy’s Law）:根本内容是：如果事情有变坏的可能，不管这种可能性有多小，它总会发生。主要内容如下：<br>&nbsp;&nbsp; - 任何事都没有表面看起来那么简单；<br>&nbsp;&nbsp; - 所有的事都会比你预计的时间长；<br>&nbsp;&nbsp; - 会出错的事总会出错；<br>&nbsp;&nbsp; - 如果你担心某种情况发生，那么它就更有可能发生。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件程序设计原则（一）</title>
      <link href="/2020/08/13/ruan-jian-she-ji-yuan-ze-yi/"/>
      <url>/2020/08/13/ruan-jian-she-ji-yuan-ze-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。每个程序员都可以从理解编程原则和模式中受益。</p><p>软件设计原则是一组帮助我们避开不良设计的指导方针。根据Robert Martin的理论，应该避免不良设计的以下三个重要特点：</p><ul><li><strong>僵化</strong>：很难做改动，因为每一个细微的改动都会影响到系统大量的其他功能</li><li><strong>脆弱</strong>：每当你做一次改动，总会引起系统中预期之外的部分出现故障</li><li><strong>死板</strong>：代码很难在其他应用中重用，因其不能从当前应用中单独抽离出来</li></ul><p>下面这些软件设计原则是我从一些书籍和网络中收集而来，并不完整，而且你也需要在一些有“冲突的原则”之间进行权衡和取舍。本文或许会对你的编程、程序设计、讨论或评审工作有所帮助。</p><h2 id="二、通用设计原则"><a href="#二、通用设计原则" class="headerlink" title="二、通用设计原则"></a>二、通用设计原则</h2><h3 id="1-KISS"><a href="#1-KISS" class="headerlink" title="1. KISS"></a>1. KISS</h3><p>所谓KISS原则，即：Keep It Simple,Stupid，指<strong>设计时要坚持简约原则，避免不必要的复杂化，并且易于修改</strong>。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">Everything should be made as simple as possible, but not simpler. - Albert Einstein</font></td></tr></tbody></table><p>简单清晰、功能强大是软件设计最重要的原则和目标。但是软件工程天然错综复杂，而“简单”却没有一个衡量标准，判断和实现一个东西是不是简单，可以通过以下方式来参考。</p><ul><li>让别的软件工程师以一种最容易的方式使用你的方案。</li><li>简单不是走捷径，不是为手边的问题找一个最快的方案。</li><li>当系统变得更庞大更复杂的时候依然能够被理解。</li><li>如果系统无法保持简单，那么我们能做的就是保持各个局部简单，即任何单个的类、模块、应用的设计目标及工作原理都能被快速理解。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black">**我的理解**：保持简单但不能掩盖软件丰富的内涵。即**简约而不简单**！简约是对复杂的事物抽丝剥茧、去除细枝末节显露主要逻辑的过程。就像小时候老师教写文章，要求尽可能用朴实的语言，言简意赅的写出来，但却又要避免语言过于贫乏。软件的“抽象”和它的“直观性”，其实是一对矛盾的关系，软件设计就要保证这两者的平衡。代码抽象过于复杂会陷入“过度设计”不易理解的困境；为了“直观性”缺乏抽象，长此以往又会出现大量的重复、不易于扩展和难维护的困境。</font></td></tr></tbody></table><h3 id="2-DRY"><a href="#2-DRY" class="headerlink" title="2. DRY"></a>2. DRY</h3><p>所谓DRY原则，即：Don’t Repeat Yourself，<strong>不要让自己重复</strong>。</p><p><strong>重复代码是软件程序变烂的万恶之首</strong>。DRY并不是指你不能复制代码，而是你复制的代码不能包含重复的“信息”。复制的东西并不仅仅是复制了代码，而是由于你把同一个信息散播在了代码的各个部分导致了有很多相近的代码也散播在各个地方。代码之所以要写的好，不要重复某些“信息”，因为需求人员总是要改需求，不改代码你就要“死”，改代码你就要加班，所以为了减少修改代码的痛苦，我们不能重复任何信息。举个例子，有一天需求人员说，要把分隔符从分号改成顿号！一下子就要改多个地方了。</p><p>所以，<strong>去掉重复的信息会让你的代码结构发生本质的变化</strong>。</p><p>“重复代码”有很多变体：</p><ul><li>魔法数字、魔法字符串等</li><li>相同代码块</li><li>相似的代码逻辑及操作</li></ul><p>对于消除重复的代码有<strong>事不过三法则</strong>。</p><ul><li>第一次先写了一段代码。</li><li>第二次在另一个地方写了一段相同或相似逻辑的代码，你已经有消除和提取重复代码的冲动了。</li><li>再次在另一个地方写了同样的代码，你已忍无可忍，现在可以考虑抽取和消除重复代码了。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black">我的理解：解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过重构的手段来消除重复。发现和解决重复并不困难，通过提取抽象、提取方法等措施就能消除重复，但困难的是立即行动去解决重复，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。解决了重复，经过一段时间，你就会发现，你对整个系统的理解程度在不知不觉中提高了不少。</font></td></tr></tbody></table><h3 id="3-Maximize-Cohesion，-Minimize-Coupling"><a href="#3-Maximize-Cohesion，-Minimize-Coupling" class="headerlink" title="3. Maximize Cohesion， Minimize Coupling"></a>3. Maximize Cohesion， Minimize Coupling</h3><p>所谓Maximize Cohesion,Minimize Coupling原则，即：<strong>高内聚低耦合</strong>。这是判断设计好坏的标准，主要是看<strong>模块内的内聚性是否高，模块间的耦合度是否低</strong>。</p><ul><li><strong>耦合性</strong>：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</li><li><strong>内聚性</strong>：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</li></ul><p>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><p>Java中实现高内聚低耦合的常用方式：</p><ul><li>少使用类的继承，多用接口隐藏实现的细节。</li><li>模块的功能化分尽可能的单一，道理也很简单,功能单一的模块供其它模块调用的机会就少。</li><li>遵循一个定义只在一个地方出现。</li><li>少使用全局变量。</li><li>类属性和方法的声明少用public，多用private关键字，</li><li>多用设计模式，比如采用MVC的设计模式就可以降低界面与业务逻辑的耦合度。</li><li>尽量不用“硬编码”的方式写程序。</li><li>最后当然就是避免直接操作或调用其它模块或类（内容耦合）。</li></ul><h3 id="4-SOC"><a href="#4-SOC" class="headerlink" title="4. SOC"></a>4. SOC</h3><p>所谓SOC原则，即：<strong>关注点分离</strong>（Separation of Concerns）。<strong>不同领域的功能，应该由不同的代码和最小重迭的模块组成</strong>。关注点分离是处理复杂性的一个原则。由于关注点混杂在一起会导致软件程序复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。关注点分离原则不仅体现在软件程序设计等设计方法中，同时也体现在架构设计、问题求解、软件开发过程、软件项目管理以及软件开发方法学等诸多方面。</p><p>MVC就是关注点分离的一个体现，把业务逻辑、数据、界面分离，这也是组织代码结构的一个形式。MVC的基本结构：</p><ul><li>Model层表示应用程序的数据核心，通常负责在数据库中存取数据。</li><li>View是应用程序的显示层，通常是依据模型的数据而建立。</li><li>Controller是用来控制和处理输入输出的，是处理用户交互的部分，也负责向模型（Model层）发送数据。</li></ul><p>MVC的这个设计各个关注点是分开的，这样有助于我们管理和开发复杂的应用程序，我们可以在某个时间点只集中精力在其中的某一个关注点，而不是所有的部分。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。即使需要改变，也能够清晰地识别出那些部分需要改变。如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。——Ivar Jacobson(《AOSD中文版》)</font></td></tr></tbody></table><h3 id="分离方式"><a href="#分离方式" class="headerlink" title="分离方式"></a>分离方式</h3><p>下面将介绍一些分层的思想和方式:</p><ul><li><strong>纵向分离</strong>: 如常见的三层架构（逻辑控制层、业务处理层和数据持久化层）。</li><li><strong>横向分离</strong>: 如把我们的软件拆分成模块或子系统。从左到右是模块1、模块2、模块3，这是一种水平方向的切割。这跟纵向的分离是两个不同的方向，横向分离大多是模块化的过程。</li><li><strong>切面分离</strong>: 有些内容是多个层之间都需要的，比如日志（log），在你的系统里面，界面层、逻辑层、数据访问层可能都需要写日志，这种跨到多层同样逻辑就可以考虑切面分离。</li><li><strong>依赖方向分离</strong>: 按依赖方向考虑，决定某个类应该放在哪个层次里面，或者考虑将某一层切割成多层。</li><li><strong>关注数据分离</strong>: 在组织数据时，应该尽量考虑数据本身的固有属性，如果不是它们的固有属性，那么应该分离出来。比如产品的类就不应该关联customer类，应该是用订单类来把他们联系在一起。</li><li><strong>关注行为分离</strong>: 行为也应该是事物或对象的固有的本身的行为，明显偏离原来行为的，应该考虑成另外的关注点儿分离开。比如有一个函数叫做CreateNewCustomer()，那么CreateNewCustomer()的行为就应该限定在创建一个新客户上面，给新客户自动发优惠券的动作就不能放到这个函数里面。</li><li><strong>扩展分离</strong>: 如果基于某种设计，原先不具有某些行为需要增加，可以考虑通过扩展或插件的形式来完成，将这些功能放入到插件或扩展中。</li><li><strong>反转分离</strong>: 很多依赖注入的框架，如Spring、Guice等等，这些帮助我们做依赖反转，从而倒置依赖关系</li></ul><h3 id="5-YAGNI"><a href="#5-YAGNI" class="headerlink" title="5. YAGNI"></a>5. YAGNI</h3><p>所谓YAGNI原则，即：You Ain’t Gonna Need It，<strong>你不需要它</strong>。它是一种极限编程（XP）实践，表示程序员不应为目前还不需要的功能编写代码。YAGNI很像KISS原则，因为它也是致力于构建简单的方案。然而，KISS是通过尽可能容易的完成某件事情来实现精简方案；但YAGNI是通过根本就不实现它来达到精简。YAGNI的观点是你应该<strong>为了眼前的需求做设计而不是未来</strong>。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">只在真正需要某些功能的时候才去实现它，而不是仅仅因为你预见到它将出现。- XP的联合创始人Ron Jeffries</font></td></tr></tbody></table><p>即使你非常确信将来你需要某个特性，也不要现在就去实现它。在很多情况下，你会发现或许最终你不需要它了，或者是你真正所需的特性与你之前预计的有很大的出入。遵循 YAGNI 实践有两个主要原因：</p><ul><li>你节约了时间，因为你避免了编写最终证明不必要的代码。</li><li>你的代码质量更高了，因为你使代码不必为你的“推测”所污染，而这些“推测”最终可能或多或少有些错误，但此时这些错误已牢牢地依附在你的代码中了。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black"> **我的理解** ：YAGNI 原则，本质上是告诫我们**写代码不要画蛇添足，否则就会弄巧成拙了**。编写业务代码时，不要去假想一些需求或者场景，因为大多数你所设想的场景都不会发生，而你所多写的那些代码也将会长期滞留在你的系统中，收效甚微，但却让你和团队花费了更多的时间和精力去书写和维护，更可怕的是可能会对将来新的代码维护人造成困惑。另外对于没有被使用到的代码，我认为也都应该立即删除，从而保持系统的精简，如果将来需要时再去书写或恢复，而且那时侯写出的代码也绝对比之前的更为契合。</font></td></tr></tbody></table><h3 id="6-Boy-Scout-Rule"><a href="#6-Boy-Scout-Rule" class="headerlink" title="6. Boy-Scout Rule"></a>6. Boy-Scout Rule</h3><p>Boy-Scout Rule，译为：<strong>童子军规则</strong>。美国童子军有一个简单的规则：“让营地比你刚来时更干净(Always leave the campground cleaner than you found it)”。如果看到地上有垃圾，不管是谁扔的，都要清理。这样你就有意地为下一批来宿营的人改善了环境。</p><p>童子军规则告诉我们在对现有代码库进行更改时，代码质量往往会降低，从而积累技术债务。所以需要始终保持代码整洁。不管原作者是谁，如果我们努力去改进代码模块，不管是多么小的改进，我们的软件系统就再也不会持续变坏了。取而代之的是，系统在发展的同时会逐渐变得更好。我们也会看到团队们关心整体的系统，而不是各自只关心自己负责的一小部分。而且团队成员要互助，互相清理代码，他们遵从童子军规则，因为那对每个人都很好，而不仅仅是对自己好。</p><p>关于童子军规则中所提倡的<strong>对代码坏味道的尽早修复</strong>，我也想起来了我们所熟知的<strong>“破窗效应</strong>”和<strong>“讳疾忌医”</strong>的典故：</p><h3 id="破窗效应"><a href="#破窗效应" class="headerlink" title="破窗效应"></a>破窗效应</h3><table><tbody><tr><td bgcolor="lightblue"><font color="black">如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些示范性的纵容去打烂更多的窗户。久而久之，这些破窗户就给人造成一种无序的感觉，结果在这种公众麻木不仁的氛围中，犯罪就会滋生、猖獗。——政治学家威尔逊和犯罪学家凯琳提出的“破窗效应”理论</font></td></tr></tbody></table><ul><li>“环境早就脏了，我扔的这点儿垃圾根本起不到关键性作用。”</li><li>“这个代码以前的其他人也都是这样写的。”</li><li>“反正也不是只有我才这么写代码的。”</li></ul><p>不少人会像上面这样辩解自己的过错。其实，这些说法根本站不住脚，错了就是错了，影响的大小并不能改变行为错误的本质，别人的错误更不会是证明你无错的理由。任何一种不良现象的存在，都有可能传递一种错误信息。进而导致更坏的后果，正所谓“<strong>千里之堤，溃于蚁穴”、勿以善小而不为，勿以恶小而为之</strong>。</p><h3 id="讳疾忌医的典故"><a href="#讳疾忌医的典故" class="headerlink" title="讳疾忌医的典故"></a>讳疾忌医的典故</h3><p>《扁鹊见蔡桓公》的故事，我们从小就学习了，告诉我们不能盲目相信自己，不能讳疾忌医。但想想我们自己代码的坏味道和bug，也是如出一辙。</p><p>代码坏味道或者糟糕的程序代码就像隐形的“疾病”一样潜伏在项目中，也因此形成了技术债务。如果这些“疾病”在项目初期不引起注关注、不把疾病扼杀在萌芽之中，那么后期修复它的代价也就越大，也必然会使得项目的软件程序越来越难以维护，这个项目也最终会像蔡桓公一样无药可治、“无奈何也”。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">所以，请记住童子军规则对我们的启示：**始终保持代码整洁，勿以善小而不为，勿以恶小而为之，有病早治**。</font></td></tr></tbody></table><h3 id="其他原则："><a href="#其他原则：" class="headerlink" title="其他原则："></a>其他原则：</h3><ul><li>避免过早优化（Avoid Premature Optimization）: 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。“过早的优化是一切罪恶之源。”——Donald Knuth</li><li>最小惊讶原则(Principle of least astonishment): 代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。</li><li>代码重用原则（Code Reuse is Good）: 重用代码能提高代码的可读性，缩短开发时间。</li><li>别让我思考(Don’t Make Me Think): 所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</li><li>为维护者写代码(Write Code for the Maintainer): 优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。“如果一个维护者不再继续维护你的代码，很可能他就有了想杀你的冲动。”</li><li>正交原则(Orthogonality): 正交性的基本思想是，在概念上不相关的事物不应该与系统相关。设计越正交，异常越少。 这使得用编程语言更容易学习，读写程序。(反例：CSS)。</li><li>做最简单的事儿就让代码可运行（Do the simplest thing that could possibly work）: 尽可能做最简单的事就可以让代码可运行。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢？”这将有助于在设计中保持简单的路径。</li><li>隐藏实现细节（Hide Implementation Details）: 软件模块通过提供接口隐藏信息（即实现细节），而不泄漏任何不必要的信息。</li><li>科里定律(Curly’s Law): 是为任何特定的代码选择一个明确定义的目标：只做一件事。</li><li>墨菲定律（Murphy’s Law）:根本内容是：如果事情有变坏的可能，不管这种可能性有多小，它总会发生。主要内容如下：<br>&nbsp;&nbsp; - 任何事都没有表面看起来那么简单；<br>&nbsp;&nbsp; - 所有的事都会比你预计的时间长；<br>&nbsp;&nbsp; - 会出错的事总会出错；<br>&nbsp;&nbsp; - 如果你担心某种情况发生，那么它就更有可能发生。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库知识点</title>
      <link href="/2021/01/20/shu-ju-ku-zhi-shi-dian/"/>
      <url>/2021/01/20/shu-ju-ku-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<p><b><span style="color:#FF4500;">写在最前面：本文章所有内容是本人从网络整理而得，并非商用，仅供学习交流使用。</span></b></p><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h4 id="1-主键、外键、超键、候选键"><a href="#1-主键、外键、超键、候选键" class="headerlink" title="1.主键、外键、超键、候选键"></a><strong>1.主键、外键、超键、候选键</strong></h4><blockquote><p><strong>超键</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p><p><strong>候选键</strong>：是最小超键，即没有冗余元素的超键。</p><p><strong>主键</strong>：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p><p><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。</p></blockquote><h4 id="2-为什么用自增列作为主键"><a href="#2-为什么用自增列作为主键" class="headerlink" title="2.为什么用自增列作为主键"></a><strong>2.为什么用自增列作为主键</strong></h4><blockquote><p>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、</p><p>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、</p><p>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</p><p>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）</p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p></blockquote><h4 id="3-触发器的作用？"><a href="#3-触发器的作用？" class="headerlink" title="3.触发器的作用？"></a><strong>3.触发器的作用？</strong></h4><blockquote><p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p></blockquote><h4 id="4-什么是存储过程？用什么来调用？"><a href="#4-什么是存储过程？用什么来调用？" class="headerlink" title="4.什么是存储过程？用什么来调用？"></a><strong>4.什么是存储过程？用什么来调用？</strong></h4><blockquote><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><p><strong>调用：</strong></p><p>1）可以用一个命令对象来调用存储过程。</p><p>2）可以供外部程序调用，比如：java程序。</p></blockquote><h4 id="5-存储过程的优缺点？"><a href="#5-存储过程的优缺点？" class="headerlink" title="5.存储过程的优缺点？"></a><strong>5.存储过程的优缺点？</strong></h4><blockquote><p><strong>优点：</strong></p><p>1）存储过程是预编译过的，执行效率高。</p><p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p><p>3）安全性高，执行存储过程需要有一定权限的用户。</p><p>4）存储过程可以重复使用，可减少数据库开发人员的工作量。</p><p><strong>缺点：</strong>移植性差</p></blockquote><h4 id="6-存储过程与函数的区别"><a href="#6-存储过程与函数的区别" class="headerlink" title="6.存储过程与函数的区别"></a><strong>6.存储过程与函数的区别</strong></h4><p><img src="https://i.imgur.com/ymE9HPJ.png" alt="img"></p><h4 id="7-什么叫视图？游标是什么？"><a href="#7-什么叫视图？游标是什么？" class="headerlink" title="7.什么叫视图？游标是什么？"></a><strong>7.什么叫视图？游标是什么？</strong></h4><blockquote><p><strong>视图：</strong></p><p>是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。</p><p><strong>游标：</strong></p><p>是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p></blockquote><h4 id="8-视图的优缺点"><a href="#8-视图的优缺点" class="headerlink" title="8.视图的优缺点"></a><strong>8.视图的优缺点</strong></h4><blockquote><p><strong>优点：</strong></p><p>1对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。</p><p>2)用户通过简单的查询可以从复杂查询中得到结果。</p><p>3)维护数据的独立性，试图可从多个表检索数据。</p><p>4)对于相同的数据可产生不同的视图。</p><p><strong>缺点：</strong></p><p>性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据</p></blockquote><h4 id="9-drop、truncate、-delete区别"><a href="#9-drop、truncate、-delete区别" class="headerlink" title="9.drop、truncate、 delete区别"></a><strong>9.drop、truncate、 delete区别</strong></h4><blockquote><p><strong>最基本：</strong></p><ul><li>drop直接删掉表。</li><li>truncate删除表中数据，再插入时自增长id又从1开始。</li><li>delete删除表中数据，可以加where字句。</li></ul><p>（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p><p>（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</p><p>（3） 一般而言，drop &gt; truncate &gt; delete</p><p>（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view</p><p>（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。</p><p>（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</p><p>（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</p><p>（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。</p><p>（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。</p><p>（10） Truncate table 表名 速度快,而且效率高,因为:?truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p><p>（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</p><p>（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p></blockquote><h4 id="10-什么是临时表，临时表什么时候删除"><a href="#10-什么是临时表，临时表什么时候删除" class="headerlink" title="10.什么是临时表，临时表什么时候删除?"></a><strong>10.什么是临时表，临时表什么时候删除?</strong></h4><blockquote><p><strong>临时表可以手动删除：</strong><br>DROP TEMPORARY TABLE IF EXISTS temp_tb;</p><p><strong>临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。<br>创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY，</strong></p><p>如：</p><p>CREATE TEMPORARY TABLE tmp_table (</p><p>NAME VARCHAR (10) NOT NULL,</p><p>time date NOT NULL<br>);</p><p>select * from tmp_table;</p></blockquote><h4 id="11-非关系型数据库和关系型数据库区别，优势比较"><a href="#11-非关系型数据库和关系型数据库区别，优势比较" class="headerlink" title="11.非关系型数据库和关系型数据库区别，优势比较?"></a><strong>11.非关系型数据库和关系型数据库区别，优势比较?</strong></h4><blockquote><p><strong>非关系型数据库的优势：</strong></p><ul><li><strong>性能：</strong>NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li><li><strong>可扩展性：</strong>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li></ul><p><strong>关系型数据库的优势：</strong></p><ul><li><strong>复杂查询：</strong>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li><strong>事务支持：</strong>使得对于安全性能很高的数据访问要求得以实现。</li></ul><p><strong>其他：</strong></p><p>**1.**对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p><p>**2.**NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。</p><p>**3.**对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。</p></blockquote><h4 id="12-数据库范式，根据某个场景设计数据表"><a href="#12-数据库范式，根据某个场景设计数据表" class="headerlink" title="12.数据库范式，根据某个场景设计数据表?"></a><strong>12.数据库范式，根据某个场景设计数据表?</strong></h4><blockquote><p><strong>第一范式:</strong>(确保每列保持原子性)所有字段值都是不可分解的原子值。</p><p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。<br>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。<br>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p><p><strong>第二范式:</strong>(确保表中的每列都和主键相关)在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。<br>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。</p><p><strong>第三范式:</strong>(确保每列都和主键列直接相关,而不是间接相关) 数据表中的每一列数据都和主键直接相关，而不能间接相关。</p><p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。<br>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p><p>**BCNF:**符合3NF，并且，主属性不依赖于主属性。</p><p>若关系模式属于第二范式，且每个属性都不传递依赖于键码，则R属于BC范式。<br>通常BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。<br>BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。<br>还可以这么说：若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。<br>一般，一个数据库设计符合3NF或BCNF就可以了。</p><p>**第四范式:**要求把同一表内的多对多关系删除。</p><p>**第五范式:**从最终结构重新建立原始结构。</p></blockquote><h4 id="13-什么是-内连接、外连接、交叉连接、笛卡尔积等"><a href="#13-什么是-内连接、外连接、交叉连接、笛卡尔积等" class="headerlink" title="13.什么是 内连接、外连接、交叉连接、笛卡尔积等?"></a><strong>13.什么是 内连接、外连接、交叉连接、笛卡尔积等?</strong></h4><blockquote><p><strong>内连接:</strong> 只连接匹配的行</p><p><strong>左外连接:</strong> 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行</p><p><strong>右外连接:</strong> 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行</p><p>例如1：<br>SELECT a.<em>,b.</em> FROM luntan LEFT JOIN usertable as b ON a.username=b.username</p><p>例如2：<br>SELECT a.<em>,b.</em> FROM city as a FULL OUTER JOIN user as b ON a.username=b.username</p><p><strong>全外连接:</strong> 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。</p><p><strong>交叉连接:</strong> 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</p><p>例如：<br>SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type</p><p><strong>注意：</strong></p><p>很多公司都只是考察是否知道其概念，但是也有很多公司需要不仅仅知道概念，还需要动手写sql,一般都是简单的连接查询，具体关于连接查询的sql练习，参见以下链接：</p><p><a href="https://www.nowcoder.com/ta/sql">牛客网数据库SQL实战</a></p><p><a href="https://leetcode-cn.com/problemset/database/">leetcode中文网站数据库练习</a></p></blockquote><h4 id="14-varchar和char的使用场景"><a href="#14-varchar和char的使用场景" class="headerlink" title="14.varchar和char的使用场景?"></a><strong>14.varchar和char的使用场景?</strong></h4><blockquote></blockquote><blockquote><p>**1.**char的长度是不可变的，而varchar的长度是可变的。</p><p>定义一个char[10]和varchar[10]。<br>如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。</p><p>**2.**char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。<br>char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。<br>varchar是以空间效率为首位。</p><p>**3.**char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。<br>varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。</p><p>**4.**两者的存储数据都非unicode的字符数据。</p></blockquote><h4 id="15-SQL语言分类"><a href="#15-SQL语言分类" class="headerlink" title="15.SQL语言分类"></a><strong>15.SQL语言分类</strong></h4><blockquote><p><strong>SQL语言共分为四大类：</strong></p><ul><li>数据查询语言DQL</li><li>数据操纵语言DML</li><li>数据定义语言DDL</li><li>数据控制语言DCL。</li></ul><p><strong>1. 数据查询语言DQL</strong></p><p>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：</p><p>SELECT<br>FROM<br>WHERE</p><p><strong>2 .数据操纵语言DML</strong></p><p>数据操纵语言DML主要有三种形式：</p><ol><li>插入：INSERT</li><li>更新：UPDATE</li><li>删除：DELETE</li></ol><p><strong>3. 数据定义语言DDL</strong></p><p>数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等如：<br>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER</p><p>表 视图 索引 同义词 簇</p><p>DDL操作是隐性提交的！不能rollback</p><p><strong>4. 数据控制语言DCL</strong></p><p>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p><ol><li>GRANT：授权。</li><li>ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚—ROLLBACK；回滚命令使数据库状态回到上次最后提交的状态。其格式为：<br>SQL&gt;ROLLBACK;</li><li>COMMIT [WORK]：提交。</li></ol><p>在数据库的插入、删除和修改操作时，只有当事务在提交到数据<br>库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看<br>到所做的事情，别人只有在最后提交完成后才可以看到。<br>提交数据有三种类型：显式提交、隐式提交及自动提交。下面分<br>别说明这三种类型。</p><p>(1) 显式提交<br>用COMMIT命令直接完成的提交为显式提交。其格式为：<br>SQL&gt;COMMIT；</p><p>(2) 隐式提交<br>用SQL命令间接完成的提交为隐式提交。这些命令是：<br>ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，<br>EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。</p><p>(3) 自动提交<br>若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，<br>系统将自动进行提交，这就是自动提交。其格式为：<br>SQL&gt;SET AUTOCOMMIT ON；</p><p>参考文章：<br><a href="https://www.cnblogs.com/study-s/p/5287529.html">https://www.cnblogs.com/study-s/p/5287529.html</a></p></blockquote><h4 id="16-like-和-的区别"><a href="#16-like-和-的区别" class="headerlink" title="16.like %和-的区别"></a><strong>16.like %和-的区别</strong></h4><blockquote><p><strong>通配符的分类:</strong></p><p>**%百分号通配符:**表示任何字符出现任意次数(可以是0次).</p><p>**_下划线通配符:**表示只能匹配单个字符,不能多也不能少,就是一个字符.</p><p><strong>like操作符:</strong> LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.</p><p><strong>注意:</strong> 如果在使用like操作符时,后面的没有使用通用匹配符效果是和=一致的,SELECT * FROM products WHERE products.prod_name like ‘1000’;<br>只能匹配的结果为1000,而不能匹配像JetPack 1000这样的结果.</p><ul><li>%通配符使用: 匹配以”yves”开头的记录:(包括记录”yves”) SELECT <em>FROM products WHERE products.prod_name like ‘yves%’;<br>匹配包含”yves”的记录(包括记录”yves”) SELECT</em> FROM products WHERE products.prod_name like ‘%yves%’;<br>匹配以”yves”结尾的记录(包括记录”yves”,不包括记录”yves “,也就是yves后面有空格的记录,这里需要注意) SELECT * FROM products WHERE products.prod_name like ‘%yves’;</li><li><em>通配符使用: SELECT *FROM products WHERE products.prod_name like ‘_yves’; 匹配结果为: 像”yyves”这样记录.<br>SELECT* FROM products WHERE products.prod*name like ‘yves</em>*’; 匹配结果为: 像”yvesHe”这样的记录.(一个下划线只能匹配一个字符,不能多也不能少)</li></ul><p><strong>注意事项:</strong></p><ul><li>注意大小写,在使用模糊匹配时,也就是匹配文本时,mysql是可能区分大小的,也可能是不区分大小写的,这个结果是取决于用户对MySQL的配置方式.如果是区分大小写,那么像YvesHe这样记录是不能被”yves__”这样的匹配条件匹配的.</li><li>注意尾部空格,”%yves”是不能匹配”heyves “这样的记录的.</li><li>注意NULL,%通配符可以匹配任意字符,但是不能匹配NULL,也就是说SELECT * FROM products WHERE products.prod_name like ‘%;是匹配不到products.prod_name为NULL的的记录.</li></ul><p><strong>技巧与建议:</strong></p><p>正如所见， MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。</p><ul><li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该 使用其他操作符。</li><li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起 来是最慢的。</li><li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数.</li></ul></blockquote><p>参考博文：<a href="https://blog.csdn.net/u011479200/article/details/78513632">https://blog.csdn.net/u011479200/article/details/78513632</a></p><h4 id="17-count-、count-1-、count-column-的区别"><a href="#17-count-、count-1-、count-column-的区别" class="headerlink" title="17.count(*)、count(1)、count(column)的区别"></a><strong>17.count(*)、count(1)、count(column)的区别</strong></h4><blockquote><ul><li>count(*)对行的数目进行计算,包含NULL</li><li>count(column)对特定的列的值具有的行数进行计算,不包含NULL值。</li><li>count()还有一种使用方式,count(1)这个用法和count(*)的结果是一样的。</li></ul><p><strong>性能问题:</strong></p><p>1.任何情况下SELECT COUNT(*) FROM tablename是最优选择;</p><p>2.尽量减少SELECT COUNT(*) FROM tablename WHERE COL = ‘value’ 这种查询;</p><p>3.杜绝SELECT COUNT(COL) FROM tablename WHERE COL2 = ‘value’ 的出现。</p><ul><li>如果表没有主键,那么count(1)比count(*)快。</li><li>如果有主键,那么count(主键,联合主键)比count(*)快。</li><li>如果表只有一个字段,count(*)最快。</li></ul><p>count(1)跟count(主键)一样,只扫描主键。count(*)跟count(非主键)一样,扫描整个表。明显前者更快一些。</p></blockquote><h4 id="18-最左前缀原则"><a href="#18-最左前缀原则" class="headerlink" title="18.最左前缀原则"></a><strong>18.最左前缀原则</strong></h4><blockquote><p><strong>多列索引：</strong></p><p>ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);</p><p>为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。</p><p>注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。</p><p><strong>最左前缀原则：</strong>顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。</p></blockquote><h2 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h2><h4 id="1-什么是索引？"><a href="#1-什么是索引？" class="headerlink" title="1.什么是索引？"></a><strong>1.什么是索引？</strong></h4><blockquote><p><strong>何为索引：</strong></p><p>数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其变种B+树。</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p></blockquote><h4 id="2-索引的作用？它的优点缺点是什么？"><a href="#2-索引的作用？它的优点缺点是什么？" class="headerlink" title="2.索引的作用？它的优点缺点是什么？"></a><strong>2.索引的作用？它的优点缺点是什么？</strong></h4><blockquote><p><strong>索引作用：</strong></p><p>协助快速查询、更新数据库表中数据。</p><p>为表设置索引要付出代价的：</p><ul><li><p>一是增加了数据库的存储空间</p></li><li><p>二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p><h4 id="3-索引的优缺点？"><a href="#3-索引的优缺点？" class="headerlink" title="3.索引的优缺点？"></a><strong>3.索引的优缺点？</strong></h4></li></ul><p><strong>创建索引可以大大提高系统的性能（优点）：</strong></p><p>1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><p>2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p>3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><p>4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p><p>5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p><strong>增加索引也有许多不利的方面(缺点)：</strong></p><p>1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><p>2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p>3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p></blockquote><h4 id="4-哪些列适合建立索引、哪些不适合建索引？"><a href="#4-哪些列适合建立索引、哪些不适合建索引？" class="headerlink" title="4.哪些列适合建立索引、哪些不适合建索引？"></a><strong>4.哪些列适合建立索引、哪些不适合建索引？</strong></h4><blockquote><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。</p><p><strong>一般来说，应该在这些列上创建索引：</strong></p><p>（1）在经常需要搜索的列上，可以加快搜索的速度；</p><p>（2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</p><p>（3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</p><p>（4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</p><p>（5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p><p>（6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p><p><strong>对于有些列不应该创建索引：</strong></p><p>（1）对于那些在查询中很少使用或者参考的列不应该创建索引。</p><p>这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p>（2）对于那些只有很少数据值的列也不应该增加索引。</p><p>这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p><p>（3）对于那些定义为text, image和bit数据类型的列不应该增加索引。</p><p>这是因为，这些列的数据量要么相当大，要么取值很少。</p><p>(4)当修改性能远远大于检索性能时，不应该创建索引。</p><p>这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p></blockquote><h4 id="5-什么样的字段适合建索引"><a href="#5-什么样的字段适合建索引" class="headerlink" title="5.什么样的字段适合建索引"></a><strong>5.什么样的字段适合建索引</strong></h4><blockquote><p>唯一、不为空、经常被查询的字段</p><h4 id="6-MySQL-B-Tree索引和Hash索引的区别"><a href="#6-MySQL-B-Tree索引和Hash索引的区别" class="headerlink" title="6.MySQL B+Tree索引和Hash索引的区别?"></a><strong>6.MySQL B+Tree索引和Hash索引的区别?</strong></h4><p><strong>Hash索引和B+树索引的特点：</strong></p><ul><li>Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位;</li><li>B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问;</li></ul><p><strong>为什么不都用Hash索引而使用B+树索引？</strong></p><ol><li>Hash索引仅仅能满足”=”,”IN”和””查询，不能使用范围查询,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样；</li><li>Hash索引无法被用来避免数据的排序操作，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样；</li><li>Hash索引不能利用部分索引键查询，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用；</li><li>Hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据；</li><li>Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高。</li></ol><p><strong>补充：</strong></p><p>1.MySQL中，只有HEAP/MEMORY引擎才显示支持Hash索引。</p><p>2.常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。<br>B+树索引和哈希索引的明显区别是：</p><p>3.如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</p><p>4.如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；<br>同理，哈希索引没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</p><p>5.哈希索引也不支持多列联合索引的最左匹配规则；</p><p>6.B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</p><p>7.在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。</p></blockquote><h4 id="7-B树和B-树的区别"><a href="#7-B树和B-树的区别" class="headerlink" title="7.B树和B+树的区别"></a><strong>7.B树和B+树的区别</strong></h4><blockquote><ol><li>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。<br><img src="https://i.imgur.com/RbzI0R8.jpg" alt="img"></li><li>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)<br><img src="https://i.imgur.com/9VbnDME.jpg" alt="img"></li></ol></blockquote><h4 id="8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a><strong>8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</strong></h4><blockquote><p><strong>1.B+的磁盘读写代价更低</strong></p><p>B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p><strong>2.B+tree的查询效率更加稳定</strong></p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></blockquote><h4 id="9-聚集索引和非聚集索引区别"><a href="#9-聚集索引和非聚集索引区别" class="headerlink" title="9.聚集索引和非聚集索引区别?"></a><strong>9.聚集索引和非聚集索引区别?</strong></h4><blockquote><p><strong>聚合索引(clustered index):</strong></p><p>聚集索引<strong>表记录的排列顺序和索引的排列顺序一致，所以查询效率快，</strong>只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。<br>聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。</p><p><strong>非聚合索引(nonclustered index):</strong></p><p>非聚集索引<strong>指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，</strong>两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。<br>非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。</p><p><strong>根本区别：</strong></p><p>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</p></blockquote><h2 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h2><h4 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1.什么是事务？"></a><strong>1.什么是事务？</strong></h4><blockquote><p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p></blockquote><h4 id="2-事务四大特性（ACID）原子性、一致性、隔离性、持久性"><a href="#2-事务四大特性（ACID）原子性、一致性、隔离性、持久性" class="headerlink" title="2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?"></a><strong>2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?</strong></h4><blockquote><p><strong>原子性（Atomicity）:</strong><br>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><p><strong>一致性（Consistency）:</strong><br>事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p><p><strong>隔离性（Isolation）:</strong><br>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p><p><strong>持久性（Durability）:</strong><br>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p></blockquote><h4 id="3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别"><a href="#3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别" class="headerlink" title="3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?"></a><strong>3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?</strong></h4><blockquote><p>从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。<br><strong>事务的并发问题</strong></p><p><strong>1、脏读：</strong>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p><p><strong>2、不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p><p><strong>3、幻读：</strong>幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。</p><p>例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。<br><strong>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</strong></p><p><strong>事务的隔离级别</strong></p><p><img src="https://i.imgur.com/xAeWTSp.png" alt="img"></p><p><strong>读未提交：</strong>另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读</p><p><strong>不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p><p><strong>可重复读：</strong>在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象</p><p><strong>串行化：</strong>最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样</p></blockquote><p><strong>特别注意：</strong></p><blockquote><p>MySQL默认的事务隔离级别为repeatable-read</p><p>MySQL 支持 4 中事务隔离级别.</p><p>事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持.</p><p>Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE</p><p>SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异</p><p><strong>MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行</strong></p><p><strong>事务隔离级别：</strong>未提交读时，写数据只会锁住相应的行。</p><p><strong>事务隔离级别为：</strong>可重复读时，写数据会锁住整张表。</p><p><strong>事务隔离级别为：</strong>串行化时，读写数据都会锁住整张表。</p><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p></blockquote><h4 id="4-事务传播行为"><a href="#4-事务传播行为" class="headerlink" title="4.事务传播行为"></a><strong>4.事务传播行为</strong></h4><blockquote><p><strong>1.PROPAGATION_REQUIRED：</strong>如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p><strong>2.PROPAGATION_SUPPORTS：</strong>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p><p><strong>3.PROPAGATION_MANDATORY：</strong>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p><strong>4.PROPAGATION_REQUIRES_NEW：</strong>创建新事务，无论当前存不存在事务，都创建新事务。</p><p><strong>5.PROPAGATION_NOT_SUPPORTED：</strong>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p><strong>6.PROPAGATION_NEVER：</strong>以非事务方式执行，如果当前存在事务，则抛出异常。</p><p><strong>7.PROPAGATION_NESTED：</strong>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p></blockquote><h4 id="5-嵌套事务"><a href="#5-嵌套事务" class="headerlink" title="5.嵌套事务"></a><strong>5.嵌套事务</strong></h4><blockquote><p><strong>什么是嵌套事务？</strong></p><p>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了：</p><p><strong>如果子事务回滚，会发生什么？</strong></p><p>父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</p><p><strong>如果父事务回滚，会发生什么？</strong></p><p>父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：</p><p><strong>事务的提交，是什么情况？</strong></p><p>是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</p></blockquote><p>参考文章：<a href="https://blog.csdn.net/liangxw1/article/details/51197560">https://blog.csdn.net/liangxw1/article/details/51197560</a></p><h2 id="四、存储引擎"><a href="#四、存储引擎" class="headerlink" title="四、存储引擎"></a>四、存储引擎</h2><h4 id="1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别"><a href="#1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别" class="headerlink" title="1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?"></a><strong>1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?</strong></h4><blockquote><p><strong>两种存储引擎的大致区别表现在：</strong></p><p>1.<strong>InnoDB支持事务，MyISAM不支持，</strong> <strong>这一点是非常之重要。</strong>事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</p><p>2.MyISAM适合查询以及插入为主的应用。</p><p>3.InnoDB适合频繁修改以及涉及到安全性较高的应用。</p><p>4.InnoDB支持外键，MyISAM不支持。</p><p>5.从MySQL5.5.5以后，InnoDB是默认引擎。</p><p>6.InnoDB不支持FULLTEXT类型的索引。</p><p>7.InnoDB中不保存表的行数，如select count(<em>) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含where条件时MyISAM也需要扫描整个表。</p><p>8.对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。</p><p>9.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除，效率非常慢。MyISAM则会重建表。</p><p>10.InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’。</p></blockquote><h4 id="2-MySQL存储引擎MyISAM与InnoDB如何选择"><a href="#2-MySQL存储引擎MyISAM与InnoDB如何选择" class="headerlink" title="2.MySQL存储引擎MyISAM与InnoDB如何选择"></a><strong>2.MySQL存储引擎MyISAM与InnoDB如何选择</strong></h4><blockquote><p>MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。</p><p>虽然MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个。<br>关于MySQL数据库提供的两种存储引擎，MyISAM与InnoDB选择使用：</p></blockquote><ul><li>1.INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MyISAM不支持。</li><li>2.MyISAM的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。</li></ul><blockquote><p>如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句。</p><p>如果你的应用程序对查询性能要求较高，就要使用MyISAM了。MyISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MyISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。</p><p>有人说MyISAM只能用于小型应用，其实这只是一种偏见。如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，而不是单纯地依赖存储引擎。</p><p>现在一般都是选用innodb了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。<br>MEMORY存储引擎</p><p>MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。<br>每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。</p><p>MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。</p><p>注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。</p></blockquote><h4 id="3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景"><a href="#3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景" class="headerlink" title="3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?"></a><strong>3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?</strong></h4><blockquote><p><strong>事务处理上方面</strong></p></blockquote><ul><li>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</li><li>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li></ul><blockquote><p><strong>锁级别</strong></p></blockquote><ul><li>MyISAM：只支持表级锁，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</li><li>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</li></ul><blockquote><p><strong>关于存储引擎MyISAM和InnoDB的其他参考资料如下：</strong></p><p><a href="http://blog.csdn.net/lc0817/article/details/52757194">MySQL存储引擎中的MyISAM和InnoDB区别详解</a></p><p><a href="https://www.cnblogs.com/kevingrace/p/5685355.html">MySQL存储引擎之MyISAM和Innodb总结性梳理</a></p></blockquote><h2 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h2><h4 id="1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?"></a><strong>1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?</strong></h4><ul><li>1.查询中用到的关键词主要包含<strong>六个</strong>，并且他们的顺序依次为 <strong>select–from–where–group by–having–order by</strong></li></ul><blockquote><p><strong>其中select和from是必须的，其他关键词是可选的，这六个关键词的执行顺序 与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行</strong></p><p>**from:**需要从哪个数据表检索数据</p></blockquote><blockquote><p>**where:**过滤表中数据的条件</p><p>**group by:**如何将上面过滤出的数据分组</p><p>**having:**对上面已经分组的数据进行过滤的条件</p><p>**select:**查看结果集中的哪个列，或列的计算结果</p><p>**order by :**按照什么样的顺序来查看返回的数据</p></blockquote><ul><li>2.<strong>from后面的表关联，是自右向左解析 而where条件的解析顺序是自下而上的。</strong></li></ul><blockquote><p>也就是说，在写SQL语句的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在where语句的最左边 （用小表去匹配大表）</p><p>其他参考资源：<br><a href="http://www.cnblogs.com/huminxxl/p/3149097.html">http://www.cnblogs.com/huminxxl/p/3149097.html</a></p></blockquote><h4 id="2-使用explain优化sql和索引"><a href="#2-使用explain优化sql和索引" class="headerlink" title="2.使用explain优化sql和索引?"></a><strong>2.使用explain优化sql和索引?</strong></h4><blockquote><p><strong>对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化</strong></p><p><strong>table：</strong>显示这一行的数据是关于哪张表的</p><p><strong>type：</strong>这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL</p><p>**all:**full table scan ;MySQL将遍历全表以找到匹配的行；</p><p><strong>index:</strong> index scan; index 和 all的区别在于index类型只遍历索引；</p><p><strong>range：</strong>索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，等查询；</p><p><strong>ref：</strong>非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；</p><p><strong>eq_ref：</strong>唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；</p><p><strong>const，system：</strong>当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。</p><p><strong>possible_keys：</strong>显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p><p><strong>key：</strong> 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引</p><p><strong>key_len：</strong>使用的索引的长度。在不损失精确性的情况下，长度越短越好</p><p><strong>ref：</strong>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><p><strong>rows：</strong>MySQL认为必须检查的用来返回请求数据的行数</p><p><strong>Extra：</strong>关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。</p></blockquote><h4 id="3-MySQL慢查询怎么解决"><a href="#3-MySQL慢查询怎么解决" class="headerlink" title="3.MySQL慢查询怎么解决?"></a><strong>3.MySQL慢查询怎么解决?</strong></h4><blockquote><ul><li>slow_query_log 慢查询开启状态。</li><li>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。</li><li>long_query_time 查询超过多少秒才记录。</li></ul></blockquote><h2 id="六、数据库锁"><a href="#六、数据库锁" class="headerlink" title="六、数据库锁"></a>六、数据库锁</h2><h4 id="1-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决"><a href="#1-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决" class="headerlink" title="1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?"></a><strong>1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?</strong></h4><blockquote><p><strong>MySQL有三种锁的级别：</strong>页级、表级、行级。</p><ul><li><strong>表级锁：</strong>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li><li><strong>行级锁：</strong>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li><strong>页面锁：</strong>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<br><strong>什么情况下会造成死锁?</strong></li></ul><p><strong>什么是死锁？</strong></p><p><strong>死锁:</strong> 是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。</p><p>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。</p><p><strong>死锁的关键在于：</strong>两个(或以上)的Session加锁的顺序不一致。</p><p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。</p><p><strong>死锁的解决办法?</strong></p><p>1.查出的线程杀死 kill<br>SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;</p><p>2.设置锁的超时时间<br>Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。</p><p>生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值<br>该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：<br>set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。</p><p>3.指定获取锁的顺序</p></blockquote><h4 id="2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁"><a href="#2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁" class="headerlink" title="2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?"></a><strong>2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?</strong></h4><blockquote><p><strong>悲观锁（Pessimistic Lock）:</strong></p><p>**悲观锁特点:**先获取锁，再进行业务操作。</p><p>即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的<strong>“一锁二查三更新”即指的是使用悲观锁。</strong>通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p><p><strong>补充：</strong><br>不同的数据库对select for update的实现和支持都是有所区别的，</p><ul><li>oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有no wait这个选项。</li><li>MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。</li></ul><p><strong>乐观锁（Optimistic Lock）:</strong></p><p>**1.**乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。</p><p>*<em>2.*</em>**乐观锁的特点先进行业务操作，不到万不得已不去拿锁。**即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。<br>乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。</p><p><strong>3.<strong>一般的做法是</strong>在需要锁的数据上增加一个版本号，或者时间戳</strong>，</p><p><strong>实现方式举例如下：</strong></p><p><strong>乐观锁（给表加一个版本号字段）</strong> 这个并不是乐观锁的定义，给表加版本号，是<strong>数据库实现乐观锁的一种方式</strong>。</p><ol><li>SELECT data AS old_data, version AS old_version FROM …;</li><li>根据获取的数据进行业务操作，得到new_data和new_version</li><li>UPDATE SET data = new_data, version = new_version WHERE version = old_version</li></ol><p>if (updated row &gt; 0) {</p><p>// 乐观锁获取成功，操作完成</p><p>} else {</p><p>// 乐观锁获取失败，回滚并重试</p><p>}</p><p><strong>注意：</strong></p><ul><li>乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能</li><li>乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。</li></ul><p><strong>总结：</strong><br>悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select … for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。</p><ul><li><strong>响应速度：</strong> 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。’</li><li><strong>冲突频率：</strong> 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。</li><li><strong>重试代价：</strong> 如果重试代价大，建议采用悲观锁。</li></ul></blockquote><h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><h4 id="1-数据库的主从复制"><a href="#1-数据库的主从复制" class="headerlink" title="1.数据库的主从复制"></a><strong>1.数据库的主从复制</strong></h4><blockquote><p><strong>主从复制的几种方式:</strong></p><p><strong>同步复制:</strong></p><p>所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。 这样，显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。</p><p><strong>异步复制:</strong></p><p>如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。</p><p><strong>半同步复制:</strong></p><p>master只保证slaves中的一个操作成功，就返回，其他slave不管。 这个功能，是由google为MySQL引入的。</p></blockquote><h4 id="2-数据库主从复制分析的-7-个问题"><a href="#2-数据库主从复制分析的-7-个问题" class="headerlink" title="2.数据库主从复制分析的 7 个问题?"></a><strong>2.数据库主从复制分析的 7 个问题?</strong></h4><p><strong>问题1：</strong>master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？</p><blockquote><p>假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此slave不应该进行写操作，至少是slave上涉及到复制的数据库不可以写。实际上，这里已经揭示了读写分离的概念。</p></blockquote><p><strong>问题2：</strong>主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？</p><blockquote><p><strong>实现数据备份:</strong><br>类似于高可用的功能，一旦master挂了，可以让slave顶上去，同时slave提升为master。</p><p>**异地容灾:**比如master在北京，地震挂了，那么在上海的slave还可以继续。<br>主要用于实现scale out,分担负载,可以将读的任务分散到slaves上。<br>【很可能的情况是，一个系统的读操作远远多于写操作，因此写操作发向master，读操作发向slaves进行操作】</p></blockquote><p><strong>问题3：</strong>主从复制中有master,slave1,slave2,…等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?</p><blockquote><p>我们在应用程序中可以这样，insert/delete/update这些更新数据库的操作，用connection(for master)进行操作，</p><p>select用connection(for slaves)进行操作。那我们的应用程序还要完成怎么从slaves选择一个来执行select，例如使用简单的轮循算法。</p><p>这样的话，相当于应用程序完成了SQL语句的路由，而且与MySQL的主从复制架构非常关联，一旦master挂了，某些slave挂了，那么应用程序就要修改了。能不能让应用程序与MySQL的主从复制架构没有什么太多关系呢？<br>找一个组件，application program只需要与它打交道，用它来完成MySQL的代理，实现SQL语句的路由。<br>MySQL proxy并不负责，怎么从众多的slaves挑一个？可以交给另一个组件(比如haproxy)来完成。</p><p>这就是所谓的MySQL READ WRITE SPLITE，MySQL的读写分离。</p></blockquote><p><strong>问题4：</strong>如果MySQL proxy , direct , master他们中的某些挂了怎么办？</p><blockquote><p>总统一般都会弄个副总统，以防不测。同样的，可以给这些关键的节点来个备份。</p></blockquote><p><strong>问题5：</strong>当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？如果只发一次，发给了slave-1，那slave-2,slave-3,…它们怎么办？</p><blockquote><p>显 然，应该发N次。实际上，在MySQL master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,…的主，同时slave-1不再负责select。 slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。</p></blockquote><p><strong>问题6：</strong>当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。</p><blockquote><p>应该找一个共享式的缓存，比如memcache来解决。将slave-2,slave-3,…这些查询的结果都缓存至mamcache中。</p></blockquote><p><strong>问题7：</strong>随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？</p><blockquote><p>scale on ?更好的服务器？ 没有最好的，只有更好的，太贵了。。。<br>scale out ? 主从复制架构已经满足不了。<br>可以分库【垂直拆分】，分表【水平拆分】。</p></blockquote><h4 id="3-mysql-高并发环境解决方案"><a href="#3-mysql-高并发环境解决方案" class="headerlink" title="3.mysql 高并发环境解决方案?"></a><strong>3.mysql 高并发环境解决方案?</strong></h4><blockquote><p><strong>MySQL 高并发环境解决方案：</strong> 分库 分表 分布式 增加二级缓存。。。。。</p><p><strong>需求分析：</strong>互联网单位 每天大量数据读取，写入，并发性高。</p><p><strong>现有解决方式：</strong>水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。</p><p><strong>集群方案：</strong>解决DB宕机带来的单点DB不能访问问题。</p><p><strong>读写分离策略：</strong>极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。</p></blockquote><h4 id="4-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）"><a href="#4-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）" class="headerlink" title="4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?"></a><strong>4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?</strong></h4><p>转载：<a href="https://www.cnblogs.com/Bozh/archive/2013/03/18/2966494.html">MySQL REDO日志和UNDO日志</a></p><blockquote><p><strong>Undo Log:</strong></p><p>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用了Undo Log来实现多版本并发控制(简称：MVCC)。</p><p>事务的原子性(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。<br>原理Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。</p><p>之所以能同时保证原子性和持久化，是因为以下<strong>特点：</strong></p><p>更新数据前记录Undo log。<br>为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。<br>Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务。<br>如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。</p><p><strong>缺陷：</strong>每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log。</p><p><strong>Redo Log:</strong></p><p>原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。</p></blockquote><h4 id="八、整理时参考的资料"><a href="#八、整理时参考的资料" class="headerlink" title="八、整理时参考的资料"></a><strong>八、整理时参考的资料</strong></h4><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMTY0NDU3Nw==&amp;mid=2651936134&amp;idx=1&amp;sn=5213a59104f6d2a90bc18d878cafe417&amp;chksm=8d0f3ac8ba78b3deb2ea3473906a37dd205b6e64bfbebe86cc00108242bfa4c49a7d1e509eca&amp;mpshare=1&amp;scene=1&amp;srcid=0707k8Bdz85tDHyVotxEQ9of#rd">java团长 数据库整理</a></p><p><a href="https://my.oschina.net/yanpenglei/blog/1650277">20个数据库常见面试题讲解 - 鹏磊 - 开源中国”</a></p><p><a href="https://m.2cto.com/database/201710/688377.html">34个数据库常见面试题讲解</a></p><p><a href="https://kb.cnblogs.com/page/45712/">漫谈数据库索引<em>知识库</em>博客园</a></p><p><a href="https://blog.csdn.net/u011479200/article/details/78513632">Mysql| 使用通配符进行模糊查询(like,%,_)</a></p><p><a href="http://blog.csdn.net/lc0817/article/details/52757194">MySQL存储引擎中的MyISAM和InnoDB区别详解</a></p><p><a href="https://www.cnblogs.com/kevingrace/p/5685355.html">MySQL存储引擎之MyISAM和Innodb总结性梳理</a></p><p><a href="https://blog.csdn.net/liangxw1/article/details/51197560">https://blog.csdn.net/liangxw1/article/details/51197560</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识点整理（二）</title>
      <link href="/2020/12/22/ji-suan-ji-wang-luo-zhi-shi-dian-zheng-li-er/"/>
      <url>/2020/12/22/ji-suan-ji-wang-luo-zhi-shi-dian-zheng-li-er/</url>
      
        <content type="html"><![CDATA[<p><b><span style="color:#FF4500;">写在最前面：本文章所有内容是本人从网络整理而得，并非商用，仅供学习交流使用。</span></b></p><p><b><span style="color:#FF4500">另一部分参见：</span></b><a href="https://zningj.github.io/2020/12/21/ji-suan-ji-wang-luo-zhi-shi-dian-zheng-li-yi/">计算机网络知识点整理（一） | 不吃香菜的博客</a></p><p><strong>DNS：</strong>Domain Name System，域名系统，是互联网使用的命名系统，用来便于把人们使用的机器名字转换为IP地址。</p><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626677436_5d3a5c6a9457872609.png" alt="5d3a5c6a9457872609">如上图，m.xyz.com需要查找y.abc.com的IP地址：</p><blockquote><ul><li><p>主机m.xyz.com向本地域名服务器进行递归查询。</p><blockquote><p>主机向本地域名服务器查询时一般使用递归查询。</p><ul><li><strong>递归查询</strong>：就是如果本地域名服务器没有所需域名的IP地址，本地域名服务器就以客户的方式向其他根域名服务器继续查询，而不是主机自己进行查询。</li></ul><p>本地域名服务器向其他根域名服务器进行查询的时一般使用迭代查询。</p><ul><li><strong>迭代查询：</strong> 当某个根域名服务器收到本地域名服务器的请求报文时，要么告诉它所需域名的IP地址，要么告诉它下一步应该向哪个服务器发起询问。然后让本地域名服务器自己去查询。</li></ul></blockquote></li><li><p>本地域名服务器迭代查询，先向一个根域名服务器查询。</p></li><li><p>根域名服务器告诉本地域名服务器，下一步应该向顶级域名服务器dns.com查询。</p></li><li><p>顶级域名服务器dns.com告诉本地域名服务器，下一步查找权限域名服务器：dns.adc.com。</p></li><li><p>本地域名服务器向权限域名服务器发起查询。权限域名服务器告诉本地服务器所需的IP地址，本地服务器在告诉给本地主机。</p></li></ul></blockquote><h4 id="补充——域名服务器的分类："><a href="#补充——域名服务器的分类：" class="headerlink" title="补充——域名服务器的分类："></a>补充——域名服务器的分类：</h4><blockquote><ul><li><strong>根域名服务器：</strong> 最高层也是最重要的域名服务器，<strong>所有的根域名服务器都知道所有的顶级域名服务器的域名地址和IP地址</strong>。例如：a.rootserver.net。</li><li><strong>顶级域名服务器：</strong> 这些域名服务器负责管理在该顶级域名服务器上注册的所有的二级域名。例如：com</li><li><strong>权限域名服务器：</strong> 负责一个区的域名服务器，如果当前权限域名服务器不能给出所需的IP地址，则返回客户应该找哪一个权限服务器。</li><li><strong>本地域名服务器：</strong> 本地DNS一般是指你电脑上网时IPv4或者IPv6设置中填写的那个DNS。这个有可能是手工指定的或者是DHCP自动分配的。当一台主机发送DNS请求报文时，这个查询报文就发送给本地域名服务器。</li></ul></blockquote><hr><h3 id="简述HTTP协议以及一次HTTP操作的。"><a href="#简述HTTP协议以及一次HTTP操作的。" class="headerlink" title="简述HTTP协议以及一次HTTP操作的。"></a>简述HTTP协议以及一次HTTP操作的。</h3><p><strong>HTTP 是面向事务的(transaction-oriented)应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。</strong></p><ul><li>HTTP 是面向事务的客户服务器协议。</li><li>HTTP 1.0 协议是无状态的(stateless)。</li><li>HTTP 协议本身也是无连接的，虽然它使用了面向连接的 TCP 向上提供的服务。</li></ul><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626659403_5d3e522382fd145179.png" alt="5d3e522382fd145179"></p><p><strong>一次HTTP操作的过程：</strong></p><blockquote><ul><li>浏览器分析超链指向页面的 URL。</li><li>浏览器向 DNS 请求解析 <a href="http://www.tsinghua.edu.cn/">www.tsinghua.edu.cn</a> 的 IP 地址。</li><li>域名系统 DNS 解析出清华大学服务器的 IP 地址。</li><li>浏览器与服务器建立 TCP 连接</li><li>浏览器发出取文件命令：GET /chn/yxsz/index.htm。</li><li>服务器给出响应，把文件 index.htm 发给浏览器。</li><li>TCP 连接释放。</li><li>浏览器显示“清华大学院系设置”文件 index.htm 中的所有文本。</li></ul></blockquote><hr><h3 id="HTTP报文的格式？"><a href="#HTTP报文的格式？" class="headerlink" title="HTTP报文的格式？"></a>HTTP报文的格式？</h3><p><strong>HTTP报文分为两类：请求报文和响应报文。它们都由三部分组成：开始行、首部行、实体主体。区别就是开始行不同。</strong></p><p><img src="https://i.loli.net/2019/07/29/5d3e5c39f101f64538.png" alt="5d3e5c39f101f64538"></p><ul><li><p><strong>首部行：</strong> 用来说明服务器、浏览器、或报文主体的一些信息。</p></li><li><p><strong>实体主体：</strong> 一般不用。</p></li><li><p><strong>开始行：</strong>对于请求报文来说，就是请求行。对于响应报文来说，就是状态行。</p><blockquote><p><strong>请求行：</strong> 包括三个内容：方法，URL以及HTTP的版本。后面有关于方法的详解。</p><p><strong>状态行：</strong> 包括三个内容：HTTP版本、状态码以及状态码的简单短语。后面有关于状态码的详解。</p></blockquote></li></ul><hr><h3 id="HTTP请求报文中的方法有哪些？"><a href="#HTTP请求报文中的方法有哪些？" class="headerlink" title="HTTP请求报文中的方法有哪些？"></a>HTTP请求报文中的方法有哪些？</h3><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626659330_5d3e537d38ae253055.png" alt="5d3e537d38ae253055"></p><hr><h3 id="get与post的区别。"><a href="#get与post的区别。" class="headerlink" title="get与post的区别。"></a>get与post的区别。</h3><p><a href="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp">原博文——get与post的区别-1</a></p><p><a href="https://www.zhihu.com/question/28586791">原博文——get与post的区别-2</a></p><table><thead><tr><th></th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。</td></tr><tr><td>对数据类型的限制</td><td>只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td>数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><blockquote><p>get方法一般用于请求获取信息，post方法一般用于向服务器提交一些修改信息。比如，我们输入一个网页地址，我们使用get方法获取页面的信息。如果我们要在某个网站上购买一件商品，我们使用post方法提交一个表单，服务器就记录下了你要购买的商品。基于这样的场景，可以得出：</p><ul><li>get方法请求的内容可以添加为标签并且能被缓存，post则不能添加为标签和被缓存（因为post请求的内容如果能添加为标签和被缓存的话，你下次点击这个标签就会直接购买商品了，很不安全）。</li><li>刷新的时候，get方法可以重新请求，无害，但是post的方法会重新提交表单（服务器这时候会告知用户），有隐患。</li></ul><p>此外，get的方法携带的数据一般放在url的后面，post方法携带的数据一般在http报文里面。因此，由于浏览器的限制，get携带的数据长度一般是有限制的，而post方法则无限制。</p></blockquote><hr><h3 id="HTTP1-0、HTTP1-1和HTTP2-0的区别？"><a href="#HTTP1-0、HTTP1-1和HTTP2-0的区别？" class="headerlink" title="HTTP1.0、HTTP1.1和HTTP2.0的区别？"></a>HTTP1.0、HTTP1.1和HTTP2.0的区别？</h3><p><a href="https://www.cnblogs.com/heluan/p/8620312.html">原博文——HTTP各版本之间的区别</a></p><p><strong>HTTP1.0与HTTP1.1区别：</strong></p><blockquote><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ul><li><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li><strong>长连接、持续连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li></ul></blockquote><p><strong>HTTP1.1与HTTP2.0的区别：</strong></p><blockquote><ul><li><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li><li><strong>header压缩</strong>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能</li></ul></blockquote><hr><h3 id="HTTP的状态码以及代表的意思？"><a href="#HTTP的状态码以及代表的意思？" class="headerlink" title="HTTP的状态码以及代表的意思？"></a>HTTP的状态码以及代表的意思？</h3><p><a href="https://blog.csdn.net/qq_35689573/article/details/82120851">原博文——常见的14种HTTP状态码</a></p><p><strong>1XX——表示通知信息，如请求收到了或正在进行处理</strong></p><p><strong>2XX——表明请求被正常处理了</strong></p><blockquote><ul><li>200 OK：请求已正常处理。</li><li>204 No Content：请求处理成功，但没有任何资源可以返回给客户端，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</li><li>206 Partial Content：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</li></ul></blockquote><p><strong>3XX——表明浏览器需要执行某些特殊的处理以正确处理请求</strong></p><blockquote><ul><li>301 Moved Permanently：资源的uri已更新，你也更新下你的书签引用吧。永久性重定向，请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。</li><li>302 Found：资源的URI已临时定位到其他位置了，姑且算你已经知道了这个情况了。临时性重定向。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。</li><li>303 See Other：资源的URI已更新，你是否能临时按新的URI访问。该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。当301,302,303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。</li><li>304 Not Modified：资源已找到，但未符合条件请求。该状态码表示客户端发送附带条件的请求时（采用GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304。</li><li>307 Temporary Redirect：临时重定向。与302有相同的含义。</li></ul></blockquote><p><strong>4XX——表明客户端是发生错误的原因所在。</strong></p><blockquote><ul><li>400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。</li><li>401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。</li><li>403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）</li><li>404 Not Found：服务器上没有请求的资源。路径错误等。</li></ul></blockquote><p><strong>5XX——服务器本身发生错误</strong></p><blockquote><ul><li>500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。</li><li>503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。</li></ul></blockquote><hr><h3 id="简述HTTPS以及实现过程。（为什么要使用HTTPS、HTTPS基本概念、加密方式、实现过程）"><a href="#简述HTTPS以及实现过程。（为什么要使用HTTPS、HTTPS基本概念、加密方式、实现过程）" class="headerlink" title="简述HTTPS以及实现过程。（为什么要使用HTTPS、HTTPS基本概念、加密方式、实现过程）"></a>简述HTTPS以及实现过程。（为什么要使用HTTPS、HTTPS基本概念、加密方式、实现过程）</h3><p><strong>为什么需要HTTPS（HTTP Secure 或者 HTTP over SSL）：</strong></p><blockquote><p>HTTP有很多<strong>安全漏洞</strong>：</p><ul><li>通信使用明文（不加密），内容可能会被窃听。</li><li>不验证通信方的身份，因此有可能遭遇伪装。</li><li>无法证明报文的完整性，所以有可能已遭篡改。</li></ul></blockquote><p><strong>也就是说：HTTP+加密+认证+完整性保护=HTTPS</strong></p><p><strong>HTTPS是身披SSL外壳的HTTP：</strong></p><blockquote><ul><li>HTTPS并非是应用层的一种新协议。只是通信接口部分用SSL和TLS协议代替而已。</li><li>通常情况下，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信。</li></ul></blockquote><p><strong>加密方式：对称加密与非对称加密</strong></p><blockquote><ul><li><p><strong>对称加密：</strong>加密和解密都是同一个密匙。</p><blockquote><p>对称加密速度快，适合Https加密算法，但是服务器和浏览器之间<strong>传递密钥的过程</strong>被人监听，相当明文传输。</p></blockquote></li><li><p><strong>非对称加密：</strong>密钥成对出现，分为公钥和私钥，公钥加密需要私钥解密，私钥加密需要公钥解密。</p><blockquote><p>服务端只将公钥暴露，浏览器使用公钥对消息进行非对称加密，服务端用私钥解密。但是服务端向浏览器回复的时候，只能用私钥进行加密，浏览器只能用公钥解密。但是：公钥是所有人都知道的，所有人都可以读取服务端回复的消息来进行解密，所以<strong>解决不了服务端向浏览器传递消息</strong>。</p></blockquote></li></ul><p><strong>HTTPS加密方式：混合加密方式，对称加密与非对称加密结合使用。</strong></p><blockquote><ul><li>使用非对称加密方式安全地交换在稍后的共享密钥加密中要使用的密钥。</li><li>确保交换的密钥是安全的前提下，使用共享密钥加密方式进行通信。</li></ul></blockquote></blockquote><p><strong>HTTPS工作流程：</strong></p><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626669165_5d3e9cdc64fcb16806.png" alt="5d3e9cdc64fcb16806"></p><blockquote><p>步骤 <strong>1</strong>： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p><p>步骤 <strong>2</strong>： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p><p>步骤 <strong>3</strong>： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p><p>步骤 <strong>4</strong>： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</p><p>步骤 <strong>5</strong>： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p><p>步骤 <strong>6</strong>： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</p><p>步骤 <strong>7</strong>： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p><p>步骤 <strong>8</strong>： 服务器同样发送 Change Cipher Spec 报文。</p><p>步骤 <strong>9</strong>： 服务器同样发送 Finished 报文。</p><p>步骤 <strong>10</strong>： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接</p><p>就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p><p>步骤 <strong>11</strong>： 应用层协议通信，即发送 HTTP 响应。</p><p>步骤 <strong>12</strong>： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。</p></blockquote><hr><h3 id="简述HTTPS与HTTP的区别？"><a href="#简述HTTPS与HTTP的区别？" class="headerlink" title="简述HTTPS与HTTP的区别？"></a>简述HTTPS与HTTP的区别？</h3><p><a href="https://www.cnblogs.com/wqhwe/p/5407468.html">原博文——HTTPS与HTTP的区别</a></p><p><strong>HTTP：</strong>是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p><strong>HTTPS：</strong>是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li></ul><hr><h3 id="IP数据报格式？"><a href="#IP数据报格式？" class="headerlink" title="IP数据报格式？"></a>IP数据报格式？</h3><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626659313_5d4234f6c54cb34330.png" alt="5d4234f6c54cb34330"></p><p>IP数据报首部可以分为固定长度（20字节）和可选长度。固定长度是所有IP数据报所必须的。<strong>固定部分个字段的意义如下：</strong></p><blockquote><ul><li><p><strong>版本：</strong> 占4位，指IP协议的版本，通信双方的协议版本必须一致。</p></li><li><p><strong>首部长度：</strong> 占4位，可表示的最大十进制数是15（1111）。它的单位是4字节（也就是32位），因此首部长度最小值为5（固定长度部分），可选长度最长为40字节。</p></li><li><p><strong>区分服务：</strong> 占8位，用来获得更好的服务。</p></li><li><p><strong>总长度：</strong> 占16位，首部和数据部分的总长度，单位为字节。因此IP数据报的最大长度为2^16-1。</p></li><li><p><strong>标识：</strong> 占16位。当数据报的长度超过网络的最大传送单元使，就给该数据报的所有分片赋值相同的标识，相同的标识字段的值使分片后的各数据报片能正确的重装成原来的数据报。</p></li><li><p><strong>标志：</strong> 占3位，但是只有两位具有意义。</p><blockquote><ul><li>标记字段中的最低位记为MF。MF=1表示后面还有分片，MF=0表示这是最后一个分片。</li><li>标志字段中间的一位记为DF，意思是能否分片，只有DF=0时才能分片。</li></ul></blockquote></li><li><p><strong>片偏移：</strong> 占13位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，数据片相对于初始位置的距离。单位是8字节。因此，除去最后一个数据片，每个数据片的长度都是8字节的倍数。</p></li><li><p><strong>生存时间：</strong> 占8位，TTL（Time To Live），单位为跳数，跳数表明该数据报至多能在互联网中经过多少个路由器，每经过一个路由器就减1。</p></li><li><p><strong>协议：</strong> 占8位，协议字段指出该数据报携带的数据是使用哪种协议，以便使目的主机的IP层知道应将数据部分上交给哪个协议进行处理。</p><blockquote><table><thead><tr><th>协议名</th><th>ICMP</th><th>IGMP</th><th>IP</th><th>TCP</th><th>EGP</th><th>IGP</th><th>UDP</th><th>IPv6</th><th>ESP</th><th>OSPF</th></tr></thead><tbody><tr><td>协议字段值</td><td>1</td><td>2</td><td>4</td><td>6</td><td>8</td><td>9</td><td>17</td><td>41</td><td>50</td><td>89</td></tr></tbody></table></blockquote></li><li><p><strong>首部校验和：</strong> 占16位，这个字段只检验数据报的首部，但是不包括数据部分。</p><blockquote><p><img src="https://i.loli.net/2019/08/01/5d423d384cdf496110.png" alt="5d423d384cdf496110"></p><ul><li>在发送方，先把数据报划分为许多16位的字的序列，并把校验和字段置为0，。</li><li>用反码算术运算（从低位到高位计算，0+0等于0,0+1等于1,1+1等于0，但是要进1。）把所有的16位字相加后，将得到的反码写入校验和字段。</li><li>接收方接收到数据报之后，将首部的所有16位字再使用反码运算相加一次，将得到的和取反码，即得出接收方的检验和的计算结果。如果结果全为0，则代表首部未发生变化，保留该数据报，反之则丢弃。</li></ul><p>参考：<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">原码、补码、反码详解</a></p></blockquote></li><li><p><strong>源地址：</strong> 占32位。</p></li><li><p><strong>目的地址：</strong> 占32位。</p></li></ul></blockquote><hr><h3 id="UDP数据报格式？"><a href="#UDP数据报格式？" class="headerlink" title="UDP数据报格式？"></a>UDP数据报格式？</h3><p><a href="https://www.cnblogs.com/anzhengyu/p/11232699.html">原博文——UDP数据报格式</a></p><p>UDP用户数据报分为 = 首部字段 （8个字节，4个字段，每个字段2个字节）+ 数字字段。</p><p>首部字段：</p><ul><li>源端口： 源端口号。在需要对方回信的时候选用，不需要填0。</li><li>目的端口： 目的端口号。必填。</li><li>长度： UDP用户数据报的长度。最小为8。</li><li>检验和：检测UDP用户数据报传输过程中是否有错。有错就丢弃。</li></ul><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626659129_5d3524ef4841844167.png" alt="5d3524ef4841844167"></p><p><strong>补充：UDP检验首部校验和的方法：</strong></p><blockquote><p>在计算检验和时，需要在用户数据报之前加12字节的伪首部。</p><p>所谓伪首部，是指他并不是UDP用户数据报的真正首部，只是在计算检验和的时候，临时加上的，检验和就是按照这个临时的用户数据报计算的。既不下传也不向上提交。伪首部的格式如上图。</p><p>UDP计算检验和与IP数据报类似，只是UDP的首部校验和把首部和数据一起都检验了。步骤如下：</p><ul><li>在发送方，首先先把全零放到检验和字段；</li><li>再把伪首部和UDP用户数据报看成是由许多16位的字串连接起来的；</li><li>然后按二进制反码计算出这些16位字的和，并将此和的反码写入检验和字段后，就发送这样的用户数据报。</li><li>在接收方，把收到的UDP用户数据报连同伪首部（以及可能的填充全零字节）一起，按二进制反码求这些16位字的和。</li><li>若无差错时其结果应全为1；否则就是有差错出现，可以选择丢失，可以上传（但是要附上错误信息）。</li></ul><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626662009_5d354dcc35e6338961.png" alt="5d354dcc35e6338961"></p></blockquote><hr><h3 id="TCP报文段格式？"><a href="#TCP报文段格式？" class="headerlink" title="TCP报文段格式？"></a>TCP报文段格式？</h3><p><a href="https://www.cnblogs.com/anzhengyu/p/11232770.html">原博文——TCP报文首部格式</a></p><p>TCP虽然是面向字节流的，但是TCP传输的数据单元却是报文段。一个报文段可以分为首部和数据两部分。</p><p>TCP报文段的首部的前20个字节是固定的，后面的4n字节是需要增加的选项。因此TCP首部的最小长度是20字节。</p><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626659105_5d356311a685317386.png" alt="5d356311a685317386"><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626659105_5d356311a685317386.png" alt="5d356311a685317386"></p><p>首部部分字段的意义如下：</p><blockquote><ul><li><p>源端口和目的端口：各占2个字节，分别写入源端口号和目的端口号。TCP的分用功能也是通过端口号实现的。</p></li><li><p>序号：占4字节。在TCP连接中传送的字节流中的每一个字节都按照顺序编号。首部中的序号字段值则代表本报文段所发送的数据的第一个字节的序号。</p></li><li><p>确认号：占4字节。代表期望收到对方下一个报文段的第一个数据字节的序号。需要注意：<code>若确认号=N，则表明：到序号N-1为止的所有数据都已正确收到</code></p></li><li><p>数据偏移：占4位。他指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。一般情况下为20字节，但是首部中还有不确定的选项字段。它的单位是4字节，而它的最大值是15，因此数据偏移最大值为60字节，也就是说选项不能超过40字节。</p></li><li><p>保留：占6位。以防后续使用。</p><p><strong>下面是6个控制位，每个占一位：</strong></p></li><li><p>紧急URG：当URG=1时，表明紧急字段有效，它告诉系统此报文中有紧急数据，应该尽快传送。</p></li><li><p>确认ACK：仅当ACK=1时确认号字段才有效。</p></li><li><p>推送PSH：当两个应用进程进行交互式的通信时，有时一端的应用进程希望在键入一个命令后立即就能收到对方的相应，这时设置PSH=1。</p></li><li><p>复位RST：当RST=1时，表明TCP连接中出现严重错误，必须释放连接，再重新建立运输连接。RST=1还可以用来拒绝一个非法的报文段或拒绝打开一个连接。</p></li><li><p>同步SYN：在建立连接时用来同步序号。当SYN=1，ACK=0时代表是连接请求报文段。若对方同意建立连接，则应在相应报文段中使SYN=1，ACK=1。也就是说，SYN=1代表连接请求或者连接接受报文。</p></li><li><p>终止FIN。用于释放一个连接。当FIN=1时，代表此报文段的发送方的数据已发送完毕，并且请求释放运输连接。</p><p><strong>控制位到这结束。</strong></p></li><li><p>窗口：占2字节。窗口值告诉对方：从本报文段中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以设置这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其窗口大小的依据。</p></li><li><p>检验和：占2字节。检验的范围包括首部字段和数据字段。和UDP检验的方法一样，只不过把伪首部第四个字段的17改成6.</p></li><li><p>紧急指针：占2字节。只有在紧急URG=1时才有效，它指出本报文段中的紧急数据的字节数。</p></li><li><p>选项：长度可变，最大40字节</p><blockquote><p>TCP最初只规定了一种选项，即最大报文长度MSS。MSS是每一个TCP报文段中的数据字段的最大长度，而并不是整个TCP报文段的长度。</p></blockquote></li></ul></blockquote><hr><h3 id="以太网MAC帧格式？"><a href="#以太网MAC帧格式？" class="headerlink" title="以太网MAC帧格式？"></a>以太网MAC帧格式？</h3><p><img src="https://uploadfiles.nowcoder.com/files/20190801/464249456_1564626664984_5d424c85e043a98902.png" alt="5d424c85e043a98902"></p><p>以太网MAC帧较为简单，由五个字段组成，前两个字段分别为6字节长的<strong>目的地址</strong>和<strong>源地址</strong>。第三个字段是2字节的<strong>类型字段</strong>，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。第四个字段是<strong>数据字段</strong>，其长度为46~1500字节（46字节是因为最小长度64字节减去18字节的首部和尾部）。最后一个字段是4字节的<strong>帧检测</strong>序列FCS（使用CRC检测）。</p><p>如果对你有帮助，就推荐+收藏吧！😜😜</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识点整理（一）</title>
      <link href="/2020/12/21/ji-suan-ji-wang-luo-zhi-shi-dian-zheng-li-yi/"/>
      <url>/2020/12/21/ji-suan-ji-wang-luo-zhi-shi-dian-zheng-li-yi/</url>
      
        <content type="html"><![CDATA[<p><b><span style="color:#FF4500;">写在最前面：本文章所有内容是本人从网络整理而得，并非商用，仅供学习交流使用。</span></b></p><p><b><span style="color:#FF4500">另一部分参见：</span></b><a href="https://zningj.github.io/2020/12/22/ji-suan-ji-wang-luo-zhi-shi-dian-zheng-li-er/">计算机网络知识点整理（二） | 不吃香菜的博客</a></p><p><img src="/2020/12/21/ji-suan-ji-wang-luo-zhi-shi-dian-zheng-li-yi/1.jpg" alt="计算机网络体系结构"></p><ul><li><p><strong>OSI七层协议体系：</strong> 概念清楚，理论也比较完整，但是它既复杂也不实用。</p></li><li><ul><li><p>物理层：</p><blockquote><ul><li>计算机网络体系中最底层，为所有网络/数据数据通信提供物理的通信线路。另外通信线路可以通过信道复用方式在一条物理线路中划分多条信道。默认情况下，一条物理线路就是一条信道。</li><li><strong>常用协议：</strong> ISO2110，IEEE802，IEEE802.2</li><li><strong>常用硬件：</strong> 中继器、集线器、还有我们通常说的双绞线也工作在物理层</li></ul></blockquote></li><li><p>数据链路层：</p><blockquote><ul><li>为同一局域网内部的网络/数据通信提供点到点的数据传输通道，通过MAC地址寻址把数据传输到目的节点。</li><li>数据链路层的通信只能在同一网段进行，要在不同网段间进行，必须依靠网络层和传输层。</li><li>数据链路层提供的不是物理线路，而是在物理层的物理线路基础之上，通过数据链路层协议构建的虚拟数据传输通道，并且只能在同一段内进行数据转发。</li><li><strong>常用协议：</strong>SLIP，CSLIP，PPP，ARP，RARP，MTU。<strong>（在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层。）</strong></li><li><strong>常用硬件：</strong>网桥、以太网交换机、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层）</li></ul></blockquote></li><li><p>网络层：</p><blockquote><ul><li>为不同网段之间的数据转发提供路径选择，通过IP地址（也有可能是其他网络地址）把数据包转发到目的节点。网络层这种寻址功能我们称为“路由寻址”，就是选择哪一条路径到达下一个节点。</li><li>网络层的功能仅起到不同网络间转发数据包的功能，最终数据还是要在目的网络的数据链路层进行传输，在到达下一个节点设备（如路由器）再进行转发。</li><li><strong>常用协议：</strong>IP，ICMP，RIP，OSPF，BGP，IGMP</li><li><strong>常用硬件：</strong>路由器</li></ul></blockquote></li><li><p>运输层：</p><blockquote><ul><li>是在下面三层构建的网络平台基础上专门为通信双方构建端到端（不是点到点）的数据传输通道，使通信双方就像在直接进行数据传输一样。这个端到端的传输通道是可以跨网络的。</li><li><strong>常用协议：</strong> TCP，UDP</li><li><strong>常用硬件：</strong>网关</li></ul></blockquote></li><li><p>会话层：</p><blockquote><ul><li>为具体的用户建立会话进程。</li><li><strong>常用协议：</strong> 无</li><li><strong>常用硬件：</strong>网关</li></ul></blockquote></li><li><p>表示层：</p><blockquote><ul><li>是对用户网络应用数据的具体解释，包括在网络通信中可采用的信息技术、可采用的加密方式等。</li><li><strong>常用协议：</strong> 无</li><li><strong>常用硬件：</strong>网关</li></ul></blockquote></li><li><p>应用层：</p><blockquote><ul><li>用户进行具体网络应用的层次，是具体网络应用的体现者，负责接受用户的各种网络应用进程的调用。</li><li><strong>常用协议：</strong> TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</li><li><strong>常用硬件：</strong>网关</li></ul></blockquote></li></ul></li><li><p><strong>TCP/IP四层协议体系：</strong> 实际应用非常广泛，从实质上讲，TCP/IP体系只有最上面的三层，最底下的网络接口层实际上没有什么内容。</p></li><li><ul><li>网络接口层：合并了原来OSI中的物理层和数据链路层，提供局域网的功能。</li><li>网际层：同OSI网络层</li><li>运输层：同OSI运输层</li><li>应用层：合并了OSI中最上面的三层。</li></ul></li><li><p><strong>五层协议体系：</strong> 《计算机网络第七版》中，为了方便介绍网络原理，而引人的体系。实际应用还是TCP/IP协议体系。</p></li><li><ul><li>物理层：同OSI物理层</li><li>数据链路层：同OSI数据链路层</li><li>网络层：同OSI网络层</li><li>运输层：同OSI运输层</li><li>应用层：合并了OSI中最上面的三层。</li></ul></li></ul><hr><h3 id="OSI体系与TCP-IP体系的联系与区别？"><a href="#OSI体系与TCP-IP体系的联系与区别？" class="headerlink" title="OSI体系与TCP/IP体系的联系与区别？"></a>OSI体系与TCP/IP体系的联系与区别？</h3><ul><li><p>相同点：</p><blockquote><ul><li>层次结构划分思想相同；</li><li>总体层次结构相同；</li><li>核心组成一样，都定义了“服务“、”接口“、”协议“上重要核心。</li></ul></blockquote></li><li><p>不同点：</p><blockquote><ul><li>适用范围不同：OSI在标准协议发明前就产生了，不偏重于任何特定的网络类型，具有最广泛的理论参考性，是一个理想代的模型；而TCP/IP则相反，它是针对TCP/IP协议簇产生的，最具实践性；</li><li>层次结构不同：TCP/IP体系中没有会话层和表示层；</li><li>支持通信模式不同：OSI同时支持无连接和面向连接的网络通信（不仅支持TCP/IP协议网络中无连接的IP网络协议，同时支持NetWare SPX/IPX网络中的面向连接的SPX协议等）。TCP/IP模型的网络层只提供无连接的服务。</li><li>所包括的通信协议不同。</li></ul></blockquote></li></ul><hr><h3 id="路由器、中继器、集线器、交换机、网关、网桥各自的概念以及作用？"><a href="#路由器、中继器、集线器、交换机、网关、网桥各自的概念以及作用？" class="headerlink" title="路由器、中继器、集线器、交换机、网关、网桥各自的概念以及作用？"></a>路由器、中继器、集线器、交换机、网关、网桥各自的概念以及作用？</h3><ul><li><p>路由器（Router）：</p><blockquote><ul><li>工作范围：网络层，不同网络之间</li><li>功能：是一种计算机网络设备，提供了<strong>路由与转送</strong>两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。</li></ul></blockquote></li><li><p>中继器：</p><blockquote><ul><li>工作范围：物理层</li><li>功能：中继器是将一条电缆传输过来的信号经过放大和调整以后再传输给另一个电缆。因此，它是物理层上的网络延长设备。一般而言，中继器连接的双方是相同的物理介质，但是有些也可以完成不同媒介之间的连接。但是中继器只是完成了信号的转换，而不能完成转发。也就是说，中继器不能再传输速度不同的介质之间完成转发。</li></ul></blockquote></li><li><p>集线器：</p><blockquote><ul><li>工作范围：物理层</li><li>功能：如果每个设备只有一个对外接口，那么意味着只能建立一对一的点到点的通信。为了能够让通信“一对多”，需要将信号复制广播，于是，产生了集线器。集线器的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。</li></ul></blockquote></li><li><p>交换机：</p><blockquote><ul><li>工作范围：数据链路层</li><li>功能：交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。也就是说，交换机也有一张表，记录的是port-mac。按照传输数据包的层次，交换机可以分为一、二…..七层交换机。</li></ul></blockquote></li><li><p>网桥：</p><blockquote><ul><li>工作范围：数据链路层</li><li>功能：网桥能够连接两个不同的数据链路，即使他们的传输速度不同。它能够识别数据链路中的数据帧，并将这些数据帧临时存储在内存中，然后在重新生成一个新的数据帧转发给另外一个网段。网桥还具有检错功能。因此，网桥有时候也会被称为2层交换机。（数据链路层设备）有些网桥能够记住曾今通过自己转发的数据帧的MAC地址，并保存在内部的内存表中。这种网桥被称为自学式网桥。</li></ul></blockquote></li><li><p>网卡：</p><blockquote><ul><li><p>工作范围：物理层、数据链路层</p></li><li><p>功能：又称<strong>网络接口控制器</strong>，<strong>网络适配器</strong>（network adapter），<strong>网卡</strong>（network interface card），或<strong>局域网接收器</strong>（LAN adapter），是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件。网卡的作用是负责接收网络上的数据包，通过和自己本身的物理地址相比较决定是否为本机应接信息，解包后将数据通过主板上的总线传输给本地计算机，另一方面将本地计算机上的数据打包后送出网络。</p><blockquote><ul><li>实现与主机总线的网络通讯连接，网卡相当于桥梁设备</li><li>实现主机与介质之间的电信号匹配</li><li>提供数据缓冲能力</li></ul></blockquote></li></ul></blockquote></li><li><p>网关：</p><blockquote><ul><li>工作范围：运输层、应用层</li><li>功能：网关（Gateway）负责第三层（网络层）以上的数据中继，实现不同体系结构的网络协议转换，它通常采用软件的方法实现，并且与特定的应用服务一一对应。比如：OSI的文件传输服务FTAM和TCP/IP的文件传输服务FTP，尽管二者都是文件传输但是由于所执行的协议不同不能直接进行通信，而需要网关将两个文件传输系统互连，达到相互进行文件传输的目的。</li></ul></blockquote></li></ul><hr><h3 id="交换机与路由器的区别？"><a href="#交换机与路由器的区别？" class="headerlink" title="交换机与路由器的区别？"></a>交换机与路由器的区别？</h3><ul><li><p>工作层次不同</p><blockquote><p>交换机是工作在OSI/RM体系结构的第二层（数据链路层），而路由器一开始就设计工作在OSI模型的网络层。由于交换机工作在OSI的第二层（数据链路层），所以它的工作原理比较简单，而路由器工作在OSI的第三层（网络层），可以得到更多的协议信息，路由器可以做出更加智能的转发决策。</p></blockquote></li><li><p>数据转发所依据的对象不同</p><blockquote><p>交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用不同网络的ID号（即IP地址）来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络，有时这些第三层的地址也称为协议地址或者网络地址。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。</p></blockquote></li><li><p>传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域</p><blockquote><p>由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。</p></blockquote></li><li><p>路由器提供了防火墙的服务</p><blockquote><p>路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。 交换机一般用于LAN-WAN的连接，交换机归于网桥，是数据链路层的设备，有些交换机也可实现第三层的交换。路由器用于WAN-WAN之间的连接，可以解决异性网络之间转发分组，作用于网络层。他们只是从一条线路上接受输入分组，然后向另一条线路转发。这两条线路可能分属于不同的网络，并采用不同协议。相比较而言，路由器的功能较交换机要强大，但速度相对也慢，价格昂贵，第三层交换机既有交换机线速转发报文能力，又有路由器良好的控制功能，因此得以广泛应用。</p></blockquote></li></ul><hr><h3 id="IP地址是如何分类的？"><a href="#IP地址是如何分类的？" class="headerlink" title="IP地址是如何分类的？"></a>IP地址是如何分类的？</h3><p><strong>IP地址 = 网络号 + 主机号</strong></p><blockquote><ul><li>A、B、C类IP地址的网络号字段分别是1、2、3个字节长，而在网络号的1-3位是类别位，分别是：0、10、110。</li><li>A、B、C类IP地址的主机号字段分别为3、2、1个字节。</li><li>A、B、C类IP地址是单播地址，D类IP地址（前四位为1110）为多播地址，E类IP地址（前四位1111）保留为以后使用。</li></ul></blockquote><hr><h3 id="A、B、C三类常用的IP地址的指派范围？有哪些特殊的IP地址以及它们的含义？"><a href="#A、B、C三类常用的IP地址的指派范围？有哪些特殊的IP地址以及它们的含义？" class="headerlink" title="A、B、C三类常用的IP地址的指派范围？有哪些特殊的IP地址以及它们的含义？"></a>A、B、C三类常用的IP地址的指派范围？有哪些特殊的IP地址以及它们的含义？</h3><p><img src="https://i.loli.net/2019/07/25/5d3903a142c0641505.jpg" alt="5d3903a142c0641505"></p><p><strong>特殊的IP地址</strong>：</p><blockquote><ul><li>网络号全0代表“this，这个”，也就是本网络的意思，当网络号和主机号全为0时则代表本网络上的本主机。网络号为0，主机号为host-id，则代表本网络上的某个主机（主机号为host-id）。这类IP地址只能作为源地址，不能作为目的地址。</li><li>网络号和主机号全为1，代表只在本网络上进行广播，路由器不转发，不可以作为源地址，可以作为目的地址。</li><li>网络号为net-id，主机号为全1，代表对net-id上所有的主机进行广播。可以作为目的地址，不可以作为源地址。</li><li>网络号为127（01111111），保留作为本地环回测试本主机的进程之间的通信只用。主机号可以为非全0或者全1的任何数，可以作为源地址，也可以作为目的地址。</li></ul></blockquote><p><strong>可以指派的IP地址：</strong></p><blockquote><ul><li>A类地址的网络号中：全0和127是不指派的；主机号中：全0代表本主机所连接的单个网络地址，全1代表网络上的所有主机，也是不指派的。</li><li>B类IP地址网络号中：<strong>128.0.0.0不指派</strong>；主机号中：全0和全1也不指派。</li><li>C类IP地址网络号中：<strong>192.0.0.0不指派</strong>；主机号中：全0和全1也不指派。</li></ul></blockquote><p><strong>总结：</strong></p><blockquote><ul><li>网络号全为0：本网络</li><li>主机号全为0：代表单个网络地址</li><li>主机号全为1：代表某个网络上的所有主机</li></ul></blockquote><hr><h3 id="简述ARP协议的工作原理。"><a href="#简述ARP协议的工作原理。" class="headerlink" title="简述ARP协议的工作原理。"></a>简述ARP协议的工作原理。</h3><blockquote><ul><li><p><strong>ARP：</strong>Address Resolution Protocol，地址解析协议</p></li><li><p><strong>功能：</strong>为了从网络层的IP地址，解析出在数据链路层使用的硬件地址。注意：ARP解决的是同一局域网上的主机和路由器的IP地址和硬件地址的映射问题。</p></li><li><p><strong>工作原理：</strong></p><p>每一台主机都设有一个ARP告诉缓存，里面有本局域网上的各个主机和路由器的IP地址到硬件地址的映射。当A要向本局域网上的B发送IP数据报时，则A先查看ARP高速缓存中有无B的IP地址：</p><ul><li>如果有：就在ARP高速缓存中查出该IP地址的硬件地址，把这个硬件地址写入MAC帧，再通过局域网将MAC帧发往此硬件地址。</li><li>如果没有：ARP向本局域网广播（请求分组是广播，响应分组是单播）发送一个ARP请求分组，表明自己的IP地址和硬件地址以及要寻找的IP地址。B接收到请求分组后，收下并且向A发送相应分组，其余主机不做相应。A收到B的相应分组后再进行常规的数据传输。</li></ul></li></ul></blockquote><p><strong>补充：</strong></p><blockquote><p><strong>生存时间：</strong>ARP对每一个映射地址的项目都设有生存时间（例如10-20分钟），这是为了防止该局域网中某些主机的硬件地址发生改变的情况。</p></blockquote><hr><h3 id="简述ICMP协议和IGMP协议。"><a href="#简述ICMP协议和IGMP协议。" class="headerlink" title="简述ICMP协议和IGMP协议。"></a>简述ICMP协议和IGMP协议。</h3><p><strong>ICMP：</strong></p><blockquote><ul><li>Internet Control Message Protocol，网际控制报文协议。</li><li><strong>功能：</strong> 为了更加有效的转发IP数据报和提高交付成功的机会，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。</li></ul></blockquote><p><strong>IGMP：</strong></p><blockquote><ul><li>Internet Group Management Protocol，网际组管理协议。</li><li><strong>功能：</strong> IGMP协议是让连接在本局域网上的多播路由器知道本局域网上是否有主机（严格来讲是主机上的某个进程）参加或者退出了某个多播组。</li></ul></blockquote><hr><h3 id="TCP和UDP的区别。"><a href="#TCP和UDP的区别。" class="headerlink" title="TCP和UDP的区别。"></a><strong>TCP和UDP的区别。</strong></h3><p>TCP：传输控制协议，Transmission Control Protocol</p><p>UDP：用户数据报协议，User Datagram Protocol</p><ul><li><p><strong>TCP是面向连接的，UDP是无连接的。</strong></p><blockquote><p>TCP在传输数据之前必须建立有效的连接，数据传输后也要释放连接。而UDP在传输前不需要建立连接，远程主机接收到UDP用户数据报之后也不需要给出确认。</p></blockquote></li><li><p><strong>TCP提供可靠的全双工通信，UDP尽最大努力通信，不保证可靠。</strong></p></li><li><p><strong>TCP占用资源多，UDP占用资源少。</strong></p></li><li><p><strong>运输协议数据单元不同，TCP是TCP报文段，UDP是用户数据报。</strong></p></li><li><p><strong>TCP是面向字节流的，UDP是面向报文的。</strong></p><blockquote><ul><li><strong>面向字节流</strong>：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但是TCP把应用程序交下来的数据只看出一连串的无结构字节流。TCP不知道字节流的具体含义，也不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块之间的大小关系。但是接收方应用程序收到的字节流必须与发送方发送的字节流完全一致。</li><li><strong>面向报文</strong>：发送方的UDP对应用程序交下来的报文添加首部后直接交付给IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</li></ul></blockquote></li><li><p><strong>TCP有拥塞控制，UDP没有拥塞控制</strong></p></li><li><p><strong>TCP不提供广播和多播服务，UDP支持一对一、多对一、一对多、多对多的交互通信。</strong></p></li></ul><hr><h3 id="TCP如何保证可靠传输？"><a href="#TCP如何保证可靠传输？" class="headerlink" title="TCP如何保证可靠传输？"></a>TCP如何保证可靠传输？</h3><p><a href="https://blog.csdn.net/liuchenxia8/article/details/80428157">原博文——TCP如何保证可靠传输</a></p><ul><li><p><strong>校验和：</strong> TCP在发送报文之前，发送方要计算校验和，收到数据后，接收方也要计算校验和，如果校验和不相等则丢弃。</p></li><li><p><strong>序列号与确认应答：</strong></p><blockquote><ul><li><strong>序列号：</strong>TCP传输时将每个字节的数据都进行了编号，这就是序列号。</li><li><strong>确认应答：</strong>TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</li><li><strong>序列号的作用</strong>不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。</li></ul></blockquote></li><li><p><strong>超时重传:</strong> 在TCP传输过程中，我们在发送一部分数据后，都会等待对方的ACK确认报文，如果中间出现差错，没有收到ACK报文，这时候需要启动超时重传机制。这种超时重传机制保证了TCP在网络延迟或者报文丢失下的可靠传输。</p><blockquote><p>超时的原因：</p><ul><li>接收方没有收到TCP报文段：网络延迟或者丢包；</li><li>发送方没有收到ACK报文段：网络延迟或者ACK报文丢失。</li></ul></blockquote></li><li><p><strong>连接管理：</strong>连接管理就是三次握手与四次挥手的过程（后面有详细解释）</p></li><li><p><strong>流量控制：</strong> 流量控制的目的是让接收方来得及接收数据。这样避免了数据丢包以及网络拥塞等情况。</p></li><li><p><strong>拥塞控制：</strong> 拥塞控制就是防止过多的数据注入到网络中，这样使网络中的路由器或者链路不至于过载。</p></li></ul><hr><h3 id="TCP三次握手的过程？为什么采用三次握手？两次可以吗？"><a href="#TCP三次握手的过程？为什么采用三次握手？两次可以吗？" class="headerlink" title="TCP三次握手的过程？为什么采用三次握手？两次可以吗？"></a>TCP三次握手的过程？为什么采用三次握手？两次可以吗？</h3><p><a href="https://www.cnblogs.com/anzhengyu/p/11232813.html">原博文——TCP运输连接管理</a></p><p><img src="https://i.loli.net/2019/07/25/5d3963c32a30b71624.png" alt="5d3963c32a30b71624"></p><p><strong>TCP三次握手的过程（A向B发送数据）：</strong></p><blockquote><ul><li>A主动打开连接，B被动打开连接。B先进入收听状态，A打算建立TCP连接时，先向B发送连接请求报文段，其中<strong>同步位SYN=1，初始序号seq=x</strong>，这个报文段不能携带数据，但是要消耗一个序号。接着，A进入同步已发送状态；</li><li>B收到请求报文段，如果同意建立连接，则向A发送ACK确认报文段，其中<strong>同步位SYN=1，确认号ACK=1，初始序号seq=y，确认号ack=x+1（请求报文段消耗了一个序号）</strong>，这个ACK报文段也不能携带数据，但是要消耗一个序号。与此同时，B进入到同步收到的状态；</li><li>A收到B的确认报文后，还要给B发送确认报文。其中<strong>ACK=1，seq=x+1（上一个报文段的ack），ack = y+1（上一个报文段的seq+1，因为消耗了一个序号）</strong>，这个ACK报文段可以携带数据，但是如果不携带数据则不会消耗序号，下一次A给B发送报文段的初始序号 <strong>seq=1</strong>。此时A进入已建立连接的状态，B收到确认后也进入已建立连接的状态。</li></ul></blockquote><p><strong>为什么需要最后一次确认？</strong></p><blockquote><p>这是防止已失效的连接请求报文段突然又传送到了B而引发错误。</p><p><strong>失效的连接请求：</strong>A第一次先发送了一个请求，但是丢失了，于是A再发送一个连接请求，重新建立连接，发送数据并释放连接。</p><p>但是有可能出现异常情况，即A发送的连接请求并没有丢失，而是滞留了在网络中。如果在传输数据完成之后，这个请求又发到B，B误以为A还要发送数据，因此发送确认报文，但是A没有运输需求，因此不予理睬。如果没有最后一次确认，B一直等待A的确认，这样会造成的浪费。</p><p>采用三报文握手，如果B没有收到A的确认，则可以知道A没有建立连接的需求，就可以避免上述这种情况。</p></blockquote><hr><h3 id="TCP四次挥手的过程？为什么最后有timewait？等待时长一般是多少？"><a href="#TCP四次挥手的过程？为什么最后有timewait？等待时长一般是多少？" class="headerlink" title="TCP四次挥手的过程？为什么最后有timewait？等待时长一般是多少？"></a>TCP四次挥手的过程？为什么最后有timewait？等待时长一般是多少？</h3><p><a href="https://www.cnblogs.com/anzhengyu/p/11232813.html">原博文——TCP运输连接管理</a></p><p><img src="https://i.loli.net/2019/07/25/5d3968b13408d81781.png" alt="5d3968b13408d81781"></p><p><strong>TCP四次挥手的过程：</strong></p><blockquote><ul><li>A和B目前都处于已建立连接的状态，A的应用进程向其TCP发出连接释放报文段，并停止发送数据，主动关闭TCP连接。此时，<strong>FIN=1，seq=u，u等于前面已发送的最后一个字节的序号加1</strong>。这时A进入到FIN-WAIT-1（终止等待1）状态，等待B的确认。FIN报文段即使不携带数据，也要消耗一个序号；</li><li>B收到释放连接后立即发出确认，此时，<strong>ACK=1，确认号是ack=u+1（前面的seq+1，因为消耗了一个序号），序号seq=v，v等于B前面所有已传送数据的最后一个字节的序号加1</strong>。B进入到CLOSE-WAIT（关闭等待）状态，TCP服务器进程向<strong>B的高层应用进程</strong>告知，此时<strong>A到B的连接已经释放</strong>，TCP连接处于半关闭状态。但是，<strong>B到A这个方向的连接尚未关闭；</strong></li><li>A收到B的确认后，就进入到FIN-WAIT2（终止等待2）的状态，等待B发送连接释放报文段；</li><li>若B已经没有数据需要发送，则应用进程通知TCP释放连接，这时B发送的报文段：<strong>FIN=1，ACK=1，seq=w（可能后面又发送了一些数据），ack=u+1，</strong>并且这个报文消耗一个序号。B进入到LAST-ACK（最后确认）的状态，等待A的确认；</li><li>A收到B的确认后，必须对此发送确认报文。该报文中<strong>：ACK=1，seq=u+1，ack=w+1</strong>。然后进入到TIME-WAIT（时间等待）状态。</li><li>此时TCP连接并没有完全释放，必须经过时间等待计时器设置的时间<strong>2MSL</strong>之后，A才进入CLOSED状态。<strong>时间MSL叫做最大报文段寿命</strong>。</li></ul></blockquote><p><strong>那么，为什么要等待2MSL的时间呢？</strong></p><blockquote><ul><li>保证A最后发送的ACK报文段能够到达B。因为这个报文可能丢失，因此B会重传最后一个确认报文段，A再重新发送确认报文，并且重启计时器，直到A，B都能正常进入到CLOSED状态；</li><li>防止上面提到的“已失效的连接请求报文”。这段时间内，这些连接请求报文就可能在网络中消失。</li></ul></blockquote><p>此外，B要比A先进入CLOSED状态</p><hr><h3 id="TCP怎么计算网络延迟？"><a href="#TCP怎么计算网络延迟？" class="headerlink" title="TCP怎么计算网络延迟？"></a>TCP怎么计算网络延迟？</h3><p><a href="https://www.zhihu.com/question/266846392">知乎——计算网络时延的原理是什么？</a></p><p><img src="https://i.loli.net/2019/07/26/5d3a50aed57c293627.png" alt="5d3a50aed57c293627"></p><p>精确的时延计算十分复杂，不过可以通过ping命令进行粗略的计算，通过ping命令得出的平均往返时间除以2，就是我们的网络时延。</p><hr><h3 id="TCP怎么进行拥塞控制？（慢启动、拥塞避免、快重传、快恢复）"><a href="#TCP怎么进行拥塞控制？（慢启动、拥塞避免、快重传、快恢复）" class="headerlink" title="TCP怎么进行拥塞控制？（慢启动、拥塞避免、快重传、快恢复）"></a>TCP怎么进行拥塞控制？（慢启动、拥塞避免、快重传、快恢复）</h3><p><img src="https://i.loli.net/2019/07/26/5d3a5a9e075a842627.png" alt="5d3a5a9e075a842627"></p><p><a href="https://www.cnblogs.com/anzhengyu/p/11232804.html">原博文——TCP的流量控制与拥塞控制</a></p><p>TCP通过<strong>慢启动、拥塞避免、快重传以及快恢复</strong>这四个算法来进行拥塞控制（具体的可以参见上面那篇博文）：</p><blockquote><ul><li><strong>慢启动：</strong>一开始先设置一个比较小的拥塞窗口值cwnd（报文段的倍数），然后进行数据传输，每收到一个报文段的确认，我们就将<strong>cwnd+1</strong>，这样下来，cwnd总体上是乘以<strong>2^n</strong>的倍数增长。（慢启动非增长速度慢，只是增长的初始基数比较小）</li><li><strong>拥塞避免：</strong> 因为慢启动算法的增长比较快，当cwnd = ssthresh（预先设置好的门限值）时，我们启动拥塞避免算法，窗口值开始线性增长。</li></ul><blockquote><p>随着拥塞避免算法的进行，网络出现超时的情况（这时判断为<strong>拥塞出现</strong>）。这时将cwnd降为一开始的值，重新进行<strong>慢开始-拥塞避免</strong>，并且此时的门限值设为出现拥塞时的cwnd的一半。</p></blockquote><ul><li><strong>快重传：</strong> 快重传的目的是为了让发送方尽早知道某个报文段的丢失。如何知道呢？<strong>当我们重复收到某一个报文段的3次确认时，我们就可以判断，它的下一个报文段可能出现了丢失</strong>。这时我们启动快重传算法，立即重传丢失的报文段。</li><li><strong>快恢复：</strong> 上面快重传算法的启动只是因为个别报文段的丢失，我们这时并不判断为网络拥塞，而是启动快恢复算法。我们将cwnd=ssthresh=当前cwnd的一半，并且开始拥塞避免算法。</li></ul><blockquote><p>当然，也有的快恢复算法是将当前拥塞窗口再增大3个报文段的值，因为既然收到了3个重复的ACK，则说明有三个分组已经离开了网络，不在占用网络资源而是停留在对方缓存当中，可以适当将窗口值增大。</p></blockquote></blockquote><hr><h3 id="TCP对应的协议有哪些？UDP对应的协议有哪些？"><a href="#TCP对应的协议有哪些？UDP对应的协议有哪些？" class="headerlink" title="TCP对应的协议有哪些？UDP对应的协议有哪些？"></a>TCP对应的协议有哪些？UDP对应的协议有哪些？</h3><p><img src="https://i.loli.net/2019/07/26/5d3a54340888063337.jpg" alt="5d3a54340888063337"></p><hr><h3 id="面向连接和无连接的区别？"><a href="#面向连接和无连接的区别？" class="headerlink" title="面向连接和无连接的区别？"></a>面向连接和无连接的区别？</h3><p><strong>应该与前面TCP和UDP的区别类似。</strong></p><blockquote><ul><li>面向连接在传输之前需要先建立连接，而且传输完成后必须要释放连接。无连接则不需要事先建立连接，直接传输数据。</li><li>面向连接一般要保证数据传输的可靠性，有序性。</li></ul></blockquote><hr><h3 id="端口以及对应的服务？"><a href="#端口以及对应的服务？" class="headerlink" title="端口以及对应的服务？"></a>端口以及对应的服务？</h3><blockquote><p><strong>端口号分类：</strong></p><ul><li><p>服务器端使用的端口号。</p><blockquote><p><strong>熟知端口号</strong>：0~1023。IANA把一些端口号指派给了TCP/IP最重要的一些程序。当有一些新的应用程序出现后，IANA必须给它指定 一个熟知端口号，否则互联网上的其他应用进程无法和它进行通信。</p><table><thead><tr><th>应用程序</th><th>FTP</th><th align="center">TELNET</th><th align="center">SMTP</th><th align="center">DNS</th><th align="center">TFTP</th><th align="center">HTTP</th><th align="center">SNMP</th><th align="center">SNMP(trap)</th><th align="center">HTTPS</th></tr></thead><tbody><tr><td>熟知端口号</td><td>21</td><td align="center">23</td><td align="center">25</td><td align="center">53</td><td align="center">69</td><td align="center">80</td><td align="center">161</td><td align="center">162</td><td align="center">443</td></tr></tbody></table><p><strong>登记端口号：</strong>1024~49151。这类端口号是为没有熟知端口号的应用程序使用。这类端口号必须在IANA中按照规定的手续进行登记，以防止重复。</p></blockquote></li><li><p>客户端使用的端口号：49152~65535。只有在客户端进程运行时才动态选择，因此又叫短暂端口号。这类端口号留给客户进程选择暂时使用，通信结束后就释放，不再占用。</p></li></ul></blockquote><p>如果对你有帮助，就推荐+收藏吧！😜😜</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统常见问题</title>
      <link href="/2020/11/24/cao-zuo-xi-tong-chang-jian-mian-shi-ti/"/>
      <url>/2020/11/24/cao-zuo-xi-tong-chang-jian-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<p><b><span style="color:#FF4500;">写在最前面：本文章所有内容是本人从网络整理而得，并非商用，仅供学习交流使用。</span></b></p><h3 id="1-进程的常见状态？以及各种状态之间的转换条件？"><a href="#1-进程的常见状态？以及各种状态之间的转换条件？" class="headerlink" title="1.进程的常见状态？以及各种状态之间的转换条件？"></a>1.进程的常见状态？以及各种状态之间的转换条件？</h3><ul><li>就绪：进程已处于准备好运行的状态，即进程已分配到除CPU外的所有必要资源后，只要再获得CPU，便可立即执行。</li><li>执行：进程已经获得CPU，程序正在执行状态。</li><li>阻塞：正在执行的进程由于发生某事件（如I/O请求、申请缓冲区失败等）暂时无法继续执行的状态。</li></ul><p>​     <img src="https://images2018.cnblogs.com/blog/1118296/201805/1118296-20180522204056722-921601285.jpg" alt="img"></p><h3 id="2-进程同步"><a href="#2-进程同步" class="headerlink" title="2.进程同步"></a>2.进程同步</h3><p>进程同步的主要任务：是对多个相关进程在执行次序上进行协调，以使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。</p><p>　　同步机制遵循的原则：</p><p>　　（1）空闲让进；</p><p>　　（2）忙则等待（保证对临界区的互斥访问）；</p><p>　　（3）有限等待（有限代表有限的时间，避免死等）；</p><p>　　（4）让权等待，（当进程不能进入自己的临界区时，应该释放处理机，以免陷入忙等状态）。</p><h3 id="3-进程的通信方式有哪些？"><a href="#3-进程的通信方式有哪些？" class="headerlink" title="3.进程的通信方式有哪些？"></a>3.进程的通信方式有哪些？</h3><p>　　进程通信，是指进程之间的信息交换（信息量少则一个状态或数值，多者则是成千上万个字节）。因此，对于用信号量进行的进程间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。</p><p>　　所谓高级进程通信指：用户可以利用操作系统所提供的一组通信命令传送大量数据的一种通信方式。操作系统隐藏了进程通信的实现细节。或者说，通信过程对用户是透明的。</p><p>　　高级通信机制可归结为三大类：</p><p>　　（1）共享存储器系统（存储器中划分的共享存储区）；实际操作中对应的是“剪贴板”（剪贴板实际上是系统维护管理的一块内存区域）的通信方式，比如举例如下：word进程按下ctrl+c，在ppt进程按下ctrl+v，即完成了word进程和ppt进程之间的通信，复制时将数据放入到剪贴板，粘贴时从剪贴板中取出数据，然后显示在ppt窗口上。</p><p>　　（2）消息传递系统（进程间的数据交换以消息（message）为单位，当今最流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。应用举例：邮槽（MailSlot）是基于广播通信体系设计出来的，它采用无连接的不可靠的数据传输。邮槽是一种单向通信机制，创建邮槽的服务器进程读取数据，打开邮槽的客户机进程写入数据。</p><p>　　（3）管道通信系统（管道即：连接读写进程以实现他们之间通信的共享文件（pipe文件，类似先进先出的队列，由一个进程写，另一进程读））。实际操作中，管道分为：匿名管道、命名管道。匿名管道是一个未命名的、单向管道，通过父进程和一个子进程之间传输数据。匿名管道只能实现本地机器上两个进程之间的通信，而不能实现跨网络的通信。命名管道不仅可以在本机上实现两个进程间的通信，还可以跨网络实现两个进程间的通信。</p><ul><li><strong>管道</strong>：<strong>管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。</strong>写进程在管道的尾端写入数据，读进程在管道的道端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。管道提供了简单的流控制机制。进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。</li></ul><p>​     <strong>注1：无名管道只能实现父子或者兄弟进程之间的通信，有名管道（FIFO）可以实现互不相关的两个进程之间的通信。</strong></p><p>　　  <strong>注2：用FIFO让一个服务器和多个客户端进行交流时候，每个客户在向服务器发送信息前建立自己的读管道，或者让服务器在得到数据后再建立管道。使用客户的进程号（pid）作为管道名是一种常用的方法。客户可以先把自己的进程号告诉服务器，然后再到那个以自己进程号命名的管道中读取回复。</strong></p><ul><li><strong>信号量</strong>：<strong>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。</strong>它常作为一种锁机制，防止某进程正在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li><strong>消息队列</strong>：<strong>是一个在系统内核中用来保存消 息的队列，它在系统内核中是以消息链表的形式出现的。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</strong>。</li><li><strong>共享内存</strong>：共享内存允许两个或多个进程访问同一个逻辑内存。<strong>这一段内存可以被两个或两个以上的进程映射至自身的地址空间中</strong>，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信<strong>。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。</strong>共享内存是最快的IPC方式，它是针对其它进程间通信方式运行效率低而专门设计的。它往往与其它通信机制（如<strong>信号量</strong>）配合使用，来实现进程间的同步和通信。</li><li><strong>套接字</strong>：套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。</li></ul><h3 id="4-上下文切换"><a href="#4-上下文切换" class="headerlink" title="4.上下文切换"></a>4.上下文切换</h3><p>对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。上下文切换(Context Switch)是一种<strong>将CPU资源从一个进程分配给另一个进程的机制</strong>。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。<strong>在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</strong></p><h3 id="5-进程与线程的区别和联系？"><a href="#5-进程与线程的区别和联系？" class="headerlink" title="5.进程与线程的区别和联系？"></a>5.进程与线程的区别和联系？</h3><ul><li><strong>进程</strong>是具有一定独立功能的程序关于某个数据集合上的一次运行活动，<strong>进程</strong>是系统进行资源分配和调度的一个独立单位。</li><li><strong>线程</strong>是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</li></ul><p><strong>进程和线程的关系</strong></p><p>（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。</p><p>（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。</p><p>（3）处理机分给线程，即真正在处理机上运行的是线程。</p><p>（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><p><strong>进程与线程的区别？</strong></p><p>（1）进程有自己的独立地址空间，线程没有</p><p>（2）进程是资源分配的最小单位，线程是CPU调度的最小单位</p><p>（3）进程和线程通信方式不同(线程之间的通信比较方便。同一进程下的线程共享数据（比如全局变量，静态变量），通过这些数据来通信不仅快捷而且方便，当然如何处理好这些访问的同步与互斥正是编写多线程程序的难点。而进程之间的通信只能通过<a href="http://baike.baidu.com/view/549640.htm">进程通信</a>的方式进行。)</p><p>（4）进程上下文切换开销大，线程开销小</p><p>（5）一个进程挂掉了不会影响其他进程，而线程挂掉了会影响其他线程</p><p>（6）对进程进程操作一般开销都比较大，对线程开销就小了 </p><p> <strong>为什么进程上下文切换比线程上下文切换代价高？</strong></p><p>进程切换分两步：</p><p>1.切换页目录以使用新的地址空间</p><p>2.切换内核栈和硬件上下文</p><p>对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。</p><p>切换的性能消耗：</p><p>1、线程上下文切换和进程上下问切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。</p><p>2、另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。</p><p>转自知乎：<strong>进程和线程的区别</strong></p><p>链接：<a href="https://www.zhihu.com/question/25532384/answer/81152571">https://www.zhihu.com/question/25532384/answer/81152571</a></p><p>首先来一句概括的总论：<strong>进程和线程都是一个时间段的描述，是CPU工作时间段的描述。</strong></p><p><strong>下面细说背景</strong>：<br>CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。</p><p><strong>一个最最基础的事实</strong>：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。</p><p><strong>一个必须知道的事实</strong>：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。</p><p><strong>串联起来的事实</strong>：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：***先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文*。。。*。</p><p>*========= 重要的东西出现了========<br><strong>进程和线程<em>就是这样的背景出来的</em>***，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。<br>*</strong></p><ul><li><strong>进程就是包换上下文切换的程序执行时间总和</strong> = <strong>CPU加载上下文+CPU执行+CPU保存上下文</strong></li></ul><p>***线程是什么呢？<br>***进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：</p><p>程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。</p><p>这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这**里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。</p><p>到此全文结束，再一个总结：<br>**<br><strong>进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</strong></p><ul><li>进程(process)与线程(thread)最大的区别是<strong>进程拥有自己的地址空间，某进程内的线程对于其他进程不可见，即进程A不能通过传地址的方式直接读写进程B的存储区域</strong>。进程之间的通信需要通过进程间通信(Inter-process communication，IPC)。与之相对的，<strong>同一进程的各线程间之间可以直接通过传递地址或全局变量的方式传递信息</strong>。</li><li><strong>进程作为操作系统中拥有资源和独立调度的基本单位，可以拥有多个线程。</strong>通常操作系统中运行的一个程序就对应一个进程。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。<strong>相比进程切换，线程切换的开销要小很多。线程于进程相互结合能够提高系统的运行效率。</strong></li></ul><p><strong>线程可以分为两类：</strong></p><ul><li><strong>用户级线程(user level thread)<strong>：对于这类线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统分配给该程序一个进程号，以及其对应的内存空间等资源。应用程序通常先在一个线程中运行，该线程被成为主线程。在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程。</strong>用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。</strong></li><li><strong>内核级线程(kernel level thread)<strong>：对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口。内核维护进程及其内部的每个线程，调度也由内核基于线程架构完成。内核级线程的好处是，</strong>内核可以将不同线程更好地分配到不同的CPU，以实现真正的并行计算。</strong></li></ul><p><strong>事实上，在现代操作系统中，往往使用组合方式实现多线程，即线程创建完全在用户空间中完成，并且一个应用程序中的多个用户级线程被映射到一些内核级线程上，相当于是一种折中方案。</strong></p><h3 id="6-进程调度"><a href="#6-进程调度" class="headerlink" title="6.进程调度"></a>6.进程调度</h3><p><strong>调度种类</strong></p><ul><li><strong>高级调度</strong>：(High-Level Scheduling)又称为作业调度，它决定把后备作业调入内存运行；</li><li><strong>低级调度</strong>：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；</li><li><strong>中级调度</strong>：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。</li></ul><p><strong>非抢占式调度与抢占式调度</strong></p><ul><li><strong>非抢占式</strong>：分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程。</li><li><strong>抢占式</strong>：操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式。</li></ul><p><strong>调度策略的设计</strong></p><ul><li><strong>响应时间</strong>: 从用户输入到产生反应的时间</li><li><strong>周转时间</strong>: 从任务开始到任务结束的时间</li></ul><p>CPU任务可以分为<strong>交互式任务</strong>和<strong>批处理任务</strong>，调度最终的目标是<strong>合理的使用CPU，使得交互式任务的响应时间尽可能短，用户不至于感到延迟，同时使得批处理任务的周转时间尽可能短，减少用户等待的时间。</strong></p><p><strong>调度算法：</strong></p><p><strong>FIFO或First Come, First Served (FCFS)先来先服务</strong></p><ul><li>调度的顺序就是任务到达就绪队列的顺序。</li><li>公平、简单(FIFO队列)、非抢占、不适合交互式。</li><li>未考虑任务特性，平均等待时间可以缩短。</li></ul><p><strong>Shortest Job First (SJF)</strong></p><ul><li>最短的作业(CPU区间长度最小)最先调度。</li><li>SJF可以保证最小的平均等待时间。</li></ul><p><strong>Shortest Remaining Job First (SRJF)</strong></p><ul><li>SJF的可抢占版本，比SJF更有优势。</li><li>SJF(SRJF): 如何知道下一CPU区间大小？根据历史进行预测: 指数平均法。</li></ul><p><strong>优先权调度</strong></p><ul><li>每个任务关联一个优先权，调度优先权最高的任务。</li><li>注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。</li></ul><p><strong>Round-Robin(RR)轮转调度算法</strong></p><ul><li>设置一个时间片，按时间片来轮转调度（“轮叫”算法）</li><li>优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多；</li><li>时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS。</li></ul><p><strong>多级队列调度</strong></p><ul><li>按照一定的规则建立多个进程队列</li><li>不同的队列有固定的优先级（高优先级有抢占权）</li><li>不同的队列可以给不同的时间片和采用不同的调度方法</li><li>存在问题1：没法区分I/O bound和CPU bound；</li><li>存在问题2：也存在一定程度的“饥饿”现象；</li></ul><p><strong>多级反馈队列</strong></p><ul><li><strong>在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务。</strong></li><li><strong>可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”。</strong></li><li><strong>最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等。</strong></li></ul><p><strong>多级反馈队列调度算法描述:</strong></p><p><img src="https://segmentfault.com/img/bVUAMV?w=300&amp;h=211" alt="clipboard.png"></p><ul><li>进程在进入待调度的队列等待时，<strong>首先进入优先级最高的Q1等待。</strong></li><li><strong>首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。</strong>例如：Q1,Q2,Q3三个队列，只有在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。</li><li><strong>对于同一个队列中的各个进程，按照时间片轮转法调度。</strong>比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。</li><li><strong>在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业（抢占式）。</strong></li></ul><p><strong>一个简单的例子</strong><br>假设系统中有3个反馈队列Q1,Q2,Q3，时间片分别为2，4，8。现在有3个作业J1,J2,J3分别在时间 0 ，1，3时刻到达。而它们所需要的CPU时间分别是3，2，1个时间片。</p><ul><li><ul><li><strong>时刻0</strong> J1到达。 于是进入到队列1 ，运行1个时间片 ，时间片还未到，此时J2到达。</li><li><strong>时刻1</strong> J2到达。 由于时间片仍然由J1掌控，于是等待。J1在运行了1个时间片后，已经完成了在Q1中的2个时间片的限制，于是J1置于Q2等待被调度。现在处理机分配给J2。</li><li><strong>时刻2</strong> J1进入Q2等待调度，J2获得CPU开始运行。</li><li><strong>时刻3</strong> J3到达，由于J2的时间片未到，故J3在Q1等待调度，J1也在Q2等待调度。</li><li><strong>时刻4</strong> J2处理完成，由于J3，J1都在等待调度，但是J3所在的队列比J1所在的队列的优先级要高，于是J3被调度，J1继续在Q2等待。</li><li><strong>时刻5</strong> J3经过1个时间片，完成。</li><li><strong>时刻6</strong> 由于Q1已经空闲，于是开始调度Q2中的作业，则J1得到处理器开始运行。 J1再经过一个时间片，完成了任务。于是整个调度过程结束。</li></ul></li></ul><h3 id="7-死锁的条件？以及如何处理死锁问题？"><a href="#7-死锁的条件？以及如何处理死锁问题？" class="headerlink" title="7.死锁的条件？以及如何处理死锁问题？"></a>7.死锁的条件？以及如何处理死锁问题？</h3><p><strong>定义</strong>:如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件,那么该组进程就是死锁的。或者在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。</p><p>产生死锁的必要条件：</p><ul><li>**互斥条件(Mutual exclusion)**：资源不能被共享，只能由一个进程使用。</li><li>**请求与保持条件(Hold and wait)**：已经得到资源的进程可以再次申请新的资源。</li><li>**非抢占条件(No pre-emption)**：已经分配的资源不能从相应的进程中被强制地剥夺。</li><li>**循环等待条件(Circular wait)**：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。</li></ul><p><strong>如何处理死锁问题：</strong></p><ul><li><strong>忽略该问题</strong>。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。</li><li><strong>检测死锁并且恢复。</strong></li><li>仔细地对资源进行动态分配，使系统始终处于安全状态以<strong>避免死锁</strong>。</li><li><strong>通过破除死锁四个必要条件之一，来防止死锁产生。</strong></li></ul><h3 id="8-临界资源"><a href="#8-临界资源" class="headerlink" title="8.临界资源"></a><strong>8.临界资源</strong></h3><ul><li>在操作系统中，进程是占有资源的最小单位（线程可以访问其所在进程内的所有资源，但线程本身并不占有资源或仅仅占有一点必须资源）。但<strong>对于某些资源来说，其在同一时间只能被一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源</strong>。典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题)。</li><li><strong>对于临界资源的访问，必须是互斥进行。</strong>也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。<strong>而进程内访问临界资源的代码被成为临界区。</strong></li></ul><h3 id="9-一个程序从开始运行到结束的完整过程（四个过程）"><a href="#9-一个程序从开始运行到结束的完整过程（四个过程）" class="headerlink" title="9.一个程序从开始运行到结束的完整过程（四个过程）"></a>9.一个程序从开始运行到结束的完整过程（四个过程）</h3><p>1、预处理：条件编译，头文件包含，宏替换的处理，生成.i文件。</p><p>2、编译：将预处理后的文件转换成汇编语言，生成.s文件</p><p>3、汇编：汇编变为目标代码(机器代码)生成.o的文件</p><p>4、链接：连接目标代码,生成可执行程序</p><p><a href="https://blog.csdn.net/wqx521/article/details/52625408">链接</a></p><h3 id="10-内存池、进程池、线程池。-c-程序员必须掌握"><a href="#10-内存池、进程池、线程池。-c-程序员必须掌握" class="headerlink" title="10.内存池、进程池、线程池。(c++程序员必须掌握)"></a>10.内存池、进程池、线程池。(c++程序员必须掌握)</h3><p> 　　首先介绍一个概念“池化技术 ”。池化技术就是：提前保存大量的资源，以备不时之需以及重复使用。池化技术应用广泛，如内存池，线程池，连接池等等。内存池相关的内容，建议看看Apache、Nginx等开源web服务器的内存池实现。<br> 　　由于在实际应用当做，分配内存、创建进程、线程都会设计到一些系统调用，系统调用需要导致程序从用户态切换到内核态，是非常耗时的操作。因此，当程序中需要频繁的进行内存申请释放，进程、线程创建销毁等操作时，通常会使用内存池、进程池、线程池技术来提升程序的性能。</p><p> 　　<strong>线程池</strong>：线程池的原理很简单，类似于操作系统中的缓冲区的概念，它的流程如下：先启动若干数量的线程，并让这些线程都处于睡眠状态，当需要一个开辟一个线程去做具体的工作时，就会唤醒线程池中的某一个睡眠线程，让它去做具体工作，当工作完成后，线程又处于睡眠状态，而不是将线程销毁。</p><p> 　　<strong>进程池</strong>与线程池同理。</p><p> 　　<strong>内存池</strong>：内存池是指程序预先从操作系统申请一块足够大内存，此后，当程序中需要申请内存的时候，不是直接向操作系统申请，而是直接从内存池中获取；同理，当程序释放内存的时候，并不真正将内存返回给操作系统，而是返回内存池。当程序退出(或者特定时间)时，内存池才将之前申请的内存真正释放。</p><h3 id="11-动态链接库与静态链接库的区别"><a href="#11-动态链接库与静态链接库的区别" class="headerlink" title="11.动态链接库与静态链接库的区别"></a>11.动态链接库与静态链接库的区别</h3><p><strong>静态库</strong></p><ul><li>静态库是一个外部函数与变量的集合体。静态库的文件内容，通常包含一堆程序员自定的变量与函数，其内容不像动态链接库那么复杂，在编译期间由编译器与链接器将它集成至应用程序内，并制作成目标文件以及可以独立运作的可执行文件。而这个可执行文件与编译可执行文件的程序，都是一种程序的静态创建（static build）。</li></ul><p><img src="https://images2018.cnblogs.com/blog/1118296/201809/1118296-20180902162023684-811662571.jpg" alt="img"></p><p><strong>动态库</strong></p><ul><li>静态库很方便，但是如果我们只是想用库中的某一个函数，却仍然得把所有的内容都链接进去。一个更现代的方法则是使用共享库，避免了在文件中静态库的大量重复。</li><li>动态链接可以在首次载入的时候执行(load-time linking)，这是 Linux 的标准做法，会由动态链接器ld-linux.so 完成，比方标准 C 库(libc.so) 通常就是动态链接的，这样<strong>所有的程序可以共享同一个库，而不用分别进行封装。</strong></li><li>动态链接也可以在程序开始执行的时候完成(run-time linking)，在 Linux 中使用 dlopen()接口来完成（会使用函数指针），通常用于分布式软件，高性能服务器上。而且共享库也可以在多个进程间共享。</li><li><strong>链接使得我们可以用多个对象文件构造我们的程序。可以在程序的不同阶段进行（编译、载入、运行期间均可），理解链接可以帮助我们避免遇到奇怪的错误</strong>。</li></ul><p><img src="https://images2018.cnblogs.com/blog/1118296/201809/1118296-20180902162103595-917107800.png" alt="img"></p><p>区别：</p><ol><li>使用静态库的时候，静态链接库要参与编译，在生成执行文件之前的链接过程中，要将静态链接库的全部指令直接链接入可执行文件中。而动态库提供了一种方法，使进程可以调用不属于其可执行代码的函数。函数的可执行代码位于一个.dll文件中，该dll包含一个或多个已被编译，链接并与使用它们的进程分开储存的函数。</li><li>静态库中不能再包含其他动态库或静态库，而在动态库中还可以再包含其他动态或者静态库。</li><li>静态库在编译的时候，就将库函数装在到程序中去了，而动态库函数必须在运行的时候才被装载，所以使用静态库速度快一些。</li></ol><p><a href="http://www.cnblogs.com/gaoyihan/p/4723332.html">链接</a></p><h3 id="12-虚拟内存？优缺点？"><a href="#12-虚拟内存？优缺点？" class="headerlink" title="12.虚拟内存？优缺点？"></a>12.虚拟内存？优缺点？</h3><p>定义：具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充得一种存储器系统。其逻辑容量由内存之和和外存之和决定。</p><p>与传统存储器比较虚拟存储器有以下三个主要特征：</p><ul><li>多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。</li><li>对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。</li><li>虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。</li></ul><p>虚拟内存的实现有以下两种方式：</p><ul><li>请求分页存储管理。</li><li>请求分段存储管理。</li></ul><h3 id="13-页面置换算法"><a href="#13-页面置换算法" class="headerlink" title="13.页面置换算法"></a>13.页面置换算法</h3><p>操作系统将内存按照页面进行管理，在需要的时候才把进程相应的部分调入内存。当产生缺页中断时，需要选择一个页面写入。如果要换出的页面在内存中被修改过，变成了“脏”页面，那就需要先写会到磁盘。页面置换算法，就是要选出最合适的一个页面，使得置换的效率最高。页面置换算法有很多，简单介绍几个，重点介绍比较重要的LRU及其实现算法。</p><p><strong>一、最优页面置换算法</strong></p><p>最理想的状态下，我们给页面做个标记，挑选一个最远才会被再次用到的页面调出。当然，这样的算法不可能实现，因为不确定一个页面在何时会被用到。</p><p><strong>二、先进先出页面置换算法（FIFO）及其改进</strong></p><p>这种算法的思想和队列是一样的，该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予淘汰。实现：把一个进程已调入内存的页面按先后次序链接成一个队列，并且设置一个指针总是指向最老的页面。缺点：对于有些经常被访问的页面如含有全局变量、常用函数、例程等的页面，不能保证这些不被淘汰。</p><p><strong>三、最近最少使用页面置换算法LRU（Least Recently Used）</strong></p><p>根据页面调入内存后的使用情况做出决策。LRU置换算法是选择最近最久未使用的页面进行淘汰。</p><p>1.为每个在内存中的页面配置一个移位寄存器。（P165）定时信号将每隔一段时间将寄存器右移一位。最小数值的寄存器对应页面就是最久未使用页面。</p><p>2.利用一个特殊的栈保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。因此，栈顶永远是最新被访问的页面号，栈底是最近最久未被访问的页面号。</p><p><a href="https://www.cnblogs.com/edisonchou/p/5094066.html">链接：分页内存管理（把虚拟内存空间和物理内存空间均划分为大小相同的页面等内容）</a></p><p><a href="http://www.cnblogs.com/edisonchou/p/5115242.html">链接：分段内存管理</a></p><h3 id="14-中断与系统调用"><a href="#14-中断与系统调用" class="headerlink" title="14.中断与系统调用"></a>14.中断与系统调用</h3><p><strong>所谓的中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得CPU暂停对程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序。</strong>中断一般分为三类：</p><ul><li>由计算机硬件异常或故障引起的中断，称为<strong>内部异常中断</strong>；</li><li>由程序中执行了引起中断的指令而造成的中断，称为<strong>软中断</strong>（这也是和我们将要说明的系统调用相关的中断）；</li><li>由外部设备请求引起的中断，称为<strong>外部中断</strong>。简单来说，对中断的理解就是对一些特殊事情的处理。</li></ul><p>与中断紧密相连的一个概念就是<strong>中断处理程序</strong>了。当中断发生的时候，系统需要去对中断进行处理，对这些中断的处理是由操作系统内核中的特定函数进行的，这些处理中断的特定的函数就是我们所说的中断处理程序了。</p><p>另一个与中断紧密相连的概念就是<strong>中断的优先级</strong>。中断的优先级说明的是当一个中断正在被处理的时候，处理器能接受的中断的级别。中断的优先级也表明了中断需要被处理的紧急程度。<strong>每个中断都有一个对应的优先级，当处理器在处理某一中断的时候，只有比这个中断优先级高的中断可以被处理器接受并且被处理。</strong>优先级比这个当前正在被处理的中断优先级要低的中断将会被忽略。</p><p><strong>典型的中断优先级如下所示：</strong></p><ul><li><strong>机器错误 &gt; 时钟 &gt; 磁盘 &gt; 网络设备 &gt; 终端 &gt; 软件中断</strong></li></ul><p>在讲系统调用之前，先说下<strong>进程的执行在系统上的两个级别</strong>：用户级和核心级，也称为**用户态和系统态(user mode and kernel mode)**。</p><p>​      <strong>用户空间就是用户进程所在的内存区域</strong>，相对的，<strong>系统空间就是操作系统占据的内存区域</strong>。用户进程和系统进程的所有数据都在内存中。<strong>处于用户态的程序只能访问用户空间，而处于内核态的程序可以访问用户空间和内核空间。</strong></p><p><strong>用户态切换到内核态的方式如下：</strong></p><ul><li><strong>系统调用</strong>：程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件（这些均属于系统调用）等，就需要向操作系统发出调用服务的请求，这就是系统调用。</li><li><strong>异常</strong>：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li><li><strong>外围设备的中断：</strong>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li></ul><p><strong>用户态和核心态(内核态）之间的区别是什么呢？</strong></p><p>​    <strong>权限不一样。</strong></p><ul><li><strong>用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）</strong>。</li><li><strong>核心态下的进程能够存取内核和用户地址某些机器指令是特权指令，在用户态下执行特权指令会引起错误。</strong>在系统中内核并不是作为一个与用户进程平行的估计的进程的集合。</li></ul><h3 id="15-C-多线程，互斥，同步"><a href="#15-C-多线程，互斥，同步" class="headerlink" title="15.C++多线程，互斥，同步"></a>15.C++多线程，互斥，同步</h3><h4 id="同步和互斥"><a href="#同步和互斥" class="headerlink" title="同步和互斥"></a>同步和互斥</h4><p>当有多个线程的时候，经常需要去<strong>同步(注：同步不是同时刻)<strong>这些线程以访问同一个数据或资源。例如，假设有一个程序，其中一个线程用于把文件读到内存，而另一个线程用于统计文件中的字符数。当然，在把整个文件调入内存之前，统计它的计数是没有意义的。但是，由于每个操作都有自己的线程，操作系统会把两个线程当作是互不相干的任务分别执行，这样就可能在没有把整个文件装入内存时统计字数。为解决此问题，你必须使两个线程</strong>同步</strong>工作。</p><p>所谓<strong>同步</strong>，是指在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。如果用对资源的访问来定义的话，同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p><p>所谓<strong>互斥</strong>，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p><h4 id="多线程同步和互斥有几种实现方法"><a href="#多线程同步和互斥有几种实现方法" class="headerlink" title="多线程同步和互斥有几种实现方法"></a>多线程同步和互斥有几种实现方法</h4><p>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</p><p>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。</p><p>内核模式下的方法有：事件，信号量，互斥量。</p><p>1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。<br>2、互斥量:为协调共同对一个共享资源的单独访问而设计的。<br>3、信号量:为控制一个具有有限数量用户资源而设计。<br>4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。</p><h3 id="16-逻辑地址-Vs-物理地址-Vs-虚拟内存"><a href="#16-逻辑地址-Vs-物理地址-Vs-虚拟内存" class="headerlink" title="16.逻辑地址 Vs 物理地址 Vs 虚拟内存"></a>16.逻辑地址 Vs 物理地址 Vs 虚拟内存</h3><ul><li><strong>所谓的逻辑地址，是指计算机用户(例如程序开发者)，看到的地址。</strong>例如，当创建一个长度为100的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为4个字节，故第二个元素的地址时起始地址加4，以此类推。事实上，<strong>逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址(在内存条中所处的位置)，并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维</strong>。</li><li>另一个重要概念是虚拟内存。操作系统读写内存的速度可以比读写磁盘的速度快几个量级。但是，内存价格也相对较高，不能大规模扩展。于是，<strong>操作系统可以通过将部分不太常用的数据移出内存，“存放到价格相对较低的磁盘缓存，以实现内存扩展</strong>。操作系统还可以通过算法预测哪部分存储到磁盘缓存的数据需要进行读写，提前把这部分数据读回内存。<strong>虚拟内存空间相对磁盘而言要小很多，因此，即使搜索虚拟内存空间也比直接搜索磁盘要快。唯一慢于磁盘的可能是，内存、虚拟内存中都没有所需要的数据，最终还需要从硬盘中直接读取。</strong>这就是为什么内存和虚拟内存中需要存储会被重复读写的数据，否则就失去了缓存的意义。现代计算机中有一个专门的**转译缓冲区(Translation Lookaside Buffer，TLB)**，用来实现虚拟地址到物理地址的快速转换。</li></ul><p><strong>与内存／虚拟内存相关的还有如下两个概念：</strong><br><strong>1) Resident Set</strong></p><ul><li>当一个进程在运行的时候，操作系统不会一次性加载进程的所有数据到内存，只会加载一部分正在用，以及预期要用的数据。其他数据可能存储在虚拟内存，交换区和硬盘文件系统上。<strong>被加载到内存的部分就是resident set。</strong></li></ul><p><strong>2) Thrashing</strong></p><ul><li>由于resident set包含预期要用的数据，理想情况下，进程运行过程中用到的数据都会逐步加载进resident set。但事实往往并非如此：<strong>每当需要的内存页面(page)不在resident set中时，操作系统必须从虚拟内存或硬盘中读数据，这个过程被称为内存页面错误(page faults)。当操作系统需要花费大量时间去处理页面错误的情况就是thrashing。</strong></li></ul><p><strong>参考链接：</strong><a href="https://blog.csdn.net/newcong0123/article/details/52792070">https://blog.csdn.net/newcong0123/article/details/52792070</a></p><h3 id="17-内部碎片与外部碎片"><a href="#17-内部碎片与外部碎片" class="headerlink" title="17.内部碎片与外部碎片"></a><strong>17.内部碎片与外部碎片</strong></h3><p>在内存管理中，<strong>内部碎片</strong>是已经被分配出去的的内存空间大于请求所需的内存空间。</p><p><strong>外部碎片</strong>是指还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲块。</p><p>固定分区存在内部碎片，可变式分区分配会存在外部碎片；</p><p><strong>页式虚拟存储</strong>系统存在<strong>内部碎片</strong>；<strong>段式虚拟存储</strong>系统，存在<strong>外部碎片</strong></p><p>为了有效的利用内存，使内存产生更少的碎片，要对内存分页，内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片。</p><p>为了共享要分段，在段的换入换出时形成外部碎片，比如5K的段换出后，有一个4k的段进来放到原来5k的地方，于是形成1k的外部碎片。</p><h3 id="18-同步和互斥的区别"><a href="#18-同步和互斥的区别" class="headerlink" title="18.同步和互斥的区别"></a>18.同步和互斥的区别</h3><p>​    当有多个线程的时候，经常需要去同步这些线程以访问同一个数据或资源。例如，假设有一个程序，其中一个线程用于把文件读到内存，而另一个线程用于统计文件中的字符数。当然，在把整个文件调入内存之前，统计它的计数是没有意义的。但是，由于每个操作都有自己的线程，操作系统会把两个线程当作是互不相干的任务分别执行，这样就可能在没有把整个文件装入内存时统计字数。为解决此问题，你必须使两个线程同步工作。</p><p>   所谓<strong>同步</strong>，是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。如果<strong>用对资源的访问来定义的话，同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</strong></p><p>   所谓<strong>互斥</strong>，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果<strong>用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</strong></p><h3 id="19-什么是线程安全"><a href="#19-什么是线程安全" class="headerlink" title="19.什么是线程安全"></a>19.什么是线程安全</h3><p>如果多线程的程序运行结果是可预期的，而且与单线程的程序运行结果一样，那么说明是“线程安全”的。</p><h3 id="20-同步与异步"><a href="#20-同步与异步" class="headerlink" title="20.同步与异步"></a>20.同步与异步</h3><h4 id="同步："><a href="#同步：" class="headerlink" title="同步："></a>同步：</h4><ul><li>同步的定义：是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么，这个进程将会一直等待下去，直到收到返回信息才继续执行下去。</li><li>特点：</li></ul><ol><li>同步是阻塞模式；</li><li>同步是按顺序执行，执行完一个再执行下一个，需要等待，协调运行；</li></ol><h4 id="异步："><a href="#异步：" class="headerlink" title="异步："></a>异步：</h4><ul><li>是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。</li><li>特点：</li></ul><ol><li>异步是非阻塞模式，无需等待；</li><li>异步是彼此独立，在等待某事件的过程中，继续做自己的事，不需要等待这一事件完成后再工作。线程是异步实现的一个方式。</li></ol><h4 id="同步与异步的优缺点："><a href="#同步与异步的优缺点：" class="headerlink" title="同步与异步的优缺点："></a>同步与异步的优缺点：</h4><ul><li>同步可以避免出现死锁，读脏数据的发生。一般共享某一资源的时候，如果每个人都有修改权限，同时修改一个文件，有可能使一个读取另一个人已经删除了内容，就会出错，同步就不会出错。但，同步需要等待资源访问结束，浪费时间，效率低。</li><li>异步可以提高效率，但，安全性较低。</li></ul><h3 id="21-系统调用与库函数的区别"><a href="#21-系统调用与库函数的区别" class="headerlink" title="21.系统调用与库函数的区别"></a>21.系统调用与库函数的区别</h3><ul><li><strong>系统调用(System call)是程序向系统内核请求服务的方式。</strong>可以包括硬件相关的服务(例如，访问硬盘等)，或者创建新进程，调度其他进程等。系统调用是程序和操作系统之间的重要接口。</li><li><strong>库函数：把一些常用的函数编写完放到一个文件里，编写应用程序时调用，这是由第三方提供的，发生在用户地址空间</strong>。</li><li>在<strong>移植性方面</strong>，不同操作系统的系统调用一般是不同的，移植性差；而在所有的ANSI C编译器版本中，C库函数是相同的。</li><li>在<strong>调用开销方面</strong>，系统调用需要在用户空间和内核环境间切换，开销较大；而库函数调用属于“过程调用”，开销较小。</li></ul><h3 id="22-守护、僵尸、孤儿进程的概念"><a href="#22-守护、僵尸、孤儿进程的概念" class="headerlink" title="22.守护、僵尸、孤儿进程的概念"></a>22.守护、僵尸、孤儿进程的概念</h3><ul><li><strong>守护进程</strong>：运行在后台的一种特殊进程，<strong>独立于控制终端并周期性地执行某些任务</strong>。</li><li><strong>僵尸进程</strong>：一个进程 fork 子进程，子进程退出，而父进程没有wait/waitpid子进程，那么<strong>子进程的进程描述符仍保存在系统中</strong>，这样的进程称为僵尸进程。</li><li><strong>孤儿进程</strong>：一个<strong>父进程退出，而它的一个或多个子进程还在运行</strong>，这些子进程称为孤儿进程。（孤儿进程将由 init 进程收养并对它们完成状态收集工作）</li></ul><h3 id="23-Semaphore-信号量-Vs-Mutex-互斥锁"><a href="#23-Semaphore-信号量-Vs-Mutex-互斥锁" class="headerlink" title="23.Semaphore(信号量) Vs Mutex(互斥锁)"></a>23.Semaphore(信号量) Vs Mutex(互斥锁)</h3><ul><li>当用户创立多个线程／进程时，如果不同线程／进程同时读写相同的内容，则可能造成读写错误，或者数据不一致。此时，需要通过加锁的方式，控制临界区(critical section)的访问权限。对于semaphore而言，在初始化变量的时候可以控制允许多少个线程／进程同时访问一个临界区，其他的线程／进程会被堵塞，直到有人解锁。</li><li>Mutex相当于只允许一个线程／进程访问的semaphore。此外，根据实际需要，人们还实现了一种读写锁(read-write lock)，它允许同时存在多个阅读者(reader)，但任何时候至多只有一个写者(writer)，且不能于读者共存。</li></ul><h3 id="24-IO多路复用"><a href="#24-IO多路复用" class="headerlink" title="24.IO多路复用"></a>24.IO多路复用</h3><p><strong>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</strong></p><ul><li>当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。</li><li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li><li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</li><li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</li><li>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</li><li>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</li></ul><h3 id="25-线程安全"><a href="#25-线程安全" class="headerlink" title="25.线程安全"></a>25.线程安全</h3><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和<a href="https://baike.baidu.com/item/%E5%8D%95%E7%BA%BF%E7%A8%8B">单线程</a>运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。或者说:一个类或者程序所提供的接口对于线程来说是<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">原子操作</a>或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。</p><p>线程安全问题都是由<a href="https://baike.baidu.com/item/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">全局变量</a>及<a href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F">静态变量</a>引起的。</p><p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5">线程同步</a>，否则的话就可能影响线程安全。</p><h3 id="26-线程共享资源和独占资源问题"><a href="#26-线程共享资源和独占资源问题" class="headerlink" title="26.线程共享资源和独占资源问题"></a>26.线程共享资源和独占资源问题</h3><p><a href="https://www.cnblogs.com/baoendemao/p/3804677.html">参考链接</a></p><p>一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的（/私有的）栈(stack)，Windows线程的缺省堆栈大小为1M。堆(heap)的分配与栈有所不同，一般是一个进程有一个C运行时堆，这个堆为本进程中所有线程共享，windows进程还有所谓进程默认堆，用户也可以创建自己的堆。<br>用操作系统术语，线程切换的时候实际上切换的是一个可以称之为线程控制块的结构（TCB）,里面保存所有将来用于恢复线程环境必须的信息，包括所有必须保存的寄存器集，线程的状态等。</p><p><strong>堆：</strong>　是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。</p><p><strong>栈：</strong>是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread safe的。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。</p><p><img src="https://images2018.cnblogs.com/blog/1118296/201809/1118296-20180913105925533-936908194.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue核心知识</title>
      <link href="/2020/11/23/vue-he-xin-zhi-shi/"/>
      <url>/2020/11/23/vue-he-xin-zhi-shi/</url>
      
        <content type="html"><![CDATA[<img width="130" align="center" src="http://image.luokangyuan.com/Vue.svg"><p><b><span style="color:#FF4500;">写在最前面：本文章所有内容是本人从网络整理而得，并非商用，仅供学习交流使用。</span></b></p><h1 id="Vue核心知识"><a href="#Vue核心知识" class="headerlink" title="Vue核心知识"></a>Vue核心知识</h1><h2 id="1-1-Vue的基本简介"><a href="#1-1-Vue的基本简介" class="headerlink" title="1.1.Vue的基本简介"></a>1.1.Vue的基本简介</h2><p>学习一门技术首先登陆其官网，<a href="https://cn.vuejs.org/">中文网址</a>，<a href="https://vuejs.org/">英文网址</a>，<code>vue</code>是一款渐进式JavaScript框架，作用是为了动态构建用户界面，该框架遵循MVVM模式，编码简洁，体积小，运行效率高；他借鉴了angular的<code>模板</code>和<code>数据绑定技术</code>，借鉴了react的<code>组件化</code>和<code>虚拟DOM技术</code>，当然，该技术也存在一个Vue全家桶，例如vue脚手架：<code>vue-cli</code>，ajax请求：<code>vue-resource</code>，路由：<code>vue-router</code>，状态管理：<code>vuex</code>，图片懒加载：<code>vue-lazyload</code>，移动端UI组件库：<code>min-ui</code>，PC端组件库：<code>element-ui</code>，页面滑动：<code>vue-scroller</code>等等插件；</p><h2 id="1-2-Vue的基本使用"><a href="#1-2-Vue的基本使用" class="headerlink" title="1.2.Vue的基本使用"></a>1.2.Vue的基本使用</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Hello {{username}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>../js/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token comment">//创建Vue实例</span>    <span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token comment">// 配置对象</span>        el<span class="token operator">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span> <span class="token comment">// element:选择器</span>        data<span class="token operator">:</span><span class="token punctuation">{</span> <span class="token comment">//数据（Model）</span>            username<span class="token operator">:</span><span class="token string">'世界'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><pre class="line-numbers language-none"><code class="language-none">vue的HelloWord编码说明<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用vue首先引入Vue.js，然后创建Vue对象，其中el表示指定的<code>根element选择器</code>，data是指初始化数据，双向数据绑定使用<code>v-model</code>，显示数据使用语法：<code>{{xxx}}</code>；</li><li>vue的MVVM的体现就是：<code>model</code>代表模型，上述代码就是数据对象（data）,<code>view</code>代表视图，就是vue中的模板页面，<code>viewModel</code>代表是视图模型（vue实例）；</li></ul><h2 id="1-3-模板语法"><a href="#1-3-模板语法" class="headerlink" title="1.3.模板语法"></a>1.3.模板语法</h2><p>所谓的模板就是动态的Html页面，包含了一些JS语法代码，在Vue中使用<code>双大括号表达式</code>和<code>指令</code>（以v-开头的自定义标签属性）；</p><pre class="line-numbers language-none"><code class="language-none">双大括号表达式<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>语法是：<code>{{xxx}}</code>，作用就是向页面输出数据，可以调用对象的方法，例如<code>{{msg.toUpperCase()}}</code>；</p><pre class="line-numbers language-none"><code class="language-none">指令：强制数据绑定&lt;body&gt;  &lt;div id="app"&gt;      &lt;p&gt;{{msg}}&lt;/p&gt;      &lt;p&gt;{{msg.toUpperCase()}}&lt;/p&gt;       &lt;img src="imgSrc" alt=""&gt;  &lt;/div&gt;&lt;script src="js/vue.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;    new Vue({        el: '#app',        data: {            msg: 'Hello Word',            imgSrc: 'http://image.luokangyuan.com/1.jpg'        }    })&lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><p>上述代码中的img标签的src属性不会获取到data中定义的imgSrc属性的值，这个时候就需要使用指令强制数据绑定，功能就是<code>指定变化的属性值</code>，完整写法是：<code>v-bind:src='imgSrc'</code>，一般采用简洁写法：<code>:src='imgSrc'</code>；正确写法如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">:src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>imgSrc<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>HTML</p><pre class="line-numbers language-none"><code class="language-none">指令：绑定事件监听&lt;body&gt;  &lt;div id="app"&gt;      &lt;button v-on:click = 'test1'&gt;test1&lt;/button&gt;      &lt;button v-on:click = 'test2(msg)'&gt;test2&lt;/button&gt;      &lt;button @click = 'test'&gt;test&lt;/button&gt;  &lt;/div&gt;&lt;script src="js/vue.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;    new Vue({        el: '#app',        data: {            msg: 'Hello Word',            imgSrc: 'http://image.luokangyuan.com/1.jpg'        },        methods: {            test1() {                alert(123)            },          test2(content) {                alert(content)            },            test() {                alert(123)            }        }    })&lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><p>绑定事件监听指令的作用就是绑定指定事件名的回调函数，完整写法：<code>v-on:click='xxx'</code>或者<code>v-on:click='xxx(参数)'</code>再或者<code>v-on:click.enter='xxx'</code>，简洁写法就是：<code>@click='xxx'</code>，使用<code>@</code>符号；</p><h2 id="1-4-计算属性和监视"><a href="#1-4-计算属性和监视" class="headerlink" title="1.4.计算属性和监视"></a>1.4.计算属性和监视</h2><pre class="line-numbers language-none"><code class="language-none">计算属性<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在computed属性对象中定义计算属性的方法，在页面中使用<code>{{方法名}}</code>来显示计算的结果；</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      姓：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>姓氏<span class="token punctuation">"</span></span>  <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>firstName<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>      名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>名字<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lastName<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>      姓名1（单向）：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>姓名1<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fullName1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>      姓名2（单向）：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>姓名2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>      姓名3（双向）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>姓名3双向<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/vue.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>        data<span class="token operator">:</span> <span class="token punctuation">{</span>            firstName<span class="token operator">:</span> <span class="token string">'A'</span><span class="token punctuation">,</span>            lastName<span class="token operator">:</span> <span class="token string">'B'</span>            <span class="token comment">//如果将 fullName1写在这个地方，那么改变firstName和lastName的值并不会同时改变fullName1的值</span>            <span class="token comment">// 所以需要使用到计算属性，将fullName1写入computed属性对象中，将方法的返回值作为输出值</span>            <span class="token comment">// fullName1：'A B' </span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        computed<span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token comment">// 这个f方法在初始化会执行，当相关属性发生改变时也会执行</span>            <span class="token function">fullName1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 计算属性中的一个方法，方法的返回值作为属性值</span>                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><pre class="line-numbers language-none"><code class="language-none">计算属性的get和set<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用计算属性实现上述的双向绑定，代码如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      姓：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>姓氏<span class="token punctuation">"</span></span>  <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>firstName<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>      名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>名字<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lastName<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>      姓名3（双向）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>姓名3双向<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fullName3<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/vue.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>        data<span class="token operator">:</span> <span class="token punctuation">{</span>            firstName<span class="token operator">:</span> <span class="token string">'A'</span><span class="token punctuation">,</span>            lastName<span class="token operator">:</span> <span class="token string">'B'</span>            <span class="token comment">// fullName1：'A B' </span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        computed<span class="token operator">:</span> <span class="token punctuation">{</span>            fullName3<span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token comment">// 回调函数：你定义的，你没有调用，但最终他执行了</span>                 <span class="token comment">// 回调函数，当需要读取当前属性值时回调，根据相关的数据计算并返回当前属性的值</span>                <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token comment">// 回调函数，监视当前属性的变化，当属性值发生改变时回调，更新相关的属性数据</span>                <span class="token function">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">const</span> names <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> names<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> names<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><blockquote><p>注意：计算属性存在缓存，多次读取只执行一次getter计算；</p></blockquote><pre class="line-numbers language-none"><code class="language-none">监视<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过vm对象的<code>$watch()方法或者watch配置</code>来监视某一个属性的值是否发生变化，当属性发生变化时，通过执行回调函数来执行相关的功能，下面的代码是使用计算属性完成的同一个功能，</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      姓：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>姓氏<span class="token punctuation">"</span></span>  <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>firstName<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>      名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>名字<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lastName<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>      姓名2（单向）：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>姓名2<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fullName2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>      姓名3（双向）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>姓名3双向<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/vue.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">   <span class="token keyword">var</span> vm <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>        data<span class="token operator">:</span> <span class="token punctuation">{</span>            firstName<span class="token operator">:</span> <span class="token string">'A'</span><span class="token punctuation">,</span>            lastName<span class="token operator">:</span> <span class="token string">'B'</span><span class="token punctuation">,</span>            fullName2<span class="token operator">:</span> <span class="token string">'A B'</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        watch<span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token comment">// 这个方法就是监视firstName，值发生改变是被调用执行函数</span>            <span class="token comment">// 函数可以传入两个参数代表新值和改变之前的值，也可以传一个，也可以不传</span>            <span class="token function-variable function">firstName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token keyword">this</span><span class="token punctuation">.</span>fullName2 <span class="token operator">=</span> value<span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    vm<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token string">'lastName'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>fullName2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> value    <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><h2 id="1-5-class和style绑定"><a href="#1-5-class和style绑定" class="headerlink" title="1.5.class和style绑定"></a>1.5.class和style绑定</h2><p>在某些页面中，某些元素的样式是动态发生变化的，class和style绑定就是用来实现动态改变样式效果的技术，其中class绑定中，表达式可以是字符串，可以是对象，也可以是数组，实例如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>class和style绑定<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">      <span class="token selector">.aClass</span><span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">}</span>      <span class="token selector">.bClass</span><span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">}</span>  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>class绑定<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>我是字符串<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{aClass: isA,bClass: isB}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>我是对象<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--class绑定的是对象。当为true才会留下--&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>style绑定<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">:style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{color: activeColor, fontSize: fontSize+<span class="token punctuation">'</span>px<span class="token punctuation">'</span>}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>我是style强制绑定<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>update<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>更新<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/vue.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>       data<span class="token operator">:</span> <span class="token punctuation">{</span>        a<span class="token operator">:</span> <span class="token string">'aClass'</span><span class="token punctuation">,</span>        isA<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        isB<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">,</span><span class="token comment">// 以上是绑定class</span>        activeColor<span class="token operator">:</span> <span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token comment">// 以下是绑定style</span>        fontSize <span class="token operator">:</span> <span class="token number">20</span>       <span class="token punctuation">}</span><span class="token punctuation">,</span>       methods<span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'bClass'</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>isA <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>isB <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">// 以上是绑定class</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>activeColor <span class="token operator">=</span> <span class="token string">'blue'</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>fontSize <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><h2 id="1-6-条件渲染"><a href="#1-6-条件渲染" class="headerlink" title="1.6.条件渲染"></a>1.6.条件渲染</h2><p>在vue中条件渲染使用<code>v-if</code>、<code>v-else</code>和<code>v-show</code>指令，二者不同的地方在于<code>v-if</code>是不会生成不应该显示的元素，<code>v-show</code>是通过css控制隐藏不应该显示的节点元素，是在页面生成的，当需要频繁的切换时，使用<code>v-show</code>比较好，当条件不成立时，<code>v-is</code>的所有子节点也不会被解析；</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-if</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">'</span>ok<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>显示成功<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-else</span><span class="token punctuation">&gt;</span></span>显示失败<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-show</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">'</span>ok<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>显示成功-v-show<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-show</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">'</span>!ok<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>显示失败-v-show<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>ok=!ok<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>切换<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/vue.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>        data<span class="token operator">:</span> <span class="token punctuation">{</span>            ok<span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><h2 id="1-7-列表渲染"><a href="#1-7-列表渲染" class="headerlink" title="1.7.列表渲染"></a>1.7.列表渲染</h2><p>列表的渲染使用的是<code>v-for</code>指令，可以渲染数组和对象，注意的是遍历的时候指定唯一的index或者key，另外在做数组的删除和更新操作时使用数组的<code>变异方法</code>，有关vue的数组变异方法可以参考官方API；</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>v-for遍历数组<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ui</span><span class="token punctuation">&gt;</span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(u,index) in users<span class="token punctuation">"</span></span> <span class="token attr-name">::key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>             {{index}}===={{u.name}}===={{u.age}}==             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>deleteUser(index)<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>删除<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>==<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>updateUser(index,{name: <span class="token punctuation">'</span>王八<span class="token punctuation">'</span>,age: 45})<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>更新<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ui</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>v-for遍历对象<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(value,key) in users[1]<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>key<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>             {{value}}==={{key}}         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/vue.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>        data<span class="token operator">:</span> <span class="token punctuation">{</span>            users<span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token comment">// vue本身只是监视了users的改变，没有监视数组内部数据的改变</span>                <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'张三'</span><span class="token punctuation">,</span>age<span class="token operator">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'李四'</span><span class="token punctuation">,</span>age<span class="token operator">:</span> <span class="token number">56</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'王五'</span><span class="token punctuation">,</span>age<span class="token operator">:</span> <span class="token number">76</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'赵六'</span><span class="token punctuation">,</span>age<span class="token operator">:</span> <span class="token number">87</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'陈七'</span><span class="token punctuation">,</span>age<span class="token operator">:</span> <span class="token number">34</span><span class="token punctuation">}</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        methods<span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token function">deleteUser</span><span class="token punctuation">(</span><span class="token parameter">index</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>users<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">updateUser</span><span class="token punctuation">(</span><span class="token parameter">index<span class="token punctuation">,</span>value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">// 如果只写 this.users[index] = value这一条语句，只改变了数组内部的数据，如果不调用vue的变异方法，就不会更新页面</span>                <span class="token comment">// vue重写了数组中的一系列方法，重写后就是改变数组操作，然后重新渲染页面，也就是实现的数据绑定</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>users<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span> <span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><pre class="line-numbers language-none"><code class="language-none">列表渲染-列表过滤和排序&lt;body&gt;  &lt;div id="app"&gt;    &lt;input type="text" v-model="searchName"&gt;     &lt;ui&gt;         &lt;li v-for="(u,index) in filterUsers" ::key="index"&gt;             {{index}}===={{u.name}}===={{u.age}}         &lt;/li&gt;     &lt;/ui&gt;     &lt;button @click="setOrderType(1)" &gt;年龄升序&lt;/button&gt;     &lt;button @click="setOrderType(2)"&gt;年龄降序&lt;/button&gt;     &lt;button @click="setOrderType(0)"&gt;原本排序&lt;/button&gt;  &lt;/div&gt;&lt;script src="js/vue.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;    new Vue({        el: '#app',        data: {            searchName: '',            orderType: 0, // 0代表原本，1代表升序，2代表降序            users: [ // vue本身只是监视了users的改变，没有监视数组内部数据的改变                {name: '张三',age: 23},                {name: '李四',age: 56},                {name: '张五',age: 76},                {name: '赵六',age: 87},                {name: '陈七',age: 34}            ]        },        computed: {            filterUsers() {                const {searchName,users,orderType} = this;// 取到相关数据（searchName和users）                let fusers; // 定义最终返回的数组                fusers = users.filter(u =&gt; u.name.indexOf(searchName) !==-1);// 对users进行过滤                // 对fusers排序                if(orderType !== 0){                    fusers.sort(function(u1,u2){ // 如果返回负数p1在前，返回正数p2在前                        // 1.代表升序,2.代表降序                        if(orderType == 2){                            return u2.age - u1.age                        }else{                            return u1.age -u2.age                        }                    })                }                return fusers;            }        },        methods: {            setOrderType(value){                this.orderType = value;            }        }    })&lt;/script&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><h2 id="1-8-事件处理"><a href="#1-8-事件处理" class="headerlink" title="1.8.事件处理"></a>1.8.事件处理</h2><p>在vue中绑定监听使用<code>@xxx='fun'</code>,其中点击函数和传参数和不传参数，默认事件的形参是<code>event</code>,当需要传参的同时需要默认event时候，使用隐含属性对象<code>@xxx = fun(123,$event)</code>；事件有两个修饰符：<code>.prevent</code>：阻止事件的默认事件的默认行为和<code>.stop</code>：停止事件冒泡；按键修饰符使用<code>keyup.keyCode = fun()</code>：keycode是键盘输入对应的ketcode值，可以使用名称，但是存在一部风没有；</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>绑定监听<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test1<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>我是按钮一<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test2(<span class="token punctuation">'</span>Hello 码酱<span class="token punctuation">'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>我是按钮二，我想获取自己传入的值<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test3<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>我是按钮三，我就想获取自己<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test4(<span class="token punctuation">'</span>Hello<span class="token punctuation">'</span>,$event)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>我是按钮四，我想获取获取自己的同时获取传入的值<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>事件修饰符：事件冒泡和事件默认行为<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token style language-css"><span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span> <span class="token property">background</span><span class="token punctuation">:</span> red</span><span class="token punctuation">"</span></span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test5<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>         <span class="token comment">&lt;!-- 使用 @click.stop阻止事件的冒泡--&gt;</span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token style language-css"><span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span> <span class="token property">background</span><span class="token punctuation">:</span> blue</span><span class="token punctuation">"</span></span></span> <span class="token attr-name">@click.stop</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test6<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>     <span class="token comment">&lt;!-- 使用@click.prevent阻止事件的默认行为 --&gt;</span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>luokangyuan.com<span class="token punctuation">"</span></span> <span class="token attr-name">@click.prevent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test7<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>去码酱博客<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>按键修饰符：使用@keyup.13，其中的数字代表键盘每一个输入对应的keycode<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">@keyup.13</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">@keyup.enter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/vue.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>        methods<span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"四川码酱"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">test2</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">alert</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">test3</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">alert</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">test4</span><span class="token punctuation">(</span><span class="token parameter">msg<span class="token punctuation">,</span>event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">alert</span><span class="token punctuation">(</span>msg<span class="token operator">+</span><span class="token string">"==="</span><span class="token operator">+</span>event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"执行了外面的div的点击事件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"执行了里面的div的点击事件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">test7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"不去码酱博客"</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">test8</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">alert</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><h2 id="1-9-表单输入绑定"><a href="#1-9-表单输入绑定" class="headerlink" title="1.9.表单输入绑定"></a>1.9.表单输入绑定</h2><p>表单的数据绑定使用<code>v-model</code>指令，具体相关编码如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/xxx<span class="token punctuation">"</span></span> <span class="token attr-name">@submit.prevent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>handSubmit<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>用户名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userName<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>密码：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pwd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>性别：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wman<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>女<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wman<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>女<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>man<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>男<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>man<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>爱好：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>basket<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>basket<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>likes<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>basket<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>篮球<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footbal<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>foot<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>likes<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footbal<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>足球<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pingpang<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pingpang<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>likes<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pingpang<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>乒乓球<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>城市：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cityId<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>未选择<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>city.id<span class="token punctuation">"</span></span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(city,index) in allCitys<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{city.name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>个人介绍：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">cols</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>30<span class="token punctuation">"</span></span> <span class="token attr-name">rows</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>desc<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>注册<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/vue.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            el<span class="token operator">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>            data<span class="token operator">:</span> <span class="token punctuation">{</span>                userName<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                pwd<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                sex<span class="token operator">:</span> <span class="token string">'男'</span><span class="token punctuation">,</span> <span class="token comment">// 默认选中性别男</span>                likes<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'foot'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 默认选中foot对应的多选框</span>                allCitys<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">"北京"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">"成都"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">"上海"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">"宁波"</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                cityId<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span><span class="token comment">// 这里默认是空，则匹配未选择，如果默认选中成都，则写2即可</span>                desc<span class="token operator">:</span> <span class="token string">''</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            methods<span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token function">handSubmit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>userName<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>pwd<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sex<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>likes<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cityId<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>desc<span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><h2 id="1-10-Vue的生命周期"><a href="#1-10-Vue的生命周期" class="headerlink" title="1.10.Vue的生命周期"></a>1.10.Vue的生命周期</h2><p><img src="http://image.luokangyuan.com/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE.png" alt="img"></p><p>常用的生命周期方法：<code>create()/mounted()</code>:常用于发送Ajax请求启动定时器等异步任务，<code>beforeDestory()</code>：常用于做一些收尾工作，例如关闭定时器；</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>destoryVm<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>点击我取消Vue实例<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-show</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>isShow<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>我是四川码酱<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/vue.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            el<span class="token operator">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>            data<span class="token operator">:</span> <span class="token punctuation">{</span>                isShow<span class="token operator">:</span> <span class="token boolean">true</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我是beforeCreate方法，我被执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我是created方法，我被执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">beforeMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我是beforeMount方法，我被执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 初始化显示之后立即调用，也是执行一次</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>intervalId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"====="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>isShow <span class="token operator">=</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>isShow<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">beforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我是beforeUpdate方法，我被执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">updated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我是updated方法，我被执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">beforeDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 死亡之前回调一次</span>                <span class="token comment">// 清除定时器</span>                <span class="token function">clearInterval</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>intervalId<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token function">destroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我是destroyed方法，我被执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            methods<span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token function">destoryVm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><blockquote><p>说明：<code>beforeCreate、created、beforeMount、mounted</code>初始化方法只执行一次，<code>beforeUpdate、updated</code>执行多次，<code>beforeDestroy、destroyed</code>死亡方法，也执行一次；</p></blockquote><h2 id="1-11-过渡和动画"><a href="#1-11-过渡和动画" class="headerlink" title="1.11.过渡和动画"></a>1.11.过渡和动画</h2><p>在vue中动画就是操作css的trasition或者animation属性，vue会给目标元素添加和移除指定的class，只不过要遵循一定的命名规则，</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>动画和过渡<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">        <span class="token comment">/* 指定显示和隐藏的过渡效果 */</span>        <span class="token selector">.fade-enter-active,        .fade-leave-active</span> <span class="token punctuation">{</span>            <span class="token property">transition</span><span class="token punctuation">:</span> opacity 1s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/* 指定隐藏的样式 */</span>        <span class="token selector">.fade-enter,        .fade-leave-to</span> <span class="token punctuation">{</span>            <span class="token property">opacity</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/* 指定显示的过滤效果 */</span>        <span class="token selector">.move-enter-active</span> <span class="token punctuation">{</span>            <span class="token property">transition</span><span class="token punctuation">:</span> all 1s        <span class="token punctuation">}</span>        <span class="token comment">/* 指定隐藏的过滤效果 */</span>        <span class="token selector">.move-leave-active</span> <span class="token punctuation">{</span>            <span class="token property">transition</span><span class="token punctuation">:</span> all 3s        <span class="token punctuation">}</span>        <span class="token comment">/* 指定隐藏的样式 */</span>        <span class="token selector">.move-enter,        .move-leave-to</span> <span class="token punctuation">{</span>            <span class="token property">opacity</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>            <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateX</span><span class="token punctuation">(</span>20px<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isshow = !isshow<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>动画按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fade<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isshow<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>四川码酱<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isshow = !isshow<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>多属性动画按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>move<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isshow<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>四川码酱<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/vue.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            el<span class="token operator">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>            <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token punctuation">{</span>                    isshow<span class="token operator">:</span> <span class="token boolean">true</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            el<span class="token operator">:</span> <span class="token string">"#app1"</span><span class="token punctuation">,</span>            <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token punctuation">{</span>                    isshow<span class="token operator">:</span> <span class="token boolean">true</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><h2 id="1-12-过滤器"><a href="#1-12-过滤器" class="headerlink" title="1.12.过滤器"></a>1.12.过滤器</h2><p>在vue中允许自定义过滤器，所谓过滤器就是：<code>对要显示的数据进行特定格式化后在显示，例如时间格式化等</code>，注意的是：<code>并没有改变原本的数据，只是产生新的对应数据</code>；</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>当前完整时间为：{{data | dateString}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>当前日期为：{{data | dateString('YYYY-MM-DD')}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>当前时间为：{{data | dateString('HH:mm:ss')}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/vue.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/moment.js/2.22.1/moment.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token comment">// 自定义过滤器</span>        Vue<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token string">'dateString'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span>format</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">moment</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>format <span class="token operator">||</span> <span class="token string">'YYYY-MM-DD HH:mm:ss'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            el<span class="token operator">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>            data<span class="token operator">:</span> <span class="token punctuation">{</span>                data<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><h2 id="1-13-内置指令和自定义指令"><a href="#1-13-内置指令和自定义指令" class="headerlink" title="1.13.内置指令和自定义指令"></a>1.13.内置指令和自定义指令</h2><pre class="line-numbers language-none"><code class="language-none">常用的内置指令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>v:text : 更新元素的 textContent</li><li>v-html : 更新元素的 innerHTML</li><li>v-if : 如果为 true, 当前标签才会输出到页面</li><li>v-else: 如果为 false, 当前标签才会输出到页面</li><li>v-show : 通过控制 display 样式来控制显示/隐藏</li><li>v-for : 遍历数组/对象</li><li>v-on : 绑定事件监听, 一般简写为@</li><li>v-bind : 强制绑定解析表达式, 可以省略 v-bind</li><li>v-model : 双向数据绑定</li><li>ref : 指定唯一标识, vue 对象通过$els 属性访问这个元素对象</li><li>v-cloak : 防止闪现出现<code>{{xxx}}</code>, 与 css 配合: [v-cloak] { display: none }</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>内置指令<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">        <span class="token selector">[v-cloak]</span> <span class="token punctuation">{</span>            <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>四川码酱<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>hint<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>提示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-cloak</span><span class="token punctuation">&gt;</span></span>{{msg}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/vue.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            el<span class="token operator">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>            data<span class="token operator">:</span> <span class="token punctuation">{</span>                msg<span class="token operator">:</span> <span class="token string">"Hello 四川码酱"</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            methods<span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token function">hint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>content<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><blockquote><p>说明： <code>v-cloak</code>指令是为了页面加载数据缓慢时候显示<code>{{xxx}}</code>标签而出了一个指令，与CSS搭配使用</p></blockquote><pre class="line-numbers language-none"><code class="language-none">自定义指令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注册全局指令，方法如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'my-directive'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding</span><span class="token punctuation">)</span><span class="token punctuation">{</span>el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> binding<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">toupperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>JavaScript</p><p>注册局部指令，方法如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">directives <span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token string">'my-directive'</span> <span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token function">bind</span> <span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> binding<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">toupperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JavaScript</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-upper-text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-lower-text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/vue.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">         <span class="token comment">// 定义全局指令</span>         <span class="token comment">// el：指令属性所在的标签属性</span>         <span class="token comment">// binding：包含指令相关信息数据的对象</span>        Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'upper-text'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span>binding</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            el<span class="token punctuation">.</span>textContent <span class="token operator">=</span> binding<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span>binding<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            el<span class="token operator">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>            data<span class="token operator">:</span> <span class="token punctuation">{</span>                msg<span class="token operator">:</span> <span class="token string">"This is my think life"</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            directives<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// 使用自定义局部指令</span>                <span class="token string">'lower-text'</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span>binding</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    el<span class="token punctuation">.</span>textContent <span class="token operator">=</span> binding<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><h2 id="1-14-核心知识总结"><a href="#1-14-核心知识总结" class="headerlink" title="1.14.核心知识总结"></a>1.14.核心知识总结</h2><ul><li>Vue是前端开发库，用于构建用户界面，遵循MVVM模式，编码简洁，体积小，效率高，包含了一些列插件库；</li><li>基本使用：引入vue.js，创建vue实例对象，其中el代表dom标签选择器，data代表初始化数据对象；</li><li><code>el</code>：指定dom标签容器的选择器，一般写一个根标签；</li><li><code>data</code>：对象或者函数类型，指定初始化状态属性数据的对象，页面中可以使用<code>{{xxx}}</code>直接访问</li><li><code>methods</code>：包含多个方法的对象，供页面中的事件指令来回调，回调函数默认有<code>$event</code>参数，也可以指定自己的参数，在方法中，访问data中的属性直接使用<code>this.xxx</code>；</li><li><code>computed</code>：计算属性，包含多个方法的对象，对状态属性进行计算处理后返回给页面一个新的数据，使用get和set方法实现属性的计算读取，同时监视数据的变化；</li><li><code>watch</code>：监视，包含多个属性监视的对象，<code>xxx.function(value){}</code>，可以传入两个参数，代表新值和改变前的值，也可以使用<code>vm.$watch('xxx', function(value){})</code>的方式添加监听；</li><li>vue中的过渡和动画，实质就是vue操作css的transition/animation属性；</li><li>生命周期：常用的钩子函数是<code>created() / mounted()</code>: 启动异步任务(启动定时器,发送ajax请求, 绑定监听)和<code>beforeDestroy()</code>: 做一些收尾的工作例如清除定时器等；</li><li>自定义过滤器：使用的是<code>Vue.filter(filterName,function(value){})</code>，在页面使用方法：<code>{{myData | filterName(arg)}}</code>，参数可传可不传；</li><li>vue内置指令：<code>v-for遍历</code>、<code>@绑定事件</code>、<code>v-model数据双向绑定</code>、<code>ref标识标签</code>；</li><li>自定义指令：使用<code>Vue.directive</code>注册全局指令，使用<code>directives</code>注册局部指令；</li></ul><blockquote><p>注意：数据在哪个组件，更新数据的行为（方法）就应该定义在那个组件中</p></blockquote><h1 id="二、Vue组件化编码方式"><a href="#二、Vue组件化编码方式" class="headerlink" title="二、Vue组件化编码方式"></a>二、Vue组件化编码方式</h1><h2 id="2-1-使用vue-cli创建模板项目"><a href="#2-1-使用vue-cli创建模板项目" class="headerlink" title="2.1.使用vue-cli创建模板项目"></a>2.1.使用vue-cli创建模板项目</h2><p>vue-cli是vue官方提供的脚手架工具，首先确认安装了node和npm，最好安装一个cnpm，使用方法如下：</p><ul><li>npm install -g vue-cli</li><li>vue init webpack vue_demo 其中 vue_demo是项目名</li><li>cd vue_demo</li><li>npm install或者npm run dev</li></ul><pre class="line-numbers language-none"><code class="language-none">项目结构说明<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>build : webpack 相关的配置文件夹(基本不需要修改)<ul><li>dev-server.js : 通过 express 启动后台服务器</li></ul></li><li>config: webpack 相关的配置文件夹(基本不需要修改)<ul><li>index.js: 指定的后台服务的端口号和静态资源文件夹</li></ul></li><li>src : 源码文件夹<ul><li>components: vue 组件及其相关资源文件夹</li><li>App.vue: 应用根主组件</li><li>main.js: 应用入口 js</li></ul></li><li>static: 静态资源文件夹</li><li>.babelrc: babel 的配置文件</li><li>.eslintignore: eslint 检查忽略的配置</li><li>.eslintrc.js: eslint 检查的配置</li><li>.gitignore: git 版本管制忽略的配置</li><li>index.html: 主页面文件</li><li>package.json: 应用包配置文件</li><li>README.md: 应用描述说明的 readme 文件</li></ul><pre class="line-numbers language-none"><code class="language-none">简单的使用Vue模板项目<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先，我们编写了一个HelloWord的组件，</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{ msg }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token comment">// 配置对象和Vue一致</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// data可以 写对象和函数，但是在组件中必须使用函数</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            msg<span class="token operator">:</span> <span class="token string">"Hello Welcome to My Vue"</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">.msg</span> <span class="token punctuation">{</span>        <span class="token property">color</span><span class="token punctuation">:</span> red    <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><p>然后，我们在App.vue中使用我们自己定义的组件</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>logo<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./assets/logo.png<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 使用组件标签 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>HelloWorld</span><span class="token punctuation">/&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token comment">// 1.引入需要使用的vue组件（HelloWoed组件）</span><span class="token keyword">import</span> HelloWorld <span class="token keyword">from</span> <span class="token string">'./components/HelloWorld'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  components<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// 2.映射组件标签</span>    HelloWorld  <span class="token punctuation">}</span><span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css"><span class="token selector">.logo</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML</p><p>我们知道使用Webpack打包后会生成一个js文件，也就是入口文件main.js</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App'</span>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span> <span class="token comment">// 挂载到入口Dom节点（index.html）</span>  components<span class="token operator">:</span> <span class="token punctuation">{</span> App <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 映射组件标签</span>  template<span class="token operator">:</span> <span class="token string">'&lt;App/&gt;'</span> <span class="token comment">//使用标签</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JavaScript</p><h2 id="2-2-项目打包发布方式"><a href="#2-2-项目打包发布方式" class="headerlink" title="2.2.项目打包发布方式"></a>2.2.项目打包发布方式</h2><p>打包命令：<code>npm run build</code></p><p>使用静态服务器：安装命令：<code>npm install -g serve</code>，发布命令：<code>serve dist</code>，然后直接访问就可以了</p><p>使用动态web服务器（Tomcat）:修改webpack.prod.conf.js，加入<code>output: {publicPath: '/xxx/' //打包文件夹的名称}</code>，然后重新打包，将dis文件夹的名称改为项目名称，放在tomcat的webapp目录下，访问即可；</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Vue </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python django中restful框架的使用</title>
      <link href="/2020/11/22/django-zhong-restful-kuang-jia-de-shi-yong/"/>
      <url>/2020/11/22/django-zhong-restful-kuang-jia-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p><b><span style="color:#FF4500;">写在最前面：本文章所有内容是本人从网络整理而得，并非商用，仅供学习交流使用。</span></b></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在使用django进行前后台分离开发时通常会搭配<code>django-rest-framework</code>框架创建RESTful风格的接口API。框架介绍及版本要求可参考官方地址：<a href="https://www.django-rest-framework.org/">https://www.django-rest-framework.org</a></p><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/Creating-Python-APIs-Like-a-BOSS-The-Django-REST-Framework-Course.jpg" alt="Creating-Python-APIs-Like-a-BOSS-The-Django-REST-Framework-Course"></p><p>本文以创建<code>man</code>包含<code>name</code>、<code>sex</code>字段的API为实例学习<code>django-rest-framework</code>框架的使用。</p><p>主要包含下面5个步骤：</p><ol><li>创建Django项目</li><li>创建ORM模型</li><li>加载Django REST Framework</li><li>序列化模型</li><li>创建加载数据的view和url</li></ol><hr><h3 id="1-创建Django项目"><a href="#1-创建Django项目" class="headerlink" title="1.创建Django项目"></a>1.创建Django项目</h3><p>创建django_rest</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">django-admin startproject django_rest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入django_rest，创建虚拟环境env</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">virtualenv env<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>激活虚拟环境,并安装django</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">source ./env/bin/activate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 django</p><pre class="line-numbers language-none"><code class="language-none">pip install django<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建rest_app</p><pre class="line-numbers language-none"><code class="language-none">python manage.py startapp rest_app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注册app，将app添加到INSTALLED_APPS</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#setting.py</span>INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.contrib.admin'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.contenttypes'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.sessions'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.messages'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.staticfiles'</span><span class="token punctuation">,</span>    <span class="token string">'rest_app'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建后台admin账户用于管理</p><pre class="line-numbers language-none"><code class="language-none">$ python manage.py createsuperuserUsername (leave blank to use 'root'):admin Email address: Password: Password (again): Superuser created successfully.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2-创建ORM模型"><a href="#2-创建ORM模型" class="headerlink" title="2.创建ORM模型"></a>2.创建ORM模型</h3><p>数据库我们使用默认sqlite3 即可，如需要变更可在setting.py中databases配置。</p><p>修改我们/django_rest/models.py添加我们<code>man</code>的模型</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#models.py</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models<span class="token comment"># Create your models here.</span><span class="token keyword">class</span> <span class="token class-name">Man</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span>    sex <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>做数据库迁移</p><pre class="line-numbers language-none"><code class="language-none">python manage.py makemigrations python manage.py migrate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/image-20210621160708390.png" alt="image-20210621160708390"></p><p>将Man这个model注册到我们的后台，以便可以通过django的后台做增删查改，编写admin.py如下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#admin.py</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> <span class="token punctuation">.</span>models <span class="token keyword">import</span> Man<span class="token comment"># Register your models here.</span>admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>register<span class="token punctuation">(</span>Man<span class="token punctuation">)</span>  <span class="token comment"># 注册Man到后台</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动django服务</p><pre class="line-numbers language-none"><code class="language-none">python manage.py runserver<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>访问 <a href="http://127.0.0.1:8000/admin/%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%EF%BC%8C%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95">http://127.0.0.1:8000/admin/可以看到登录界面，输入密码登录</a></p><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/image-20210621162254044.png" alt="image-20210621162254044"></p><p>可以看到我们的rest_app下的模型man对象mans</p><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/image-20210621163034920.png" alt="image-20210621163034920"></p><p>我们添加一个那个男人lgd.ame</p><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/image-20210621163158979.png" alt="image-20210621163158979"></p><hr><h3 id="3-加载Django-REST-Framework"><a href="#3-加载Django-REST-Framework" class="headerlink" title="3. 加载Django REST Framework"></a>3. 加载Django REST Framework</h3><p>安装工具包</p><pre class="line-numbers language-none"><code class="language-none">pip install djangorestframework<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注册rest_framework</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#setting.py</span>INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.contrib.admin'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.contenttypes'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.sessions'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.messages'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.staticfiles'</span><span class="token punctuation">,</span>    <span class="token string">'rest_app'</span>    <span class="token string">'rest_framework'</span> <span class="token comment">#注册</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-序列化模型"><a href="#4-序列化模型" class="headerlink" title="4.序列化模型"></a>4.序列化模型</h3><p>序列化器会把我们的模型数据转化（序列化）为json格式，这样就能够被请求了。同样当有josn数据提交过来的时候，序列化器会将json数据转换为模型供咋们使用。</p><p>我们在rest_app下创建文件serializer.py</p><p>我们要做三件事：</p><ol><li>导入Man模型</li><li>导入序REST Framework序列化器</li><li>创建新的类将模型和序列化器链接起来</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> rest_framework <span class="token keyword">import</span> serializers<span class="token keyword">from</span> <span class="token punctuation">.</span>models <span class="token keyword">import</span> Man<span class="token keyword">class</span> <span class="token class-name">Manserializer</span><span class="token punctuation">(</span>serializers<span class="token punctuation">.</span>HyperlinkedModelSerializer<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>        model <span class="token operator">=</span> Man        fields <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'sex'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-创建加载数据的view和url"><a href="#5-创建加载数据的view和url" class="headerlink" title="5.创建加载数据的view和url"></a>5.创建加载数据的view和url</h3><p>我们需要把序列化后的数据返回给浏览器，所以要做一下步骤：</p><ol><li>通过Man查询数据库</li><li>将查询后的数据传递给序列化器，通过序列化器转化为json</li></ol><p>我们在rest_app/views.py编写我们的视图,<code>ModelViewSet</code>由rest_framework提供，包含了get、post方法</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># views.py</span><span class="token keyword">from</span> rest_framework <span class="token keyword">import</span> viewsets<span class="token keyword">from</span> <span class="token punctuation">.</span>serializers <span class="token keyword">import</span> ManSerializer<span class="token keyword">from</span> <span class="token punctuation">.</span>models <span class="token keyword">import</span> Man<span class="token keyword">class</span> <span class="token class-name">ManViewSet</span><span class="token punctuation">(</span>viewsets<span class="token punctuation">.</span>ModelViewSet<span class="token punctuation">)</span><span class="token punctuation">:</span>    queryset <span class="token operator">=</span> Man<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>order_by<span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>  <span class="token comment">#查询结果给queryset</span>    serializer_class <span class="token operator">=</span> ManSerializer     <span class="token comment">#对结果进序列化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在django_rest目录下urls.py添加api路由</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> path<span class="token punctuation">,</span> includeurlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    path<span class="token punctuation">(</span><span class="token string">'admin/'</span><span class="token punctuation">,</span> admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>urls<span class="token punctuation">)</span><span class="token punctuation">,</span>    path<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> include<span class="token punctuation">(</span><span class="token string">'rest_app.urls'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在rest_app目录下创建urls.py添加视图路由，通过rest_framework中router确保我们的请求到正确的动态资源。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> include<span class="token punctuation">,</span> path<span class="token keyword">from</span> rest_framework <span class="token keyword">import</span> routers<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> viewsrouter <span class="token operator">=</span> routers<span class="token punctuation">.</span>DefaultRouter<span class="token punctuation">(</span><span class="token punctuation">)</span>router<span class="token punctuation">.</span>register<span class="token punctuation">(</span><span class="token string">r'man'</span><span class="token punctuation">,</span> views<span class="token punctuation">.</span>ManViewSet<span class="token punctuation">)</span>   <span class="token comment">#路由到ManViewSet视图</span><span class="token comment"># Wire up our API using automatic URL routing.</span><span class="token comment"># Additionally, we include login URLs for the browsable API.</span>urlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    path<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> include<span class="token punctuation">(</span>router<span class="token punctuation">.</span>urls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">#使用router路由</span>    path<span class="token punctuation">(</span><span class="token string">'api-auth/'</span><span class="token punctuation">,</span> include<span class="token punctuation">(</span><span class="token string">'rest_framework.urls'</span><span class="token punctuation">,</span> namespace<span class="token operator">=</span><span class="token string">'rest_framework'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后我们来启动服务,访问<a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> 可以在浏览器查看到我们api信息</p><pre class="line-numbers language-none"><code class="language-none">python manage.py runserver<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/image-20210621182048294.png" alt="image-20210621182048294"></p><p>访问<a href="http://127.0.0.1:8000/man/">http://127.0.0.1:8000/man/</a> 来查看man资源</p><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/image-20210621181859700.png" alt="image-20210621181859700"></p><p>通过id来访问api资源<a href="http://127.0.0.1:8000/man/1/">http://127.0.0.1:8000/man/1/</a></p><p><img src="https://markdown-1257692304.cos.ap-nanjing.myqcloud.com/markdown_img/image-20210621182006651.png" alt="image-20210621182006651"></p><hr><p>这样我们一个基础restful风格的API创建完成了。感觉关键点还是理解<code>ModelViewSet</code>和内置<code>router</code>不读源码很难知其所以然。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> restful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3中最常用的5种线程锁</title>
      <link href="/2020/10/13/python3-zhong-zui-chang-yong-de-5-chong-xian-cheng-suo/"/>
      <url>/2020/10/13/python3-zhong-zui-chang-yong-de-5-chong-xian-cheng-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="Python3中最常用的5种线程锁"><a href="#Python3中最常用的5种线程锁" class="headerlink" title="Python3中最常用的5种线程锁"></a>Python3中最常用的5种线程锁</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章节将继续围绕threading模块讲解，基本上是纯理论偏多。</p><p>对于日常开发者来讲很少会使用到本章节的内容，但是对框架作者等是必备知识，同时也是高频的面试常见问题。</p><p><a href="https://docs.python.org/zh-cn/3.6/library/threading.html">官方文档</a></p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>线程安全是多线程或多进程编程中的一个概念，在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p><p>线程安全的问题最主要还是由线程切换导致的，比如一个房间（进程）中有10颗糖（资源），除此之外还有3个小人（1个主线程、2个子线程），当小人A吃了3颗糖后被系统强制进行休息时他认为还剩下7颗糖，而当小人B工作后又吃掉了3颗糖，那么当小人A重新上岗时会认为糖还剩下7颗，但是实际上只有4颗了。</p><p>上述例子中线程A和线程B的数据不同步，这就是线程安全问题，它可能导致非常严重的意外情况发生，我们按下面这个示例来进行说明。</p><p>下面有一个数值num初始值为0，我们开启2条线程：</p><ul><li>线程1对num进行一千万次+1的操作</li><li>线程2对num进行一千万次-1的操作</li></ul><p>结果可能会令人咋舌，num最后并不是我们所想象的结果0：</p><pre class="line-numbers language-none"><code class="language-none">import threadingnum = 0def add():    global num    for i in range(10_000_000):        num += 1def sub():    global num    for i in range(10_000_000):        num -= 1if __name__ == "__main__":    subThread01 = threading.Thread(target=add)    subThread02 = threading.Thread(target=sub)    subThread01.start()    subThread02.start()    subThread01.join()    subThread02.join()    print("num result : %s" % num)# 结果三次采集# num result : 669214# num result : -1849179# num result : -525674<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这就是一个非常好的案例，想要解决这个问题就必须通过锁来保障线程切换的时机。</p><p>需要我们值得留意的是，在Python基本数据类型中list、tuple、dict本身就是属于线程安全的，所以如果有多个线程对这3种容器做操作时，我们不必考虑线程安全问题。</p><h1 id="锁的作用"><a href="#锁的作用" class="headerlink" title="锁的作用"></a>锁的作用</h1><p>锁是Python提供给我们能够自行操控线程切换的一种手段，使用锁可以让线程的切换变的有序。</p><p>一旦线程的切换变的有序后，各个线程之间对数据的访问、修改就变的可控，所以若要保证线程安全，就必须使用锁。</p><p>threading模块中提供了5种最常见的锁，下面是按照功能进行划分：</p><ul><li>同步锁：lock（一次只能放行一个）</li><li>递归锁：rlock（一次只能放行一个）</li><li>条件锁：condition（一次可以放行任意个）</li><li>事件锁：event（一次全部放行）</li><li>信号量锁：semaphore（一次可以放行特定个）</li></ul><h1 id="Lock-同步锁"><a href="#Lock-同步锁" class="headerlink" title="Lock() 同步锁"></a>Lock() 同步锁</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Lock锁的称呼有很多，如：</p><ul><li>同步锁</li><li>互斥锁</li></ul><p>它们是什么意思呢？如下所示：</p><ol><li>互斥指的是某一资源同一时刻仅能有一个访问者对其进行访问，具有唯一性和排他性，但是互斥无法限制访问者对资源的访问顺序，即访问是无序的</li><li>同步是指在互斥的基础上（大多数情况），通过其他机制实现访问者对资源的有序访问</li><li>同步其实已经实现了互斥，是互斥的一种更为复杂的实现，因为它在互斥的基础上实现了有序访问的特点</li></ol><p>下面是threading模块与同步锁提供的相关方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>threading.Lock()</td><td>返回一个同步锁对象</td></tr><tr><td>lockObject.acquire(blocking=True, timeout=1)</td><td>上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒</td></tr><tr><td>lockObject.release()</td><td>解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行</td></tr><tr><td>lockObject.locaked()</td><td>判断该锁对象是否处于上锁状态，返回一个布尔值</td></tr></tbody></table><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>同步锁一次只能放行一个线程，一个被加锁的线程在运行时不会将执行权交出去，只有当该线程被解锁时才会将执行权通过系统调度交由其他线程。</p><p>如下所示，使用同步锁解决最上面的问题：</p><pre class="line-numbers language-none"><code class="language-none">import threadingnum = 0def add():    lock.acquire()    global num    for i in range(10_000_000):        num += 1    lock.release()def sub():    lock.acquire()    global num    for i in range(10_000_000):        num -= 1    lock.release()if __name__ == "__main__":    lock = threading.Lock()    subThread01 = threading.Thread(target=add)    subThread02 = threading.Thread(target=sub)    subThread01.start()    subThread02.start()    subThread01.join()    subThread02.join()    print("num result : %s" % num)# 结果三次采集# num result : 0# num result : 0# num result : 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样这个代码就完全变成了串行的状态，对于这种计算密集型I/O业务来说，还不如直接使用串行化单线程执行来得快，所以这个例子仅作为一个示例，不能概述锁真正的用途。</p><h2 id="死锁现象"><a href="#死锁现象" class="headerlink" title="死锁现象"></a>死锁现象</h2><p>对于同步锁来说，一次acquire()必须对应一次release()，不能出现连续重复使用多次acquire()后再重复使用多次release()的操作，这样会引起死锁造成程序的阻塞，完全不动了，如下所示：</p><pre class="line-numbers language-none"><code class="language-none">import threadingnum = 0def add():    lock.acquire()  # 上锁    lock.acquire()  # 死锁    # 不执行    global num    for i in range(10_000_000):        num += 1    lock.release()    lock.release()def sub():    lock.acquire()  # 上锁    lock.acquire()  # 死锁    # 不执行    global num    for i in range(10_000_000):        num -= 1    lock.release()    lock.release()if __name__ == "__main__":    lock = threading.Lock()    subThread01 = threading.Thread(target=add)    subThread02 = threading.Thread(target=sub)    subThread01.start()    subThread02.start()    subThread01.join()    subThread02.join()    print("num result : %s" % num)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h2><p>由于threading.Lock()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作：</p><pre class="line-numbers language-none"><code class="language-none">import threadingnum = 0def add():    with lock:        # 自动加锁        global num        for i in range(10_000_000):            num += 1        # 自动解锁def sub():    with lock:        # 自动加锁        global num        for i in range(10_000_000):            num -= 1        # 自动解锁if __name__ == "__main__":    lock = threading.Lock()    subThread01 = threading.Thread(target=add)    subThread02 = threading.Thread(target=sub)    subThread01.start()    subThread02.start()    subThread01.join()    subThread02.join()    print("num result : %s" % num)    # 结果三次采集# num result : 0# num result : 0# num result : 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="RLock-递归锁"><a href="#RLock-递归锁" class="headerlink" title="RLock() 递归锁"></a>RLock() 递归锁</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>递归锁是同步锁的一个升级版本，在同步锁的基础上可以做到连续重复使用多次acquire()后再重复使用多次release()的操作，但是一定要注意加锁次数和解锁次数必须一致，否则也将引发死锁现象。</p><p>下面是threading模块与递归锁提供的相关方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>threading.RLock()</td><td>返回一个递归锁对象</td></tr><tr><td>lockObject.acquire(blocking=True, timeout=1)</td><td>上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒</td></tr><tr><td>lockObject.release()</td><td>解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行</td></tr><tr><td>lockObject.locaked()</td><td>判断该锁对象是否处于上锁状态，返回一个布尔值</td></tr></tbody></table><h2 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h2><p>以下是递归锁的简单使用，下面这段操作如果使用同步锁则会发生死锁现象，但是递归锁不会：</p><pre class="line-numbers language-none"><code class="language-none">import threadingnum = 0def add():    lock.acquire()    lock.acquire()    global num    for i in range(10_000_000):        num += 1    lock.release()    lock.release()def sub():    lock.acquire()    lock.acquire()    global num    for i in range(10_000_000):        num -= 1    lock.release()    lock.release()if __name__ == "__main__":    lock = threading.RLock()    subThread01 = threading.Thread(target=add)    subThread02 = threading.Thread(target=sub)    subThread01.start()    subThread02.start()    subThread01.join()    subThread02.join()    print("num result : %s" % num)# 结果三次采集# num result : 0# num result : 0# num result : 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="with语句-1"><a href="#with语句-1" class="headerlink" title="with语句"></a>with语句</h2><p>由于threading.RLock()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作：</p><pre class="line-numbers language-none"><code class="language-none">import threadingnum = 0def add():    with lock:        # 自动加锁        global num        for i in range(10_000_000):            num += 1        # 自动解锁def sub():    with lock:        # 自动加锁        global num        for i in range(10_000_000):            num -= 1        # 自动解锁if __name__ == "__main__":    lock = threading.RLock()    subThread01 = threading.Thread(target=add)    subThread02 = threading.Thread(target=sub)    subThread01.start()    subThread02.start()    subThread01.join()    subThread02.join()    print("num result : %s" % num)# 结果三次采集# num result : 0# num result : 0# num result : 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Condition-条件锁"><a href="#Condition-条件锁" class="headerlink" title="Condition() 条件锁"></a>Condition() 条件锁</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>条件锁是在递归锁的基础上增加了能够暂停线程运行的功能。并且我们可以使用wait()与notify()来控制线程执行的个数。</p><p>注意：条件锁可以自由设定一次放行几个线程。</p><p>下面是threading模块与条件锁提供的相关方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>threading.Condition()</td><td>返回一个条件锁对象</td></tr><tr><td>lockObject.acquire(blocking=True, timeout=1)</td><td>上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒</td></tr><tr><td>lockObject.release()</td><td>解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行</td></tr><tr><td>lockObject.wait(timeout=None)</td><td>将当前线程设置为“等待”状态，只有该线程接到“通知”或者超时时间到期之后才会继续运行，在“等待”状态下的线程将允许系统根据策略自行切换到其他线程中运行</td></tr><tr><td>lockObject.wait_for(predicate, timeout=None)</td><td>将当前线程设置为“等待”状态，只有该线程的predicate返回一个True或者超时时间到期之后才会继续运行，在“等待”状态下的线程将允许系统根据策略自行切换到其他线程中运行。注意：predicate参数应当传入一个可调用对象，且返回结果为bool类型</td></tr><tr><td>lockObject.notify(n=1)</td><td>通知一个当前状态为“等待”的线程继续运行，也可以通过参数n通知多个</td></tr><tr><td>lockObject.notify_all()</td><td>通知所有当前状态为“等待”的线程继续运行</td></tr></tbody></table><h2 id="使用方式-2"><a href="#使用方式-2" class="headerlink" title="使用方式"></a>使用方式</h2><p>下面这个案例会启动10个子线程，并且会立即将10个子线程设置为等待状态。</p><p>然后我们可以发送一个或者多个通知，来恢复被等待的子线程继续运行：</p><pre class="line-numbers language-none"><code class="language-none">import threadingcurrentRunThreadNumber = 0maxSubThreadNumber = 10def task():    global currentRunThreadNumber    thName = threading.currentThread().name    condLock.acquire()  # 上锁    print("start and wait run thread : %s" % thName)    condLock.wait()  # 暂停线程运行、等待唤醒    currentRunThreadNumber += 1    print("carry on run thread : %s" % thName)    condLock.release()  # 解锁if __name__ == "__main__":    condLock = threading.Condition()    for i in range(maxSubThreadNumber):        subThreadIns = threading.Thread(target=task)        subThreadIns.start()    while currentRunThreadNumber &lt; maxSubThreadNumber:        notifyNumber = int(            input("Please enter the number of threads that need to be notified to run："))        condLock.acquire()        condLock.notify(notifyNumber)  # 放行        condLock.release()    print("main thread run end")    # 先启动10个子线程，然后这些子线程会全部变为等待状态# start and wait run thread : Thread-1# start and wait run thread : Thread-2# start and wait run thread : Thread-3# start and wait run thread : Thread-4# start and wait run thread : Thread-5# start and wait run thread : Thread-6# start and wait run thread : Thread-7# start and wait run thread : Thread-8# start and wait run thread : Thread-9# start and wait run thread : Thread-10# 批量发送通知，放行特定数量的子线程继续运行# Please enter the number of threads that need to be notified to run：5  # 放行5个# carry on run thread : Thread-4# carry on run thread : Thread-3# carry on run thread : Thread-1# carry on run thread : Thread-2# carry on run thread : Thread-5# Please enter the number of threads that need to be notified to run：5  # 放行5个# carry on run thread : Thread-8# carry on run thread : Thread-10# carry on run thread : Thread-6# carry on run thread : Thread-9# carry on run thread : Thread-7# Please enter the number of threads that need to be notified to run：1# main thread run end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="with语句-2"><a href="#with语句-2" class="headerlink" title="with语句"></a>with语句</h2><p>由于threading.Condition()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作：</p><pre class="line-numbers language-none"><code class="language-none">import threadingcurrentRunThreadNumber = 0maxSubThreadNumber = 10def task():    global currentRunThreadNumber    thName = threading.currentThread().name    with condLock:        print("start and wait run thread : %s" % thName)        condLock.wait()  # 暂停线程运行、等待唤醒        currentRunThreadNumber += 1        print("carry on run thread : %s" % thName)if __name__ == "__main__":    condLock = threading.Condition()    for i in range(maxSubThreadNumber):        subThreadIns = threading.Thread(target=task)        subThreadIns.start()    while currentRunThreadNumber &lt; maxSubThreadNumber:        notifyNumber = int(            input("Please enter the number of threads that need to be notified to run："))        with condLock:            condLock.notify(notifyNumber)  # 放行    print("main thread run end")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Event-事件锁"><a href="#Event-事件锁" class="headerlink" title="Event() 事件锁"></a>Event() 事件锁</h1><h2 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>事件锁是基于条件锁来做的，它与条件锁的区别在于一次只能放行全部，不能放行任意个数量的子线程继续运行。</p><p>我们可以将事件锁看为红绿灯，当红灯时所有子线程都暂停运行，并进入“等待”状态，当绿灯时所有子线程都恢复“运行”。</p><p>下面是threading模块与事件锁提供的相关方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>threading.Event()</td><td>返回一个事件锁对象</td></tr><tr><td>lockObject.clear()</td><td>将事件锁设为红灯状态，即所有线程暂停运行</td></tr><tr><td>lockObject.is_set()</td><td>用来判断当前事件锁状态，红灯为False，绿灯为True</td></tr><tr><td>lockObject.set()</td><td>将事件锁设为绿灯状态，即所有线程恢复运行</td></tr><tr><td>lockObject.wait(timeout=None)</td><td>将当前线程设置为“等待”状态，只有该线程接到“绿灯通知”或者超时时间到期之后才会继续运行，在“等待”状态下的线程将允许系统根据策略自行切换到其他线程中运行</td></tr></tbody></table><h2 id="使用方式-3"><a href="#使用方式-3" class="headerlink" title="使用方式"></a>使用方式</h2><p>事件锁不能利用with语句来进行使用，只能按照常规方式。</p><p>如下所示，我们来模拟线程和红绿灯的操作，红灯停，绿灯行：</p><pre class="line-numbers language-none"><code class="language-none">import threadingmaxSubThreadNumber = 3def task():    thName = threading.currentThread().name    print("start and wait run thread : %s" % thName)    eventLock.wait()  # 暂停运行，等待绿灯    print("green light, %s carry on run" % thName)    print("red light, %s stop run" % thName)    eventLock.wait()  # 暂停运行，等待绿灯    print("green light, %s carry on run" % thName)    print("sub thread %s run end" % thName)if __name__ == "__main__":    eventLock = threading.Event()    for i in range(maxSubThreadNumber):        subThreadIns = threading.Thread(target=task)        subThreadIns.start()    eventLock.set()  # 设置为绿灯    eventLock.clear()  # 设置为红灯    eventLock.set()  # 设置为绿灯# start and wait run thread : Thread-1# start and wait run thread : Thread-2# start and wait run thread : Thread-3# green light, Thread-1 carry on run# red light, Thread-1 stop run# green light, Thread-1 carry on run# sub thread Thread-1 run end# green light, Thread-3 carry on run# red light, Thread-3 stop run# green light, Thread-3 carry on run# sub thread Thread-3 run end# green light, Thread-2 carry on run# red light, Thread-2 stop run# green light, Thread-2 carry on run# sub thread Thread-2 run end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Semaphore-信号量锁"><a href="#Semaphore-信号量锁" class="headerlink" title="Semaphore() 信号量锁"></a>Semaphore() 信号量锁</h1><h2 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>信号量锁也是根据条件锁来做的，它与条件锁和事件锁的区别如下：</p><ul><li>条件锁：一次可以放行任意个处于“等待”状态的线程</li><li>事件锁：一次可以放行全部的处于“等待”状态的线程</li><li>信号量锁：通过规定，成批的放行特定个处于“上锁”状态的线程</li></ul><p>下面是threading模块与信号量锁提供的相关方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>threading.Semaphore()</td><td>返回一个信号量锁对象</td></tr><tr><td>lockObject.acquire(blocking=True, timeout=1)</td><td>上锁，当一个线程在执行被上锁代码块时，将不允许切换到其他线程运行，默认锁失效时间为1秒</td></tr><tr><td>lockObject.release()</td><td>解锁，当一个线程在执行未被上锁代码块时，将允许系统根据策略自行切换到其他线程中运行</td></tr></tbody></table><h2 id="使用方式-4"><a href="#使用方式-4" class="headerlink" title="使用方式"></a>使用方式</h2><p>以下是使用示例，你可以将它当做一段限宽的路段，每次只能放行相同数量的线程：</p><pre class="line-numbers language-none"><code class="language-none">import threadingimport timemaxSubThreadNumber = 6def task():    thName = threading.currentThread().name    semaLock.acquire()    print("run sub thread %s" % thName)    time.sleep(3)    semaLock.release()if __name__ == "__main__":    # 每次只能放行2个    semaLock = threading.Semaphore(2)    for i in range(maxSubThreadNumber):        subThreadIns = threading.Thread(target=task)        subThreadIns.start()# run sub thread Thread-1# run sub thread Thread-2# run sub thread Thread-3# run sub thread Thread-4# run sub thread Thread-6# run sub thread Thread-5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="with语句-3"><a href="#with语句-3" class="headerlink" title="with语句"></a>with语句</h2><p>由于threading.Semaphore()对象中实现了__enter__()与__exit__()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作：</p><pre class="line-numbers language-none"><code class="language-none">import threadingimport timemaxSubThreadNumber = 6def task():    thName = threading.currentThread().name    with semaLock:        print("run sub thread %s" % thName)        time.sleep(3)if __name__ == "__main__":    semaLock = threading.Semaphore(2)    for i in range(maxSubThreadNumber):        subThreadIns = threading.Thread(target=task)        subThreadIns.start()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="锁关系浅析"><a href="#锁关系浅析" class="headerlink" title="锁关系浅析"></a>锁关系浅析</h1><p>上面5种锁可以说都是基于同步锁来做的，这些你都可以从源码中找到答案。</p><p>首先来看RLock递归锁，递归锁的实现非常简单，它的内部会维护着一个计数器，当计数器不为0的时候该线程不能被I/O操作和时间轮询机制切换。但是当计数器为0的时候便不会如此了：</p><pre class="line-numbers language-none"><code class="language-none">def __init__(self):    self._block = _allocate_lock()    self._owner = None    self._count = 0  # 计数器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>而Condition条件锁的内部其实是有两把锁的，一把底层锁（同步锁）一把高级锁(递归锁)。</p><p>低层锁的解锁方式有两种，使用wait()方法会暂时解开底层锁同时加上一把高级锁，只有当接收到别的线程里的notfiy()后才会解开高级锁和重新上锁低层锁，也就是说条件锁底层是根据同步锁和递归锁的不断切换来进行实现的：</p><pre class="line-numbers language-none"><code class="language-none">def __init__(self, lock=None):    if lock is None:        lock = RLock()  # 可以看到条件锁的内部是基于递归锁，而递归锁又是基于同步锁来做的    self._lock = lock    self.acquire = lock.acquire    self.release = lock.release    try:        self._release_save = lock._release_save    except AttributeError:        pass    try:        self._acquire_restore = lock._acquire_restore    except AttributeError:        pass    try:        self._is_owned = lock._is_owned    except AttributeError:        pass    self._waiters = _deque()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Event事件锁内部是基于条件锁来做的：</p><pre class="line-numbers language-none"><code class="language-none">class Event:    def __init__(self):        self._cond = Condition(Lock())  # 实例化出了一个条件锁。        self._flag = False    def _reset_internal_locks(self):        # private!  called by Thread._reset_internal_locks by _after_fork()        self._cond.__init__(Lock())    def is_set(self):        """Return true if and only if the internal flag is true."""        return self._flag    isSet = is_set<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Semaphore信号量锁内部也是基于条件锁来做的：</p><pre class="line-numbers language-none"><code class="language-none">class Semaphore:    def __init__(self, value=1):        if value &lt; 0:            raise ValueError("semaphore initial value must be &gt;= 0")        self._cond = Condition(Lock()) # 可以看到，这里是实例化出了一个条件锁        self._value = value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="基本练习题"><a href="#基本练习题" class="headerlink" title="基本练习题"></a>基本练习题</h1><h2 id="条件锁的应用"><a href="#条件锁的应用" class="headerlink" title="条件锁的应用"></a>条件锁的应用</h2><p>需求：一个空列表，两个线程轮番往里面加值（一个加偶数，一个加奇数），最终让该列表中的值为 1 - 100 ，且是有序排列的。</p><pre class="line-numbers language-none"><code class="language-none">import threadinglst = []def even():    """加偶数"""    with condLock:        for i in range(2, 101, 2):            # 判断当前列表的长度处于2是否能处尽            # 如果能处尽则代表需要添加奇数            # 否则就添加偶数            if len(lst) % 2 != 0:                # 添偶数                lst.append(i)      # 先添加值                condLock.notify()  # 告诉另一个线程，你可以加奇数了，但是这里不会立即交出执行权                condLock.wait()    # 交出执行权，并等待另一个线程通知加偶数            else:                # 添奇数                condLock.wait()  # 交出执行权，等待另一个线程通知加偶数                lst.append(i)                    condLock.notify()        condLock.notify()def odd():    """加奇数"""    with condLock:        for i in range(1, 101, 2):            if len(lst) % 2 == 0:                lst.append(i)                condLock.notify()                condLock.wait()        condLock.notify()if __name__ == "__main__":    condLock = threading.Condition()    addEvenTask = threading.Thread(target=even)    addOddTask = threading.Thread(target=odd)    addEvenTask.start()    addOddTask.start()    addEvenTask.join()    addOddTask.join()    print(lst)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="事件锁的应用"><a href="#事件锁的应用" class="headerlink" title="事件锁的应用"></a>事件锁的应用</h2><p>有2个任务线程来扮演李白和杜甫，如何让他们一人一句进行对答？文本如下：</p><blockquote><p>杜甫：老李啊，来喝酒！</p><p>李白：老杜啊，不喝了我喝不下了！</p><p>杜甫：老李啊，再来一壶？</p><p>杜甫：…老李？</p><p>李白：呼呼呼…睡着了..</p></blockquote><p>代码如下：</p><pre class="line-numbers language-none"><code class="language-none">import threadingdef libai():    event.wait()      print("李白：老杜啊，不喝了我喝不下了！")    event.set()    event.clear()    event.wait()    print("李白：呼呼呼...睡着了..")def dufu():    print("杜甫：老李啊，来喝酒！")    event.set()      event.clear()    event.wait()    print("杜甫：老李啊，再来一壶？")    print("杜甫：...老李？")    event.set()if __name__ == '__main__':    event = threading.Event()    t1 = threading.Thread(target=libai)    t2 = threading.Thread(target=dufu)    t1.start()    t2.start()    t1.join()    t2.join()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 线程锁 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python的threading模块</title>
      <link href="/2020/09/23/shi-yong-python-de-threading-mo-kuai/"/>
      <url>/2020/09/23/shi-yong-python-de-threading-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h1 id="threading模块"><a href="#threading模块" class="headerlink" title="threading模块"></a>threading模块</h1><p>Python中提供了threading模块来实现线程并发编程，官方文档如下：</p><p><a href="https://docs.python.org/zh-cn/3.6/library/threading.html">官方文档</a></p><h1 id="添加子线程"><a href="#添加子线程" class="headerlink" title="添加子线程"></a>添加子线程</h1><h2 id="实例化Thread类"><a href="#实例化Thread类" class="headerlink" title="实例化Thread类"></a>实例化Thread类</h2><p>使用该方式新增子线程任务是比较常见的，也是推荐使用的。</p><p>简单的代码示例如下，创建3个子线程并向其添加任务，然后运行并打印它们的线程ID和线程名字：</p><pre class="line-numbers language-none"><code class="language-none">import threadingimport timedef task(params):    print("sub thread run")    currentThread = threading.current_thread()    time.sleep(3)    print("current subthread id : %s\ncurrent subthread name : %s\ncurrent subthread params : %s" % (        currentThread.ident, currentThread.name, params))if __name__ == "__main__":    print("main thread run")    for item in range(3):        subThreadIns = threading.Thread(target=task, args=(item, ))        subThreadIns.start()    print("main thread run end")# main thread run# sub thread run# sub thread run# sub thread run# main thread run end# current subthread id : 123145534398464# current subthread name : Thread-1# current subthread params : 0# current subthread id : 123145544908800# current subthread name : Thread-3# current subthread params : 2# current subthread id : 123145539653632# current subthread name : Thread-2# current subthread params : 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>❶：返回一个线程对象，注意args的参数必须是一个tuple，否则抛出异常，也就是说单实参必须添加逗号</p><p>❷：start()方法是指该线程对象能够被系统调度了，但不是立即运行该线程，而是等待系统调度后才运行。所以你会看见上面子线程的运行顺序是0、2、1，另外一个线程对象只能运行一次该方法，若多次运行则抛出RunTimeError的异常。</p><p>❸：获取当前的线程对象</p><p>❹：获取当前线程对象的编号和名字，以及传入的参数。当线程启动时，系统都会分配给它一个随机的编号和名字</p><p>首先上述代码会先运行主线程，然后会创建3个子线程并运行。</p><p>当子线程运行的时候碰到了sleep(3)这种I/O操作时会释放掉GIL锁，并将线程执行权交还给了主线程。</p><p>然后主线程就运行完毕了，此时主线程并不会被kill掉，而是等待子线程运行结束后才会被kill掉，而子线程则是运行完毕后会被立刻kill掉。</p><p>我们可以看见，上面3个任务如果按照串行执行共会花费9.+秒时间，而通过多线程来运行，则仅需花费3.+秒的时间，极大的提升了任务处理效率。</p><h2 id="自定义类覆写run-方法"><a href="#自定义类覆写run-方法" class="headerlink" title="自定义类覆写run()方法"></a>自定义类覆写run()方法</h2><p>上面的子线程任务对象是一个全局函数，我们也可以将它作为方法来进行调用。</p><p>书写一个类并继承Threading类，覆写run()方法即可：</p><pre class="line-numbers language-none"><code class="language-none">import threadingimport timeclass TaskClass(threading.Thread):  # ❶    def __init__(self, params):        self.params = params  # ❷        super(__class__, self).__init__()    def run(self):        print("sub thread run")        currentThread = threading.currentThread()        time.sleep(3)        print("current subthread id : %s\ncurrent subthread name : %s\ncurrent subthread params : %s" % (            currentThread.ident, currentThread.name, self.params))if __name__ == "__main__":    print("main thread run")    for item in range(3):        subThreadIns = TaskClass(item)        subThreadIns.start()    print("main thread run end")# main thread run# sub thread run# sub thread run# sub thread run# main thread run end# current subthread id : 123145495068672# current subthread name : Thread-1# current subthread params : 0# current subthread id : 123145500323840# current subthread name : Thread-2# current subthread params : 1# current subthread id : 123145505579008# current subthread name : Thread-3# current subthread params : 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>❶：必须继承Threading类并调用父类的__init__()方法</p><p>❷：传入的参数</p><h2 id="源码浅析"><a href="#源码浅析" class="headerlink" title="源码浅析"></a>源码浅析</h2><p>为什么添加子线程有2种截然不同的方式呢？它们之间有什么区别？这些都可以从源码中找到答案。</p><p>我们从Thread类的实例看起，首先是__init__()方法（threading.py line 738 - 800），它主要做了一些初始化的准备工作：</p><pre class="line-numbers language-none"><code class="language-none">class Thread:    _initialized = False    _exc_info = _sys.exc_info    def __init__(self, group=None, target=None, name=None,                 args=(), kwargs=None, *, daemon=None):            # 如果group不是None，就会抛出断言异常        assert group is None, "group argument must be None for now"                # 如果kwargs是None，则构造一个空字典        if kwargs is None:            kwargs = {}                    # 传入的执行任务的函数或者None        self._target = target                # 线程名字        self._name = str(name or _newname())                # 任务函数传入的元组参数        self._args = args        # 任务函数传入的关键字参数        self._kwargs = kwargs        # 是否是守护线程启动，如果不是None则以守护线程模式启动        if daemon is not None:            self._daemonic = daemon        # 如果是None，则继承当前线程的守护模式        else:            self._daemonic = current_thread().daemon        # 线程编号        self._ident = None        # 锁定状态，None        self._tstate_lock = None        # 一把Event事件锁        self._started = Event()        # 是否停止运行的标志位        self._is_stopped = False        # 初始化状态改为True        self._initialized = True         self._stderr = _sys.stderr        _dangling.add(self)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数释义：</p><ul><li>group：应该为None，为了日后扩展ThreadGroup类而保留的</li><li>target：传入一个可调用对象，即线程任务task，默认为None，即可以不进行传入</li><li>name：线程启动时将不再由系统分配线程名称，而是自定义，默认情况下，系统分配的线程名称会由 “Thread-<em>N</em>“ 的格式构成一个唯一的名称，其中 <em>N</em> 是小的十进制数</li><li>args：用于调用目标函数的参数元组，默认是()空元组，你必须传入一个元组</li><li>kwargs：用于调用目标函数的关键字参数字典，默认是None，你必须传入一个字典</li><li>daemon：命名关键字参数，应当传入一个布尔值，默认为None，它会指定该线程是否是以守护线程模式启动，如果为None，该线程将继承当前线程的守护模式属性</li></ul><p>接下来看start()方法，它是告知系统当前线程完成调度，可随时启用的方法（threading.py line 828 - 851）：</p><pre class="line-numbers language-none"><code class="language-none">def start(self):    # 如果初始状态不为True，则抛出异常    if not self._initialized:        raise RuntimeError("thread.__init__() not called")    # 判断当前线程是否被锁住，如果被锁住则抛出异常    if self._started.is_set():        raise RuntimeError("threads can only be started once")    with _active_limbo_lock:        _limbo[self] = self    try:        # 执行引导        _start_new_thread(self._bootstrap, ())    except Exception:        with _active_limbo_lock:            del _limbo[self]        raise    self._started.wait()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里关键是看self._bootstrap()方法，该该方法位于（threading.py line 870 - 888），看看它会做什么事情：</p><pre class="line-numbers language-none"><code class="language-none">def _bootstrap(self):    try:        self._bootstrap_inner()    except:        if self._daemonic and _sys is None:            return        raise<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继续找self._bootstrap_inner()方法，该该方法位于（threading.py line 901 - 964）。</p><p>在该方法的916行时，它会执行run()方法：</p><pre class="line-numbers language-none"><code class="language-none">def _bootstrap_inner(self):        ...        try:            # 执行run            self.run()        except SystemExit:            pass        except:          ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果此时你按照第二种添加子线程的方式，则直接会运行被子类TaskClass覆写的run()方法。</p><p>如果是第一种添加子线程的方式，则还需要往里面看（threading.py line 835 - 868）：</p><pre class="line-numbers language-none"><code class="language-none">def run(self):       try:           # self._target = 我们自己传递的可调用对象task           if self._target:               self._target(*self._args, **self._kwargs)       finally:           del self._target, self._args, self._kwargs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此可以发现，不管是使用哪一种方式添加子线程，都会运行5个方法。</p><p>所以说它们内部实现其实都是一样的，没什么特别的，也不要觉得它特别神奇。</p><h1 id="threading模块方法大全"><a href="#threading模块方法大全" class="headerlink" title="threading模块方法大全"></a>threading模块方法大全</h1><p>以下是threading模块提供的类或方法：</p><table><thead><tr><th>类方法</th><th>描述</th><th>返回值</th></tr></thead><tbody><tr><td>threading.Thread(target, args, kwargs)</td><td>创建并返回一个线程对象</td><td>threadObject</td></tr><tr><td>threading.Timer(interval, function, args, kwargs)</td><td>创建并返回一个延迟启动的线程对象</td><td>threadObject</td></tr><tr><td>threading.active_count()</td><td>获取当前进程下存活的线程数量</td><td>int</td></tr><tr><td>threading.enumerate()</td><td>查看当前进程存活了的所有线程对象，以列表形式返回</td><td>[threadObject, …]</td></tr><tr><td>threading.main_thread()</td><td>获取主线程对象</td><td>threadObject</td></tr><tr><td>threading.current_thread()</td><td>获取当前正在执行的线程对象</td><td>threadObject</td></tr><tr><td>threading.currentThread()</td><td>获取当前正在执行的线程对象</td><td>threadObject</td></tr><tr><td>threading.get_ident()</td><td>获取当前正在执行的线程对象的编号</td><td>int</td></tr></tbody></table><p>下面我将使用该代码对上述功能进行演示：</p><pre class="line-numbers language-none"><code class="language-none">import threadingimport timeclass TaskClass(threading.Thread):    def run(self):        time.sleep(3)        passif __name__ == "__main__":    for i in range(3):        subThreadIns = TaskClass()        subThreadIns.start()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1）获取当前进程下存活的线程数量：</p><pre class="line-numbers language-none"><code class="language-none">print(threading.active_count())# 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2）查看当前进程存活了的所有线程对象，以列表形式返回：</p><pre class="line-numbers language-none"><code class="language-none">print(threading.enumerate())# [&lt;_MainThread(MainThread, started 4425459136)&gt;, &lt;TaskClass(Thread-1, started 123145449238528)&gt;, &lt;TaskClass(Thread-2, started 123145454493696)&gt;, &lt;TaskClass(Thread-3, started 123145459748864)&gt;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3）获取主线程对象：</p><pre class="line-numbers language-none"><code class="language-none">print(threading.main_thread())# &lt;_MainThread(MainThread, started 4565407168)&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>4）获取当前正在执行的线程对象：</p><pre class="line-numbers language-none"><code class="language-none">print(threading.currentThread())# &lt;_MainThread(MainThread, started 4383299008)&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>5）获取当前正在执行的线程对象的编号：</p><pre class="line-numbers language-none"><code class="language-none">print(threading.get_ident())# 4380034496<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="threadObject方法大全"><a href="#threadObject方法大全" class="headerlink" title="threadObject方法大全"></a>threadObject方法大全</h1><p>以下是针对线程对象提供的属性或者方法：</p><table><thead><tr><th>方法/属性</th><th>描述</th><th>返回值</th></tr></thead><tbody><tr><td>threadObject.start()</td><td>通知系统该线程调度完毕，可以随时进行启动，一个线程对象只能运行一次该方法，若多次运行则抛出RunTimeError异常</td><td>…</td></tr><tr><td>threadObject.join(timeout=None)</td><td>主线程默认会等待子线程运行结束后再继续执行，timeou为等待的秒数，如不设置该参数则一直等待。</td><td>…</td></tr><tr><td>threadObject.getName()</td><td>获取线程对象的名字</td><td>str</td></tr><tr><td>threadObject.setName(name)</td><td>设置线程对象的名字</td><td>None</td></tr><tr><td>threadObject.is_alive()</td><td>查看线程对象是否存活</td><td>bool</td></tr><tr><td>threadObject.isAlive()</td><td>查看线程对象是否存活，不推荐使用</td><td>bool</td></tr><tr><td>threadObject.isDaemon()</td><td>查看线程对象是守护线程</td><td>bool</td></tr><tr><td>threadObject.setDaemon()</td><td>设置线程对象为守护线程，主线程运行完毕之后设置为守护线程的子线程便立即结束执行</td><td>None</td></tr><tr><td>threadObject.ident</td><td>获取线程对象的编号</td><td>int</td></tr><tr><td>threadObject.name</td><td>获取或者设置线程对象的名字</td><td>str or None</td></tr><tr><td>daemon</td><td>查看线程对象是守护线程</td><td>bool</td></tr></tbody></table><h2 id="主线程阻塞"><a href="#主线程阻塞" class="headerlink" title="主线程阻塞"></a>主线程阻塞</h2><p>默认情况下，当子线程启动后，主线程会依旧往下运行而不是等待所有的子线程运行完毕后再继续往下运行。</p><p>如图所示，主线程在运行结束后并不会被理解kill掉，而是所有的子线程运行完毕后主线程才会被kill掉：</p><p><img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210701172414613.png" alt="image-20210701172414613"></p><p>我们可以利用threadObject.join(timeout=None)来让主线程等待子线程运行完毕后再继续向下运行，timeout为等待的秒数，如不设置该参数则一直等待。</p><p>如图所示，这是没有设置timeout的示意图，主线程必须等待所有子线程运行完毕后再接着运行：</p><p><img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210701172435152.png" alt="image-20210701172435152"></p><p>代码示例：</p><pre class="line-numbers language-none"><code class="language-none">import threadingimport timeclass TaskClass(threading.Thread):    def run(self):        thName = threading.current_thread().name        print("%s start run" % thName)        time.sleep(3)        print("%s run end" % thName)if __name__ == "__main__":    print("main thread start run")    threadLst = []        for i in range(3):        threadLst.append(TaskClass())    for ins in threadLst:        ins.start()  # 开始运行所有子线程    for ins in threadLst:        ins.join()   # 让主线程等待所有子线程运行完毕后再接着运行，注意，设置主线程等待的子线程必须处于活跃状态            print("main thread carry on run")    print("main thread run end")    # main thread start run# Thread-1 start run# Thread-2 start run# Thread-3 start run# Thread-1 run end# Thread-2 run end# Thread-3 run end# main thread carry on run# main thread run end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程是指当主线程运行完毕后，子线程是否还要继续运行。</p><p>默认threadObject.setDaemon()为None，也就是False，即当前主线程运行完毕后，子线程依旧可以接着运行。</p><p><img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210701174232233.png" alt="image-20210701174232233"></p><p>如果threadObject.setDaemon()为True，则当前主线程运行完毕后，子线程即使没有运行完毕也会结束运行。</p><p><img src="https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210701174053747.png" alt="image-20210701174053747"></p><p>代码示例：</p><pre class="line-numbers language-none"><code class="language-none">import threadingimport timeclass TaskClass(threading.Thread):    def run(self):        thName = threading.current_thread().name        print("%s start run" % thName)        time.sleep(3)        print("%s run end" % thName)if __name__ == "__main__":    print("main thread start run")    threadLst = []    for i in range(3):        threadLst.append(TaskClass())    for ins in threadLst:            # 注意，守护线程的设置必须在线程未启动时设置        ins.setDaemon(True)        ins.start()    print("main thread carry on run")    print("main thread run end")# main thread start run# Thread-1 start run# Thread-2 start run# Thread-3 start run# main thread carry on run# main thread run end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="join-与setDaemon-True-共存"><a href="#join-与setDaemon-True-共存" class="headerlink" title="join()与setDaemon(True)共存"></a>join()与setDaemon(True)共存</h2><p>如果同时设置setDaemon(True)与join()方法会怎么样呢？有两种情况：</p><ol><li>join()方法没有设置timeout（没有设置即表示死等）或者timeout的时间比子线程作业时间要长，这代表子线程会死在主线程之前，setDaemon(True)也就没有了意义，即失效了</li><li>join()设置了timeout并且timeout的时间比子线程作业时间要短，这代表主线程会死在子线程之前，setDaemon(True)生效，子线程会跟着主线程一起死亡。</li></ol><p>情况一：</p><pre class="line-numbers language-none"><code class="language-none">import threadingimport timeclass TaskClass(threading.Thread):    def run(self):        thName = threading.current_thread().name        print("%s start run" % thName)        time.sleep(3)        print("%s run end" % thName)if __name__ == "__main__":    subThread = TaskClass()    subThread.setDaemon(True) # 主线程运行完后会立即终止子线程的运行。但是由于有join()，故不生效。    subThread.start()    subThread.join() # 主线程必须等待子线程运行结束后再接着运行    print("main thread run end")# Thread-1 start run# Thread-1 run end# main thread run end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>情况2：</p><pre class="line-numbers language-none"><code class="language-none">import threadingimport timeclass TaskClass(threading.Thread):    def run(self):        thName = threading.current_thread().name        print("%s start run" % thName)        time.sleep(3)        print("%s run end" % thName)if __name__ == "__main__":    subThread = TaskClass()    subThread.setDaemon(True) # 主线程运行完后会立即终止子线程的运行。但是由于有join()，故不生效。    subThread.start()    subThread.join(1) # 主线程必须等待子线程运行结束后再接着运行，只等待1s    print("main thread run end")# Thread-1 start run# main thread run end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="线程延迟启动"><a href="#线程延迟启动" class="headerlink" title="线程延迟启动"></a>线程延迟启动</h1><p>使用threading模块中提供的Timer类，可让子线程延迟启动，如下所示：</p><pre class="line-numbers language-none"><code class="language-none">import threadingimport timedef task():    print("sub thread start run")    time.sleep(3)    print("sub thread run end")if __name__ == "__main__":    print("main thread run")    t1 = threading.Timer(interval=3, function=task)    t1.start()  # 3秒后才启动子线程    t1.join()    print("main thread run end")# main thread run# sub thread start run# sub thread run end# main thread run end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要用类的形式，则可以继承threading.Timer()类，并修改self.function属性，个人极度不推荐这样做。</p><p>如下所示，在不知道某一个方法怎么使用时扒扒源码看一看，翻翻官方文档就大概能了解：</p><pre class="line-numbers language-none"><code class="language-none">import threadingimport timeclass TaskClass(threading.Timer):    def __init__(self, *args, **kwargs):        # 必须要修改function为你想执行的方法        super(__class__, self).__init__(*args, **kwargs)        self.function = self.task    def task(self, x, y):        print("sub thread start run")        time.sleep(3)        print("parmas %s %s" % (x, y))        print("sub thread run end")if __name__ == "__main__":    # 必须传入一个None    t1 = TaskClass(interval=3, function=None, args=(1, 2))    t1.start()    t1.join()    print("main thread run end")# sub thread start run# parmas 1 2# sub thread run end# main thread run end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="多线程编程应用场景"><a href="#多线程编程应用场景" class="headerlink" title="多线程编程应用场景"></a>多线程编程应用场景</h1><p>由于GIL锁的存在，Python中对于I/O操作来说可以使用多线程编程，如果是计算密集型的操作则不应该使用多线程进行处理，因为没有I/O操作就不能通过I/O切换来执行其他线程，故对于计算密集型的操作来说多线程没有什么优势，甚至还可能比普通串行还慢（因为涉及到线程切换，虽然是毫秒级别，但是计算的数值越大这个切换也就越密集，GIL锁是100个CPU指令切换一次的）</p><p>注意：我们是在Python2版本下进行此次测试，Python3版本确实相差不大，但是，从本质上来说依然是这样的。</p><p>计算密集型程序的普通串行运行时间：</p><pre class="line-numbers language-none"><code class="language-none">import threadingimport timenum = 0def add():    global num    for i in range(10000000): # 一千万次        num += 1def sub():    global num    for i in range(10000000):  # 一千万次        num -= 1if __name__ == '__main__':    start_time = time.time()    add()    sub()    end_time = time.time()    print("执行时间:",end_time - start_time)        # ==== 执行结果 ==== 三次采集"""大约在 1.3 - 1.4 秒"""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>计算密集型程序的多线程并发运行时间：</p><pre class="line-numbers language-none"><code class="language-none"># coding:utf-8import threadingimport timenum = 0def add():    global num    for i in range(10000000):  # 一千万次        num += 1def sub():    global num    for i in range(10000000):  # 一千万次        num -= 1if __name__ == '__main__':    start_time = time.time()    t1 = threading.Thread(target=add,)    t2 = threading.Thread(target=sub,)    t1.start()    t2.start()    t1.join()    t2.join()    end_time = time.time()    print(u"执行时间:",end_time - start_time)# ==== 执行结果 ==== 三次采集"""大约 4 - 5 秒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> threaing </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文本三剑客超详细教程---grep、sed、awk</title>
      <link href="/2020/09/03/linux-wen-ben-san-jian-ke-chao-xiang-xi-jiao-cheng-grep-sed-awk/"/>
      <url>/2020/09/03/linux-wen-ben-san-jian-ke-chao-xiang-xi-jiao-cheng-grep-sed-awk/</url>
      
        <content type="html"><![CDATA[<p>Linux文本三剑客超详细教程—grep、sed、awk<br>　　awk、grep、sed是linux操作文本的三大利器，合称文本三剑客，也是必须掌握的linux命令之一。三者的功能都是处理文本，但侧重点各不相同，其中属awk功能最强大，但也最复杂。grep更适合单纯的查找或匹配文本，sed更适合编辑匹配到的文本，awk更适合格式化文本，对文本进行较复杂格式处理。</p><p>1、grep<br>1.1 什么是grep和egrep<br>　　Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来（匹配到的标红）。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p><p>　　grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p><p>　　grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p><p>　　egrep = grep -E：扩展的正则表达式 （除了&lt; , &gt; , \b 使用其他正则都可以去掉\）</p><p>1.2 使用grep<br>1.2.1 命令格式<br>1<br>grep [option] pattern file</p><p>1.2.2 命令功能<br>用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。</p><p>1.2.3 命令参数<br>常用参数已加粗</p><p> -A&lt;显示行数&gt;：除了显示符合范本样式的那一列之外，并显示该行之后的内容。<br> -B&lt;显示行数&gt;：除了显示符合样式的那一行之外，并显示该行之前的内容。<br> -C&lt;显示行数&gt;：除了显示符合样式的那一行之外，并显示该行之前后的内容。<br> -c：统计匹配的行数<br> -e ：实现多个选项间的逻辑or 关系<br> -E：扩展的正则表达式<br> -f FILE：从FILE获取PATTERN匹配<br> -F ：相当于fgrep<br> -i –ignore-case #忽略字符大小写的差别。<br> -n：显示匹配的行号<br> -o：仅显示匹配到的字符串<br> -q： 静默模式，不输出任何信息<br> -s：不显示错误信息。<br> -v：显示不被pattern 匹配到的行，相当于[^] 反向匹配<br> -w ：匹配 整个单词</p><p>1.3 grep实战演示</p><p> 2、正则表达式<br>2.1 认识正则<br>（1）介绍</p><p>　　正则表达式应用广泛，在绝大多数的编程语言都可以完美应用，在Linux中，也有着极大的用处。</p><p>　　使用正则表达式，可以有效的筛选出需要的文本，然后结合相应的支持的工具或语言，完成任务需求。</p><p>　　在本篇博客中，我们使用grep/egrep来完成对正则表达式的调用</p><p>（2）正则表达式类型</p><p>正则表达式可以使用正则表达式引擎实现，正则表达式引擎是解释正则表达式模式并使用这些模式匹配文本的基础软件。</p><p>在Linux中，常用的正则表达式有：</p><p> POSIX 基本正则表达式（BRE）引擎<br> POSIX 扩展正则表达式（BRE）引擎</p><p>2.2 基本正则表达式<br>2.2.1 匹配字符<br>（1）格式</p><p> . 匹配任意单个字符，不能匹配空行<br>  [] 匹配指定范围内的任意单个字符<br>  [^] 取反<br>  [:alnum:] 或 [0-9a-zA-Z]<br>  [:alpha:] 或 [a-zA-Z]<br>  [:upper:] 或 [A-Z]<br>  [:lower:] 或 [a-z]<br>  [:blank:] 空白字符（空格和制表符）<br>  [:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广）<br>  [:cntrl:] 不可打印的控制字符（退格、删除、警铃…）<br>  [:digit:] 十进制数字 或[0-9]<br>  [:xdigit:]十六进制数字<br>  [:graph:] 可打印的非空白字符<br>  [:print:] 可打印字符<br>  [:punct:] 标点符号<br>（2）演示</p><p>2.2.2 配置次数<br>（1）格式</p><ul><li>匹配前面的字符任意次，包括0次，贪婪模式：尽可能长的匹配<br>.*  任意长度的任意字符，不包括0次<br>?  匹配其前面的字符0 或 1次<br>+  匹配其前面的字符至少1次<br>{n}  匹配前面的字符n次<br>{m,n}  匹配前面的字符至少m 次，至多n次<br>{,n}  匹配前面的字符至多n次<br>{n,}  匹配前面的字符至少n次<br>（2）演示</li></ul><p>2.2.3 位置锚定：定位出现的位置<br>（1）格式</p><p> ^  行首锚定，用于模式的最左侧<br> $  行尾锚定，用于模式的最右侧<br> ^PATTERN$，用于模式匹配整行<br> ^$ 空行<br> ^[[:space:]].*$  空白行<br> &lt; 或 \b  词首锚定，用于单词模式的左侧<br> &gt; 或 \b  词尾锚定；用于单词模式的右侧<br> &lt;PATTERN&gt;<br>（2）演示</p><p>2.2.4 分组和后向引用<br>（1）格式</p><p>① 分组：() 将一个或多个字符捆绑在一起，当作一个整体进行处理</p><p>　　分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为: \1, \2, \3, …</p><p>② 后向引用</p><p>引用前面的分组括号中的模式所匹配字符，而非模式本身</p><p>\1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符</p><p>\2 表示从左侧起第2个左括号以及与之匹配右括号之间的模式所匹配到的字符，以此类推</p><p>&amp; 表示前面的分组中所有字符</p><p>③ 流程分析如下：</p><p>（2）演示</p><p>2.3 扩展正则表达式<br>（1）字符匹配：</p><p> .  任意单个字符<br> []  指定范围的字符<br> [^] 不在指定范围的字符<br>   次数匹配：</p><ul><li>：匹配前面字符任意次<br>?  : 0 或1次</li></ul><ul><li>：1 次或多次<br>{m} ：匹配m次 次<br>{m,n} ：至少m ，至多n次<br>（2）位置锚定：</li></ul><p> ^ : 行首<br> $ : 行尾<br> &lt;, \b : 语首<br> &gt;, \b : 语尾<br>   分组：()<br> 后向引用：\1, \2, …<br>（3）总结</p><p>　　除了&lt;, \b : 语首、&gt;, \b : 语尾；使用其他正则都可以去掉\；上面有演示案例，不在进行演示</p><p>3、sed<br>3.1 认识sed<br>　　sed 是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（patternspace ），接着用sed 命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。然后读入下行，执行下一个循环。如果没有使诸如‘D’ 的特殊命令，那会在两个循环之间清空模式空间，但不会清空保留空间。这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出或-i。</p><p>　　功能：主要用来自动编辑一个或多个文件, 简化对文件的反复操作</p><p>3.2 使用sed<br>3.2.1 命令格式<br>1<br>sed [options] ‘[地址定界] command’ file(s)　　</p><p>3.2.2 常用选项options<br> -n：不输出模式空间内容到屏幕，即不自动打印，只打印匹配到的行<br> -e：多点编辑，对每行处理时，可以有多个Script<br> -f：把Script写到文件当中，在执行sed时-f 指定文件路径，如果是多个Script，换行写<br> -r：支持扩展的正则表达式<br> -i：直接将处理的结果写入文件<br> -i.bak：在将处理的结果写入文件之前备份一份</p><p>3.2.3 地址定界<br> 不给地址：对全文进行处理<br> 单地址：<br> #: 指定的行<br> /pattern/：被此处模式所能够匹配到的每一行<br> 地址范围：<br> #,#<br> #,+#<br> /pat1/,/pat2/<br> #,/pat1/<br> <del>：步进<br>  sed -n ‘1</del>2p’  只打印奇数行 （1<del>2 从第1行，一次加2行）<br>  sed -n ‘2</del>2p’  只打印偶数行</p><p>3.2.4 编辑命令command<br> d：删除模式空间匹配的行，并立即启用下一轮循环<br> p：打印当前模式空间内容，追加到默认输出之后<br> a：在指定行后面追加文本，支持使用\n实现多行追加<br> i：在行前面插入文本，支持使用\n实现多行追加<br> c：替换行为单行或多行文本，支持使用\n实现多行追加<br> w：保存模式匹配的行至指定文件<br> r：读取指定文件的文本至模式空间中匹配到的行后<br> =：为模式空间中的行打印行号<br> !：模式空间中匹配行取反处理<br> s///：查找替换，支持使用其它分隔符，如：s@@@，s###；<br> 加g表示行内全局替换；<br> 在替换时，可以加一下命令，实现大小写转换<br> \l：把下个字符转换成小写。<br> \L：把replacement字母转换成小写，直到\U或\E出现。<br> \u：把下个字符转换成大写。<br> \U：把replacement字母转换成大写，直到\L或\E出现。<br> \E：停止以\L或\U开始的大小写转换</p><p>3.3 sed用法演示<br>3.3.1 常用选项options演示<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>[root@along ~]# cat demo<br>aaa<br>bbbb<br>AABBCCDD<br>[root@along ~]# sed “/aaa/p” demo  #匹配到的行会打印一遍，不匹配的行也会打印<br>aaa<br>aaa<br>bbbb<br>AABBCCDD<br>[root@along ~]# sed -n “/aaa/p” demo  #-n不显示没匹配的行<br>aaa<br>[root@along ~]# sed -e “s/a/A/“ -e “s/b/B/“ demo  #-e多点编辑<br>Aaa<br>Bbbb<br>AABBCCDD<br>[root@along ~]# cat sedscript.txt<br>s/A/a/g<br>[root@along ~]# sed -f sedscript.txt demo  #-f使用文件处理<br>aaa<br>bbbb<br>aaBBCCDD<br>[root@along ~]# sed -i.bak “s/a/A/g” demo  #-i直接对文件进行处理<br>[root@along ~]# cat demo<br>AAA<br>bbbb<br>AABBCCDD<br>[root@along ~]# cat demo.bak<br>aaa<br>bbbb<br>AABBCCDD　　</p><p>3.3.2 地址界定演示<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>[root@along <del>]# cat demo<br>aaa<br>bbbb<br>AABBCCDD<br>[root@along ~]# sed -n “p” demo  #不指定行，打印全文<br>aaa<br>bbbb<br>AABBCCDD<br>[root@along ~]# sed “2s/b/B/g” demo  #替换第2行的b-&gt;B<br>aaa<br>BBBB<br>AABBCCDD<br>[root@along ~]# sed -n “/aaa/p” demo<br>aaa<br>[root@along ~]# sed -n “1,2p” demo  #打印1-2行<br>aaa<br>bbbb<br>[root@along ~]# sed -n “/aaa/,/DD/p” demo<br>aaa<br>bbbb<br>AABBCCDD<br>[root@along ~]# sed -n “2,/DD/p” demo<br>bbbb<br>AABBCCDD<br>[root@along ~]# sed “1</del>2s/[aA]/E/g” demo  #将奇数行的a或A替换为E<br>EEE<br>bbbb<br>EEBBCCDD　　</p><p>3.3.3 编辑命令command演示<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>[root@along ~]# cat demo<br>aaa<br>bbbb<br>AABBCCDD<br>[root@along ~]# sed “2d” demo  #删除第2行<br>aaa<br>AABBCCDD<br>[root@along ~]# sed -n “2p” demo  #打印第2行<br>bbbb<br>[root@along ~]# sed “2a123” demo  #在第2行后加123<br>aaa<br>bbbb<br>123<br>AABBCCDD<br>[root@along ~]# sed “1i123” demo  #在第1行前加123<br>123<br>aaa<br>bbbb<br>AABBCCDD<br>[root@along ~]# sed “3c123\n456” demo  #替换第3行内容<br>aaa<br>bbbb<br>123<br>456<br>[root@along ~]# sed -n “3w/root/demo3” demo  #保存第3行的内容到demo3文件中<br>[root@along ~]# cat demo3<br>AABBCCDD<br>[root@along ~]# sed “1r/root/demo3” demo  #读取demo3的内容到第1行后<br>aaa<br>AABBCCDD<br>bbbb<br>AABBCCDD<br>[root@along ~]# sed -n “=” demo  #=打印行号<br>1<br>2<br>3<br>[root@along ~]# sed -n ‘2!p’ demo  #打印除了第2行的内容<br>aaa<br>AABBCCDD<br>[root@along ~]# sed ‘s@[a-z]@\u&amp;@g’ demo  #将全文的小写字母替换为大写字母<br>AAA<br>BBBB<br>AABBCCDD　　</p><p>3.4 sed高级编辑命令<br>（1）格式</p><p> h：把模式空间中的内容覆盖至保持空间中<br> H：把模式空间中的内容追加至保持空间中<br> g：从保持空间取出数据覆盖至模式空间<br> G：从保持空间取出内容追加至模式空间<br> x：把模式空间中的内容与保持空间中的内容进行互换<br> n：读取匹配到的行的下一行覆盖 至模式空间<br> N：读取匹配到的行的下一行追加 至模式空间<br> d：删除模式空间中的行<br> D：删除 当前模式空间开端至\n 的内容（不再传 至标准输出），放弃之后的命令，但是对剩余模式空间重新执行sed</p><p>（2）一个案例+示意图演示</p><p>① 案例：倒序输出文本内容</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>[root@along ~]# cat num.txt<br>One<br>Two<br>Three<br>[root@along ~]# sed ‘1!G;h;$!d’ num.txt<br>Three<br>Two<br>One<br>② 示意图如下：</p><p>③ 总结模式空间与保持空间关系：</p><p>保持空间是模式空间一个临时存放数据的缓冲区，协助模式空间进行数据处理</p><p>（3）演示</p><p>① 显示偶数行</p><p>1<br>2<br>3<br>4<br>5<br>[root@along ~]# seq 9 |sed -n ‘n;p’<br>2<br>4<br>6<br>8<br>② 倒序显示</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>[root@along ~]# seq 9 |sed  ‘1!G;h;$!d’<br>9<br>8<br>7<br>6<br>5<br>4<br>3<br>2<br>1<br>③ 显示奇数行</p><p>1<br>2<br>3<br>4<br>5<br>6<br>[root@along ~]# seq 9 |sed ‘H;n;d’<br>1<br>3<br>5<br>7<br>9<br>④ 显示最后一行</p><p>1<br>2<br>[root@along ~]# seq 9| sed ‘N;D’<br>9<br>⑤ 每行之间加空行</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>[root@along ~]# seq 9 |sed ‘G’<br>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><hr><p> ⑥ 把每行内容替换成空行</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>[root@along ~]# seq 9 |sed “g”</p><hr><p> ⑦ 确保每一行下面都有一个空行</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>[root@along ~]# seq 9 |sed ‘/^$/d;G’<br>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>4、awk<br>4.1 认识awk<br>　　awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。</p><p>　　awk其实不仅仅是工具软件，还是一种编程语言。不过，本文只介绍它的命令行用法，对于大多数场合，应该足够用了。</p><p>4.2 使用awk<br>4.2.1 语法<br>1<br>2<br>3<br>awk [options] ‘program’ var=value file…<br>awk [options] -f programfile var=value file…<br>awk [options] ‘BEGIN{ action;… } pattern{ action;… } END{ action;… }’ file …　　</p><p>4.2.2 常用命令选项<br> -F fs：fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:<br> -v var=value：赋值一个用户定义变量，将外部变量传递给awk<br> -f scripfile：从脚本文件中读取awk命令</p><p>4.3 awk变量<br>变量：内置和自定义变量，每个变量前加 -v 命令选项</p><p>4.3.1 内置变量<br>（1）格式</p><p> FS ：输入字段分隔符，默认为空白字符<br> OFS ：输出字段分隔符，默认为空白字符<br> RS ：输入记录分隔符，指定输入时的换行符，原换行符仍有效<br> ORS ：输出记录分隔符，输出时用指定符号代替换行符<br> NF ：字段数量，共有多少字段， $NF引用最后一列，$(NF-1)引用倒数第2列<br> NR ：行号，后可跟多个文件，第二个文件行号继续从第一个文件最后行号开始<br> FNR ：各文件分别计数, 行号，后跟一个文件和NR一样，跟多个文件，第二个文件行号从1开始<br> FILENAME ：当前文件名<br> ARGC ：命令行参数的个数<br> ARGV ：数组，保存的是命令行所给定的各参数，查看参数</p><p>（2）演示</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>[root@along ~]# cat awkdemo<br>hello:world<br>linux:redhat:lalala:hahaha<br>along:love:youou<br>[root@along ~]# awk -v FS=’:’ ‘{print $1,$2}’ awkdemo  #FS指定输入分隔符<br>hello world<br>linux redhat<br>along love<br>[root@along ~]# awk -v FS=’:’ -v OFS=’—‘ ‘{print $1,$2}’ awkdemo  #OFS指定输出分隔符<br>hello—world<br>linux—redhat<br>along—love<br>[root@along ~]# awk -v RS=’:’ ‘{print $1,$2}’ awkdemo<br>hello<br>world linux<br>redhat<br>lalala<br>hahaha along<br>love<br>you<br>[root@along ~]# awk -v FS=’:’ -v ORS=’—‘ ‘{print $1,$2}’ awkdemo<br>hello world—linux redhat—along love—<br>[root@along ~]# awk -F: ‘{print NF}’ awkdemo<br>2<br>4<br>3<br>[root@along ~]# awk -F: ‘{print $(NF-1)}’ awkdemo  #显示倒数第2列<br>hello<br>lalala<br>love<br>[root@along ~]# awk ‘{print NR}’ awkdemo awkdemo1<br>1<br>2<br>3<br>4<br>5<br>[root@along ~]# awk END’{print NR}’ awkdemo awkdemo1<br>5<br>[root@along ~]# awk ‘{print FNR}’ awkdemo awkdemo1<br>1<br>2<br>3<br>1<br>2<br>[root@along ~]# awk ‘{print FILENAME}’ awkdemo<br>awkdemo<br>awkdemo<br>awkdemo<br>[root@along ~]# awk ‘BEGIN {print ARGC}’ awkdemo awkdemo1<br>3<br>[root@along ~]# awk ‘BEGIN {print ARGV[0]}’ awkdemo awkdemo1<br>awk<br>[root@along ~]# awk ‘BEGIN {print ARGV[1]}’ awkdemo awkdemo1<br>awkdemo<br>[root@along ~]# awk ‘BEGIN {print ARGV[2]}’ awkdemo awkdemo1<br>awkdemo1　　</p><p>4.3.2 自定义变量<br>自定义变量( 区分字符大小写)</p><p>（1）-v var=value</p><p>① 先定义变量，后执行动作print</p><p>1<br>2<br>3<br>4<br>[root@along ~]# awk -v name=”along” -F: ‘{print name”:”$0}’ awkdemo<br>along:hello:world<br>along:linux:redhat:lalala:hahaha<br>along:along:love:you<br>② 在执行动作print后定义变量</p><p>1<br>2<br>3<br>4<br>[root@along ~]# awk -F: ‘{print name”:”$0;name=”along”}’ awkdemo<br>:hello:world<br>along:linux:redhat:lalala:hahaha<br>along:along:love:you　　</p><p>（2）在program 中直接定义</p><p>可以把执行的动作放在脚本中，直接调用脚本 -f</p><p>1<br>2<br>3<br>4<br>5<br>6<br>[root@along ~]# cat awk.txt<br>{name=”along”;print name,$1}<br>[root@along ~]# awk -F: -f awk.txt awkdemo<br>along hello<br>along linux<br>along along　　</p><p>4.4 printf命令<br>比print更强大</p><p>4.4.1 格式<br>（1）格式化输出</p><p>1<br>printf “FORMAT”, item1,item2, …<br>①  必须指定FORMAT</p><p>②  不会自动换行，需要显式给出换行控制符，\n</p><p>③  FORMAT 中需要分别为后面每个item 指定格式符</p><p>（2）格式符：与item 一一对应</p><p> %c:  显示字符的ASCII码<br> %d, %i:  显示十进制整数<br> %e, %E: 显示科学计数法数值<br> %f ：显示为浮点数，小数   %5.1f，带整数、小数点、整数共5位，小数1位，不够用空格补上<br> %g, %G ：以科学计数法或浮点形式显示数值<br> %s ：显示字符串；例：%5s最少5个字符，不够用空格补上，超过5个还继续显示<br> %u ：无符号整数<br> %%:  显示% 自身</p><p>（3）修饰符：放在%c[/d/e/f…]之间</p><p> #[.#]：第一个数字控制显示的宽度；第二个# 表示小数点后精度，%5.1f<br> -：左对齐（默认右对齐） %-15s<br> +：显示数值的正负符号 %+d</p><p>4.4.2 演示<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>[root@along ~]# awk -F: ‘{print $1,$3}’ /etc/passwd<br>root 0<br>bin 1<br>—第一列显示小于20的字符串；第2列显示整数并换行<br>[root@along ~]# awk -F: ‘{printf “%20s—%u\n”,$1,$3}’ /etc/passwd<br>                root—0<br>                 bin—1<br>—使用-进行左对齐；第2列显示浮点数<br>[root@along ~]# awk -F: ‘{printf “%-20s—%-10.3f\n”,$1,$3}’ /etc/passwd<br>root                —0.000<br>bin                 —1.000<br>—使用printf做表格<br>[root@along ~]# awk -F: ‘BEGIN{printf “username            userid\n—————————–\n”}{printf “%-20s|%-10.3f\n”,$1,$3}’ /etc/passwd<br>username            userid</p><hr><p>root                |0.000<br>bin                 |1.000　　</p><p>4.5 操作符<br>4.5.1 格式<br> 算术操作符：<br> x+y, x-y, x*y, x/y, x^y, x%y<br> -x:  转换为负数<br> +x:  转换为数值<br> 字符串操作符：没有符号的操作符，字符串连接<br> 赋值操作符：<br> =, +=, -=, *=, /=, %=, ^=<br> ++, –<br> 比较操作符：<br> ==, !=, &gt;, &gt;=, &lt;, &lt;=<br> 模式匹配符：~ ：左边是否和右边匹配包含 !~ ：是否不匹配<br> 逻辑操作符：与&amp;&amp; ，或|| ，非!<br> 函数调用： function_name(argu1, argu2, …)<br> 条件表达式（三目表达式）：selector?if-true-expression:if-false-expression<br> 注释：先判断selector，如果符合执行 ? 后的操作；否则执行 : 后的操作</p><p>4.5.2 演示<br>（1）模式匹配符</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>—查询以/dev开头的磁盘信息<br>[root@along ~]# df -h |awk -F: ‘$0 ~ /^/dev/‘<br>/dev/mapper/cl-root   17G  7.3G  9.7G  43% /<br>/dev/sda1           1014M  121M  894M  12% /boot<br>—只显示磁盘使用状况和磁盘名<br>[root@along ~]# df -h |awk ‘$0 ~ /^/dev/{print $(NF-1)”—“$1}’<br>43%—/dev/mapper/cl-root<br>12%—/dev/sda1<br>—查找磁盘大于40%的<br>[root@along ~]# df -h |awk ‘$0 ~ /^/dev/{print $(NF-1)”—“$1}’ |awk -F% ‘$1 &gt; 40’<br>43%—/dev/mapper/cl-root　　</p><p>（2）逻辑操作符</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>[root@along ~]# awk -F: ‘$3&gt;=0 &amp;&amp; $3&lt;=1000 {print $1,$3}’ /etc/passwd<br>root 0<br>bin 1<br>[root@along ~]# awk -F: ‘$3==0 || $3&gt;=1000 {print $1}’ /etc/passwd<br>root<br>[root@along ~]# awk -F: ‘!($3==0) {print $1}’ /etc/passwd<br>bin<br>[root@along ~]# awk -F: ‘!($0 ~ /bash$/) {print $1,$3}’ /etc/passwd<br>bin 1<br>daemon 2　　</p><p>（3）条件表达式（三目表达式）</p><p>1<br>2<br>3<br>[root@along ~]# awk -F: ‘{$3 &gt;= 1000?usertype=”common user”:usertype=”sysadmin user”;print usertype,$1,$3}’ /etc/passwd<br>sysadmin user root 0<br>common user along 1000　　</p><p>4.6 awk PATTERN 匹配部分<br>4.6.1 格式<br>PATTERN：根据pattern 条件，过滤匹配的行，再做处理</p><p>（1）如果未指定：空模式，匹配每一行</p><p>（2）/regular expression/ ：仅处理能够模式匹配到的行，正则，需要用/ / 括起来</p><p>（3）relational expression：关系表达式，结果为“真”才会被处理</p><p>真：结果为非0值，非空字符串</p><p>假：结果为空字符串或0值</p><p>（4）line ranges：行范围</p><p>　　startline(起始行),endline(结束行)：/pat1/,/pat2/  不支持直接给出数字，可以有多段，中间可以有间隔</p><p>（5）BEGIN/END 模式</p><p>　　BEGIN{}:  仅在开始处理文件中的文本之前执行一次</p><p>　　END{} ：仅在文本处理完成之后执行</p><p>4.6.2 演示<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>[root@along ~]# awk -F: ‘{print $1}’ awkdemo<br>hello<br>linux<br>along<br>[root@along ~]# awk -F: ‘/along/{print $1}’ awkdemo<br>along<br>[root@along ~]# awk -F: ‘1{print $1}’ awkdemo<br>hello<br>linux<br>along<br>[root@along ~]# awk -F: ‘0{print $1}’ awkdemo<br>[root@along ~]# awk -F: ‘/^h/,/^a/{print $1}’ awkdemo<br>hello<br>linux<br>along<br>[root@along ~]# awk -F: ‘BEGIN{print “第一列”}{print $1} END{print “结束”}’ awkdemo<br>第一列<br>hello<br>linux<br>along<br>结束　　</p><p>4.7 awk有意思的案例<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>[root@along ~]# seq 10<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>—因为i=0，为假，所以不打印<br>[root@along ~]# seq 10 |awk ‘i=0’<br>—i=1，为真，所以全部打印<br>[root@along ~]# seq 10 |awk ‘i=1’<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>—只打印奇数行；奇数行i进入时本身为空，被赋为!i，即不为空，所以打印；偶数行i进入时本身不为空，被赋为!i，即为空，所以不打印<br>[root@along ~]# seq 10 |awk ‘i=!i’<br>1<br>3<br>5<br>7<br>9<br>—解释上一个操作，i在奇偶行的值<br>[root@along ~]# seq 10 |awk ‘{i=!i;print i}’<br>1<br>0<br>1<br>0<br>1<br>0<br>1<br>0<br>1<br>0<br>—只打印偶数行，是上边打印奇数行的取反<br>[root@along ~]# seq 10 |awk ‘!(i=!i)’<br>2<br>4<br>6<br>8<br>10<br>—只打印偶数行；先对i进行赋值，即不为空，刚好和打印奇数行相反<br>[root@along ~]# seq 10 |awk -v i=1 ‘i=!i’<br>2<br>4<br>6<br>8<br>10　　</p><p>5、awk高阶用法<br>5.1 awk控制语句—if-else判断<br>（1）语法</p><p>1<br>2<br>if(condition){statement;…}[else statement]  双分支<br>if(condition1){statement1}else if(condition2){statement2}else{statement3}  多分支<br>（2）使用场景：对awk 取得的整行或某个字段做条件判断</p><p>（3）演示</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>[root@along ~]# awk -F: ‘{if($3&gt;10 &amp;&amp; $3&lt;1000)print $1,$3}’ /etc/passwd<br>operator 11<br>games 1<br>[root@along ~]# awk -F: ‘{if($NF==”/bin/bash”) print $1,$NF}’ /etc/passwd<br>root /bin/bash<br>along /bin/bash<br>—输出总列数大于3的行<br>[root@along ~]# awk -F: ‘{if(NF&gt;2) print $0}’ awkdemo<br>linux:redhat:lalala:hahaha<br>along:love:you<br>—第3列&gt;=1000为Common user，反之是root or Sysuser<br>[root@along ~]# awk -F: ‘{if($3&gt;=1000) {printf “Common user: %s\n”,$1} else{printf “root or Sysuser: %s\n”,$1}}’ /etc/passwd<br>root or Sysuser: root<br>root or Sysuser: bin<br>Common user: along<br>—磁盘利用率超过40的设备名和利用率<br>[root@along ~]# df -h|awk -F% ‘/^/dev/{print $1}’|awk ‘$NF &gt; 40{print $1,$NF}’<br>/dev/mapper/cl-root 43<br>—test=100和&gt;90为very good; 90&gt;test&gt;60为good; test&lt;60为no pass<br>[root@along ~]# awk ‘BEGIN{ test=100;if(test&gt;90){print “very good”}else if(test&gt;60){ print “good”}else{print “no pass”}}’<br>very good<br>[root@along ~]# awk ‘BEGIN{ test=80;if(test&gt;90){print “very good”}else if(test&gt;60){ print “good”}else{print “no pass”}}’<br>good<br>[root@along ~]# awk ‘BEGIN{ test=50;if(test&gt;90){print “very good”}else if(test&gt;60){ print “good”}else{print “no pass”}}’<br>no pass　　</p><p>5.2 awk控制语句—while循环<br>（1）语法</p><p>1<br>while(condition){statement;…}<br>注：条件“真”，进入循环；条件“假”， 退出循环</p><p>（2）使用场景</p><p>　　对一行内的多个字段逐一类似处理时使用</p><p>　　对数组中的各元素逐一处理时使用</p><p>（3）演示</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>—以along开头的行，以：为分隔，显示每一行的每个单词和其长度<br>[root@along ~]# awk -F: ‘/^along/{i=1;while(i&lt;=NF){print $i,length($i); i++}}’ awkdemo<br>along 5<br>love 4<br>you 3<br>—以：为分隔，显示每一行的长度大于6的单词和其长度<br>[root@along ~]# awk -F: ‘{i=1;while(i&lt;=NF) {if(length($i)&gt;=6){print $i,length($i)}; i++}}’ awkdemo<br>redhat 6<br>lalala 6<br>hahaha 6<br>—计算1+2+3+…+100=5050<br>[root@along ~]# awk ‘BEGIN{i=1;sum=0;while(i&lt;=100){sum+=i;i++};print sum}’<br>5050　　</p><p>5.3 awk控制语句—do-while循环<br>（1）语法</p><p>1<br>do {statement;…}while(condition)<br>意义：无论真假，至少执行一次循环体</p><p>（2）计算1+2+3+…+100=5050</p><p>1<br>2<br>[root@along ~]# awk ‘BEGIN{sum=0;i=1;do{sum+=i;i++}while(i&lt;=100);print sum}’<br>5050　　</p><p>5.4 awk控制语句—for循环<br>（1）语法</p><p>1<br>for(expr1;expr2;expr3) {statement;…}　　</p><p>（2）特殊用法：遍历数组中的元素</p><p>1<br>for(var in array) {for-body}　　</p><p>（3）演示</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>—显示每一行的每个单词和其长度<br>[root@along ~]# awk -F: ‘{for(i=1;i&lt;=NF;i++) {print$i,length($i)}}’ awkdemo<br>hello 5<br>world 5<br>linux 5<br>redhat 6<br>lalala 6<br>hahaha 6<br>along 5<br>love 4<br>you 3<br>—求男m、女f各自的平均<br>[root@along ~]# cat sort.txt<br>xiaoming m 90<br>xiaohong f 93<br>xiaohei m 80<br>xiaofang f 99<br>[root@along ~]# awk ‘{m[$2]++;score[$2]+=$3}END{for(i in m){printf “%s:%6.2f\n”,i,score[i]/m[i]}}’ sort.txt<br>m: 85.00<br>f: 96.00　　</p><p>5.5 和shell脚本中较相似的控制语句<br>5.5.1 switch语句<br>和shell中的case很像，就不在演示了</p><p>1<br>switch(expression) {case VALUE1 or /REGEXP/:statement1; case VALUE2 or /REGEXP2/: statement2;…; default: statementn}</p><p>5.5.2 break和continue<br>1<br>2<br>3<br>4<br>5<br>6<br>—奇数相加<br>[root@along ~]# awk ‘BEGIN{sum=0;for(i=1;i&lt;=100;i++){if(i%2==0)continue;sum+=i}print sum}’<br>2500<br>—1+2+…+66<br>[root@along ~]# awk ‘BEGIN{sum=0;for(i=1;i&lt;=100;i++){if(i==66)break;sum+=i}print sum}’<br>2145</p><p>5.5.3 next<br>next：提前结束对本行处理而直接进入下一行处理（awk 自身循环）</p><p>1<br>2<br>3<br>4<br>—只打印偶数行<br>[root@along ~]# awk -F: ‘{if(NR%2!=0) next; print $1,$3}’ /etc/passwd<br>bin 1<br>adm 3　　</p><p>5.6 awk数组<br>5.6.1 关联数组：array[index-expression]<br>（1）可使用任意字符串；字符串要使用双引号括起来</p><p>（2）如果某数组元素事先不存在，在引用时，awk 会自动创建此元素，并将其值初始化为“空串”</p><p>（3）若要判断数组中是否存在某元素，要使用“index in array”格式进行遍历</p><p>（4）若要遍历数组中的每个元素，要使用for 循环：for(var in array) {for-body}</p><p>5.6.2 演示<br>（1）awk使用数组</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>[root@along ~]# cat awkdemo2<br>aaa<br>bbbb<br>aaa<br>123<br>123<br>123<br>—去除重复的行<br>[root@along ~]# awk ‘!arr[$0]++’ awkdemo2<br>aaa<br>bbbb<br>123<br>—打印文件内容，和该行重复第几次出现<br>[root@along ~]# awk ‘{!arr[$0]++;print $0,arr[$0]}’ awkdemo2<br>aaa 1<br>bbbb 1<br>aaa 2<br>123 1<br>123 2<br>123 3<br>　　分析：把每行作为下标，第一次进来，相当于print ias…一样结果为空，打印空，!取反结果为1，打印本行，并且++变为不空，下次进来相同的行就是相同的下标，本来上次的值，！取反为空，不打印，++变为不空，所以每次重复进来的行都不打印</p><p>（2）数组遍历</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>[root@along ~]# awk ‘BEGIN{abc[“ceo”]=”along”;abc[“coo”]=”mayun”;abc[“cto”]=”mahuateng”;for(i in abc){print i,abc[i]}}’<br>coo mayun<br>ceo along<br>cto mahuateng<br>[root@along ~]# awk ‘{for(i=1;i&lt;=NF;i++)abc[$i]++}END{for(j in abc)print j,abc[j]}’ awkdemo2<br>aaa 2<br>bbbb 1<br>123 3　　</p><p>5.6.3 数值\字符串处理<br>（1）数值处理</p><p> rand()：返回0和1之间一个随机数，需有个种子 srand()，没有种子，一直输出0.237788<br>演示：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>[root@along ~]# awk ‘BEGIN{print rand()}’<br>0.237788<br>[root@along ~]# awk ‘BEGIN{srand(); print rand()}’<br>0.51692<br>[root@along ~]# awk ‘BEGIN{srand(); print rand()}’<br>0.189917<br>—取0-50随机数<br>[root@along ~]# awk ‘BEGIN{srand(); print int(rand()*100%50)+1}’<br>12<br>[root@along ~]# awk ‘BEGIN{srand(); print int(rand()*100%50)+1}’<br>24　　</p><p>（2）字符串处理：</p><p> length([s]) ：返回指定字符串的长度<br> sub(r,s,[t]) ：对t 字符串进行搜索r 表示的模式匹配的内容，并将第一个匹配的内容替换为s<br> gsub(r,s,[t]) ：对t 字符串进行搜索r 表示的模式匹配的内容，并全部替换为s 所表示的内容<br> plit(s,array,[r]) ：以r 为分隔符，切割字符串s ，并将切割后的结果保存至array 所表示的数组中，第一个索引值为1, 第二个索引值为2,…<br>演示：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>[root@along ~]# echo “2008:08:08 08:08:08” | awk ‘sub(/:/,”-“,$1)’<br>2008-08:08 08:08:08<br>[root@along ~]# echo “2008:08:08 08:08:08” | awk ‘gsub(/:/,”-“,$0)’<br>2008-08-08 08-08-08<br>[root@along ~]# echo “2008:08:08 08:08:08” | awk ‘{split($0,i,”:”)}END{for(n in i){print n,i[n]}}’<br>4 08<br>5 08<br>1 2008<br>2 08<br>3 08 08　　</p><p>5.7 awk自定义函数<br>（1）格式：和bash区别：定义函数（）中需加参数，return返回值不是$?，是相当于echo输出</p><p>1<br>2<br>3<br>4<br>function name ( parameter, parameter, … ) {<br>    statements<br>    return expression<br>}　　</p><p>（2）演示</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>[root@along ~]# cat fun.awk<br>function max(v1,v2) {<br>    v1&gt;v2?var=v1:var=v2<br>    return var<br>}<br>BEGIN{a=3;b=2;print max(a,b)}<br>[root@along ~]# awk -f fun.awk<br>3　　</p><p>5.8 awk中调用shell 命令<br>（1）system 命令</p><p>　　空格是awk 中的字符串连接符，如果system中需要使用awk中的变量可以使用空格分隔，或者说除了awk 的变量外其他一律用”” 引用 起来。</p><p>1<br>2<br>3<br>4<br>5<br>6<br>[root@along ~]# awk BEGIN’{system(“hostname”) }’<br>along<br>[root@along ~]# awk ‘BEGIN{name=”along”;system(“echo “name)}’  注：”echo “ echo后有空格<br>along<br>[root@along ~]# awk ‘BEGIN{score=100; system(“echo your score is “ score) }’<br>your score is 100　　</p><p>（2）awk 脚本</p><p>将awk 程序写成脚本，直接调用或执行</p><p>示例：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>[root@along ~]# cat f1.awk<br>{if($3&gt;=1000)print $1,$3}<br>[root@along ~]# cat f2.awk<br>#!/bin/awk -f<br>{if($3 &gt;= 1000)print $1,$3}<br>[root@along ~]# chmod +x f2.awk<br>[root@along ~]# ./f2.awk -F: /etc/passwd<br>along 1000　　</p><p>（3）向awk脚本传递参数</p><p>① 格式：</p><p>1<br>awkfile var=value var2=value2… Inputfile<br>　　注意 ：在BEGIN 过程 中不可用。直到 首行输入完成以后，变量才可用 。可以通过-v  参数，让awk 在执行BEGIN 之前得到变量的值。命令行中每一个指定的变量都需要一个-v</p><p>② 示例</p><p>1<br>2<br>3<br>4<br>5<br>6<br>[root@along ~]# cat test.awk<br>#!/bin/awk -f<br>{if($3 &gt;=min &amp;&amp; $3&lt;=max)print $1,$3}<br>[root@along ~]# chmod +x test.awk<br>[root@along ~]# ./test.awk -F: min=100 max=200 /etc/passwd<br>systemd-network 192　　</p><p>6、grep awk sed对比<br>grep 主要用于搜索某些字符串；</p><p>sed，awk 用于处理文本 ；</p><p>　　grep基本是以行为单位处理文本的； 而awk可以做更细分的处理，通过指定分隔符将一行（一条记录）划分为多个字段，以字段为单位处理文本。awk中支持C语法，可以有分支条件判断、循环语句等，相当于一个小型编程语言。</p><p>　　awk功能比较多是一个编程语言了。 grep功能简单，就是一个简单的正则表达式的匹配。 awk的功能依赖于grep。</p><p>　　grep可以理解为主要作用是在一个文件中查找过滤需要的内容。awk不是过滤查找，而是文本处理工具，是把一个文件处理成你想要的格式。</p><p>　　AWK的功能是什么？与sed和grep很相似，awk是一种样式扫描与处理工具。但其功能却大大强于sed和grep。awk提供了极其强大的功能：它几乎可以完成grep和sed所能完成的全部工作，同时，它还可以可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。它具备了一个完整的语言所应具有的几乎所有精美特性。实际上，awk的确拥有自己的语言：awk程序设计语言，awk的三位创建者已将它正式定义为：样式扫描和处理语言。  使用awk的第一个理由是基于文本的样式扫描和处理是我们经常做的工作，awk所做的工作有些象数据库，但与数据库不同的是，它处理的是文本文件，这些文件没有专门的存储格式，普通的人们就能编辑、阅读、理解和处理它们。而数据库文件往往具有特殊的存储格式，这使得它们必须用数据库处理程序来处理它们。既然这种类似于数据库的处理工作我们经常会遇到，我们就应当找到处理它们的简便易行的方法，UNIX有很多这方面的工具，例如sed 、grep、sort以及find等等，awk是其中十分优秀的一种。 </p><p>　　使用awk的第二个理由是awk是一个简单的工具，当然这是相对于其强大的功能来说的。的确，UNIX有许多优秀的工具，例如UNIX天然的开发工具C语言及其延续C++就非常的优秀。但相对于它们来说，awk完成同样的功能要方便和简捷得多。这首先是因为awk提供了适应多种需要的解决方案：从解决简单问题的awk命令行到复杂而精巧的awk程序设计语言，这样做的好处是，你可以不必用复杂的方法去解决本来很简单的问题。例如，你可以用一个命令行解决简单的问题，而C不行，即使一个再简单的程序，C语言也必须经过编写、编译的全过程。其次，awk本身是解释执行的，这就使得awk程序不必经过编译的过程，同时，这也使得它与shell script程序能够很好的契合。最后，awk本身较C语言简单，虽然awk吸收了C语言很多优秀的成分，熟悉C语言会对学习awk有很大的帮助，但awk本身不须要会使用C语言——一种功能强大但需要大量时间学习才能掌握其技巧的开发工具。 </p><p>　　使用awk的第三个理由是awk是一个容易获得的工具。与C和C++语言不同，awk只有一个文件(/bin/awk)，而且几乎每个版本的UNIX都提供各自版本的awk，你完全不必费心去想如何获得awk。但C语言却不是这样，虽然C语言是UNIX天然的开发工具，但这个开发工具却是单独发行的，换言之，你必须为你的UNIX版本的C语言开发工具单独付费（当然使用D版者除外），获得并安装它，然后你才可以使用它。 </p><p>　　基于以上理由，再加上awk强大的功能，我们有理由说，如果你要处理与文本样式扫描相关的工作，awk应该是你的第一选择。在这里有一个可遵循的一般原则：如果你用普通的shell工具或shell script有困难的话，试试awk,如果awk仍不能解决问题，则便用C语言，如果C语言仍然失败，则移至C++。 </p><p>　　sed是一个非交互性文本流编辑器。它编辑文件或标准输入导出的文本拷贝。sed编辑器按照一次处理 一行的方式来处理文件（或者输入）并把输出送到屏幕上。你可以在vi和ex/ed编辑器里识别他的命令。sed把当前正在处理的行保存在一个临时缓存里，这个缓存叫做模式空间。一但sed完成了对模式空间里的行的处理（即对该行执行sed命令），就把模式空间的行送到屏幕上（除非该命令要删除该行活禁止打印）。处理完该行之后，从模式空间里删除它，然后把下一行读入模式空间，进行处理，并显示。当输入文件的最后一行处理完后，sed终止。通过把每一行存在一个临时缓存里并编辑该行，初始文件不会被修改或被破坏。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架知识整理</title>
      <link href="/2020/09/02/java-ji-he-kuang-jia-zhi-shi-zheng-li/"/>
      <url>/2020/09/02/java-ji-he-kuang-jia-zhi-shi-zheng-li/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/09/02/java-ji-he-kuang-jia-zhi-shi-zheng-li/%E9%9B%86%E5%90%88.png" alt="Java集合"></p><h2 id="1-Collection集合"><a href="#1-Collection集合" class="headerlink" title="1 Collection集合"></a>1 Collection集合</h2><h3 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h3><p>在前面基础班我们已经学习过并使用过集合ArrayList ,那么集合到底是什么呢?</p><ul><li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有啥区别呢？</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><h3 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2 集合框架"></a>1.2 集合框架</h3><p>JAVA SE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p><p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>。</p><ul><li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li></ul><p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p><p><a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/Collection%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE.png"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/Collection%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE.png" alt="Collection集合体系图"></a></p><p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。</p><p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p><ul><li>Collection接口<ul><li>定义的是所有单列集合的共性方法，所有单列集合都可以使用共性方法</li><li><strong>没有带索引的方法</strong></li></ul></li><li>List接口<ul><li>有序集合（存储和取出的元素顺序相同）</li><li>允许存储相同的元素</li><li>有索引，可以使用普通的for循环遍历</li></ul></li><li>Set接口<ul><li>不允许储存重复元素</li><li>没有索引</li></ul></li><li>TreeSet集合： 无序的集合（存储和取出的顺序可能不一致）</li><li>LinkedHashSet集合：有序的集合</li></ul><h3 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h3><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>： 把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><p>方法演示：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.Collection;public class Demo1Collection {    public static void main(String[] args) {// 创建集合对象     // 使用多态形式    Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();    // 使用方法    // 添加功能  boolean  add(String s)    coll.add("小李广");    coll.add("扫地僧");    coll.add("石破天");    System.out.println(coll);    // boolean contains(E e) 判断o是否在集合中存在    System.out.println("判断  扫地僧 是否在集合中"+coll.contains("扫地僧"));    //boolean remove(E e) 删除在集合中的o元素    System.out.println("删除石破天："+coll.remove("石破天"));    System.out.println("操作之后集合中元素:"+coll);        // size() 集合中有几个元素System.out.println("集合中有"+coll.size()+"个元素");// Object[] toArray()转换成一个Object数组    Object[] objects = coll.toArray();    // 遍历数组    for (int i = 0; i &lt; objects.length; i++) {System.out.println(objects[i]);}// void  clear() 清空集合coll.clear();System.out.println("集合中内容为："+coll);// boolean  isEmpty()  判断是否为空System.out.println(coll.isEmpty());  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p></blockquote><h2 id="2-Iterator迭代器"><a href="#2-Iterator迭代器" class="headerlink" title="2 Iterator迭代器"></a>2 Iterator迭代器</h2><h3 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h3><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>下面介绍一下迭代的概念：</p><ul><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li></ul><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class IteratorDemo {  public static void main(String[] args) {        // 使用多态方式 创建对象        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();        // 添加元素到集合        coll.add("串串星人");        coll.add("吐槽星人");        coll.add("汪星人");        //遍历        //使用迭代器 遍历   每个集合对象都有自己的迭代器        Iterator&lt;String&gt; it = coll.iterator();        //  泛型指的是 迭代出 元素的数据类型        while(it.hasNext()){ //判断是否有迭代元素            String s = it.next();//获取迭代出的元素            System.out.println(s);        }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p></blockquote><h3 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h3><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p><p><a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="迭代器的实现原理"></a></p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h3 id="2-3-增强for循环"><a href="#2-3-增强for循环" class="headerlink" title="2.3 增强for循环"></a>2.3 增强for循环</h3><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p><p>格式：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">for(元素的数据类型  变量 : Collection集合or数组){   //写操作代码}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class NBForDemo1 {    public static void main(String[] args) {int[] arr = {3,5,6,87};       //使用增强for遍历数组for(int a : arr){//a代表数组中的每个元素System.out.println(a);}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h4><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class NBFor {    public static void main(String[] args) {            Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();    coll.add("小河神");    coll.add("老河神");    coll.add("神婆");    //使用增强for遍历    for(String s :coll){//接收变量s代表 代表被遍历到的集合元素    System.out.println(s);    }}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p></blockquote><h2 id="3-泛型"><a href="#3-泛型" class="headerlink" title="3 泛型"></a>3 泛型</h2><h3 id="3-1-泛型概述"><a href="#3-1-泛型概述" class="headerlink" title="3.1 泛型概述"></a>3.1 泛型概述</h3><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><p>大家观察下面代码：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class GenericDemo {public static void main(String[] args) {Collection coll = new ArrayList();coll.add("abc");coll.add("itcast");coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放Iterator it = coll.iterator();while(it.hasNext()){//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型String str = (String) it.next();System.out.println(str.length());}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。 为什么会发生类型转换异常呢？ 我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。 怎么来解决这个问题呢？ Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p></blockquote><h3 id="3-2-使用泛型的好处"><a href="#3-2-使用泛型的好处" class="headerlink" title="3.2 使用泛型的好处"></a>3.2 使用泛型的好处</h3><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p><ul><li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li><li>避免了类型强转的麻烦。</li></ul><p>通过我们如下代码体验一下：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class GenericDemo2 {public static void main(String[] args) {        Collection&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add("abc");        list.add("itcast");        // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错        // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型        Iterator&lt;String&gt; it = list.iterator();        while(it.hasNext()){            String str = it.next();            //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型            System.out.println(str.length());        }}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p></blockquote><h3 id="3-3-泛型的定义与使用"><a href="#3-3-泛型的定义与使用" class="headerlink" title="3.3 泛型的定义与使用"></a>3.3 泛型的定义与使用</h3><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><h4 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h4><p>定义格式：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">修饰符 class 类名&lt;代表泛型的变量&gt; {  }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，API中的ArrayList集合：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">class ArrayList&lt;E&gt;{     public boolean add(E e){ }    public E get(int index){ }   ....}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用泛型： 即什么时候确定泛型。</p><h4 id="在创建对象的时候确定泛型"><a href="#在创建对象的时候确定泛型" class="headerlink" title="在创建对象的时候确定泛型"></a>在创建对象的时候确定泛型</h4><p>例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">class ArrayList&lt;String&gt;{      public boolean add(String e){ }     public String get(int index){  }     ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p><p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">class ArrayList&lt;Integer&gt; {      public boolean add(Integer e) { }     public Integer get(int index) {  }     ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例自定义泛型类</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class MyGenericClass&lt;MVP&gt; {//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型private MVP mvp;         public void setMVP(MVP mvp) {        this.mvp = mvp;    }         public MVP getMVP() {        return mvp;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用:</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class GenericClassDemo {  public static void main(String[] args) {          // 创建一个泛型为String的类         MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;();             // 调用setMVP         my.setMVP("大胡子登登");         // 调用getMVP         String mvp = my.getMVP();         System.out.println(mvp);         //创建一个泛型为Integer的类         MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;();          my2.setMVP(123);              Integer mvp2 = my2.getMVP();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h4><p>定义格式：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){  }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class MyGenericMethod {      public &lt;MVP&gt; void show(MVP mvp) {    System.out.println(mvp.getClass());    }        public &lt;MVP&gt; MVP show2(MVP mvp) {    return mvp;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class GenericMethodDemo {    public static void main(String[] args) {        // 创建对象        MyGenericMethod mm = new MyGenericMethod();        // 演示看方法提示        mm.show("aaa");        mm.show(123);        mm.show(12.45);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h4><p>定义格式：</p><p>Code</p><pre class="line-numbers language-none"><code class="language-none">修饰符 interface接口名&lt;代表泛型的变量&gt; {  }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public interface MyGenericInterface&lt;E&gt;{public abstract void add(E e);public abstract E getE();  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p>例如</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class MyImp1 implements MyGenericInterface&lt;String&gt; {@Override    public void add(String e) {        // 省略...    }@Overridepublic String getE() {return null;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，泛型E的值就是String类型。</p><p><strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><p>例如</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; {@Overridepublic void add(E e) {        // 省略...}@Overridepublic E getE() {return null;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>确定泛型：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">/* * 使用 */public class GenericInterface {    public static void main(String[] args) {        MyImp2&lt;String&gt;  my = new MyImp2&lt;String&gt;();          my.add("aa");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-泛型通配符"><a href="#3-4-泛型通配符" class="headerlink" title="3.4 泛型通配符"></a>3.4 泛型通配符</h3><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举个例子大家理解使用即可：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) {    Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;();    getElement(list1);    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();    getElement(list2);}public static void getElement(Collection&lt;?&gt; coll){}//？代表可以接收任意类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>tips:泛型不存在继承关系 Collection list = new ArrayList();这种是错误的。</p></blockquote><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) {    Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();    Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;();    Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;();        getElement(list1);    getElement(list2);//报错    getElement(list3);    getElement(list4);//报错      getElement2(list1);//报错    getElement2(list2);//报错    getElement2(list3);    getElement2(list4);  }// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll){}// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="4-数据结构"><a href="#4-数据结构" class="headerlink" title="4 数据结构"></a>4 数据结构</h2><p>当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。</p><p>现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。</p><p>我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。</p><p>我们将常见的数据结构：<strong>堆栈、队列、数组、链表和红黑树</strong> 。</p><h3 id="4-1-栈"><a href="#4-1-栈" class="headerlink" title="4.1 栈"></a>4.1 栈</h3><ul><li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li></ul><p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p><ul><li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p></li><li><p>栈的入口、出口的都是栈的顶端位置。</p><p><a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E5%A0%86%E6%A0%88.png"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E5%A0%86%E6%A0%88.png" alt="img"></a></p></li></ul><p>这里两个名词需要注意：</p><ul><li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li><li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li></ul><h3 id="4-2-队列"><a href="#4-2-队列" class="headerlink" title="4.2 队列"></a>4.2 队列</h3><ul><li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li><li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li></ul><p><a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E9%98%9F%E5%88%97%E5%9B%BE.bmp"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E9%98%9F%E5%88%97%E5%9B%BE.bmp" alt="img"></a></p><h3 id="4-3-数组"><a href="#4-3-数组" class="headerlink" title="4.3 数组"></a>4.3 数组</h3><ul><li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li></ul><p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p><p><a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%BF%AB.png"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%BF%AB.png" alt="img"></a></p></li><li><p>增删元素慢</p><ul><li><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图<a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0.png"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0.png" alt="img"></a></li><li><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图<a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4.png"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4.png" alt="img"></a></li></ul></li></ul><h3 id="4-4-链表"><a href="#4-4-链表" class="headerlink" title="4.4 链表"></a>4.4 链表</h3><ul><li><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</p><p><a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9.png"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9.png" alt="img"></a></p></li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p><p><a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="img"></a></p></li><li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p></li><li><p>增删元素快：</p><ul><li><p>增加元素：只需要修改连接下个元素的地址即可。</p><p><a href="https://foochane.cn/article/image/%E5%A2%9E%E5%8A%A0%E7%BB%93%E7%82%B9.png"><img src="https://foochane.cn/article/image/%E5%A2%9E%E5%8A%A0%E7%BB%93%E7%82%B9.png" alt="img"></a></p></li><li><p>删除元素：只需要修改连接下个元素的地址即可。</p><p><a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.bmp"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.bmp" alt="img"></a></p></li></ul></li></ul><h3 id="4-5-红黑树"><a href="#4-5-红黑树" class="headerlink" title="4.5 红黑树"></a>4.5 红黑树</h3><ul><li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li></ul><p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p><p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p><p>如图：</p><p><a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E4%BA%8C%E5%8F%89%E6%A0%91.bmp"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E4%BA%8C%E5%8F%89%E6%A0%91.bmp" alt="img"></a></p><p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p><p>红黑树的约束:</p><ol><li><p>节点可以是红色的或者黑色的</p></li><li><p>根节点是黑色的</p></li><li><p>叶子节点(特指空节点)是黑色的</p></li><li><p>每个红色节点的子节点都是黑色的</p></li><li><p>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</p></li></ol><p>红黑树的特点:</p><pre class="line-numbers language-none"><code class="language-none">速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-List集合"><a href="#5-List集合" class="headerlink" title="5 List集合"></a>5 List集合</h2><p>我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？</p><p>接下来，我们一起学习Collection中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p><h3 id="5-1-List接口介绍"><a href="#5-1-List接口介绍" class="headerlink" title="5.1 List接口介绍"></a>5.1 List接口介绍</h3><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p><p>看完API，我们总结一下：</p><p>List接口特点：</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><blockquote><p>tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。</p></blockquote><h3 id="5-2-List接口中常用方法"><a href="#5-2-List接口中常用方法" class="headerlink" title="5.2 List接口中常用方法"></a>5.2 List接口中常用方法</h3><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><p>List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class ListDemo {    public static void main(String[] args) {// 创建List集合对象    List&lt;String&gt; list = new ArrayList&lt;String&gt;();        // 往 尾部添加 指定元素    list.add("图图");    list.add("小美");    list.add("不高兴");        System.out.println(list);    // add(int index,String s) 往指定位置添加    list.add(1,"没头脑");        System.out.println(list);    // String remove(int index) 删除指定位置元素  返回被删除元素    // 删除索引位置为2的元素     System.out.println("删除索引位置为2的元素");    System.out.println(list.remove(2));        System.out.println(list);        // String set(int index,String s)    // 在指定位置 进行 元素替代（改）     // 修改指定位置元素    list.set(0, "三毛");    System.out.println(list);        // String get(int index)  获取指定位置元素        // 跟size() 方法一起用  来 遍历的     for(int i = 0;i&lt;list.size();i++){    System.out.println(list.get(i));    }    //还可以使用增强for    for (String string : list) {System.out.println(string);}  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-List的子类"><a href="#6-List的子类" class="headerlink" title="6 List的子类"></a>6 List的子类</h2><h3 id="6-1-ArrayList集合"><a href="#6-1-ArrayList集合" class="headerlink" title="6.1 ArrayList集合"></a>6.1 ArrayList集合</h3><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p><h3 id="6-2-LinkedList集合"><a href="#6-2-LinkedList集合" class="headerlink" title="6.2 LinkedList集合"></a>6.2 LinkedList集合</h3><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><blockquote><p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p></blockquote><p><a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="img"></a></p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p><p>方法演示：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class LinkedListDemo {    public static void main(String[] args) {        LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;();        //添加元素        link.addFirst("abc1");        link.addFirst("abc2");        link.addFirst("abc3");        System.out.println(link);        // 获取元素        System.out.println(link.getFirst());        System.out.println(link.getLast());        // 删除元素        System.out.println(link.removeFirst());        System.out.println(link.removeLast());        while (!link.isEmpty()) { //判断集合是否为空            System.out.println(link.pop()); //弹出集合中的栈顶元素        }        System.out.println(link);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-Set接口"><a href="#7-Set接口" class="headerlink" title="7 Set接口"></a>7 Set接口</h2><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p><p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p><blockquote><p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p></blockquote><h3 id="7-1-HashSet集合介绍"><a href="#7-1-HashSet集合介绍" class="headerlink" title="7.1 HashSet集合介绍"></a>7.1 HashSet集合介绍</h3><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，由于我们暂时还未学习，先做了解。</p><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class HashSetDemo {    public static void main(String[] args) {        //创建 Set集合        HashSet&lt;String&gt;  set = new HashSet&lt;String&gt;();        //添加元素        set.add(new String("cba"));        set.add("abc");        set.add("bac");         set.add("cba");          //遍历        for (String name : set) {            System.out.println(name);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果如下，说明集合中不能存储重复元素：</p><p>Code</p><pre class="line-numbers language-none"><code class="language-none">cbaabcbac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p></blockquote><h3 id="7-2-HashSet集合存储数据的结构（哈希表）"><a href="#7-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="7.2 HashSet集合存储数据的结构（哈希表）"></a>7.2 HashSet集合存储数据的结构（哈希表）</h3><p>什么是哈希表呢？</p><p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。<a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E5%93%88%E5%B8%8C%E8%A1%A8.png"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="img"></a></p><p>看到这张图就有人要问了，这个是怎么存储的呢？</p><p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p><p><a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="img"></a></p><p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p><h3 id="7-3-HashSet存储自定义类型元素"><a href="#7-3-HashSet存储自定义类型元素" class="headerlink" title="7.3 HashSet存储自定义类型元素"></a>7.3 HashSet存储自定义类型元素</h3><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p><p>创建自定义Student类</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class Student {    private String name;    private int age;    public Student() {    }    public Student(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public boolean equals(Object o) {        if (this == o)            return true;        if (o == null || getClass() != o.getClass())            return false;        Student student = (Student) o;        return age == student.age &amp;&amp;               Objects.equals(name, student.name);    }    @Override    public int hashCode() {        return Objects.hash(name, age);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class HashSetDemo2 {    public static void main(String[] args) {        //创建集合对象   该集合中存储 Student类型对象        HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;();        //存储         Student stu = new Student("于谦", 43);        stuSet.add(stu);        stuSet.add(new Student("郭德纲", 44));        stuSet.add(new Student("于谦", 43));        stuSet.add(new Student("郭麒麟", 23));        stuSet.add(stu);        for (Student stu2 : stuSet) {            System.out.println(stu2);        }    }}执行结果：Student [name=郭德纲, age=44]Student [name=于谦, age=43]Student [name=郭麒麟, age=23]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-LinkedHashSet"><a href="#7-3-LinkedHashSet" class="headerlink" title="7.3 LinkedHashSet"></a>7.3 LinkedHashSet</h3><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p><p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p><p>演示代码如下:</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class LinkedHashSetDemo {public static void main(String[] args) {Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;();set.add("bbb");set.add("aaa");set.add("abc");set.add("bbc");        Iterator&lt;String&gt; it = set.iterator();while (it.hasNext()) {System.out.println(it.next());}}}结果：  bbb  aaa  abc  bbc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-4-可变参数"><a href="#7-4-可变参数" class="headerlink" title="7.4 可变参数"></a>7.4 可变参数</h3><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">修饰符 返回值类型 方法名(参数类型... 形参名){  }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其实这个书写完全等价与</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">修饰符 返回值类型 方法名(参数类型[] 形参名){  }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p><p><strong>JDK1.5</strong>以后。出现了简化操作。<strong>…</strong> 用在参数上，称之为可变参数。</p><p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p><p>代码演示：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class ChangeArgs {    public static void main(String[] args) {        int[] arr = { 1, 4, 62, 431, 2 };        int sum = getSum(arr);        System.out.println(sum);        //  6  7  2 12 2121        // 求 这几个元素和 6  7  2 12 2121        int sum2 = getSum(6, 7, 2, 12, 2121);        System.out.println(sum2);    }    /*     * 完成数组  所有元素的求和 原始写法           public static int getSum(int[] arr){        int sum = 0;        for(int a : arr){            sum += a;        }                return sum;      }    */    //可变参数写法    public static int getSum(int... arr) {        int sum = 0;        for (int a : arr) {            sum += a;        }        return sum;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</p><p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p></blockquote><h2 id="8-Collections"><a href="#8-Collections" class="headerlink" title="8 Collections"></a>8 Collections</h2><h3 id="8-1-常用功能"><a href="#8-1-常用功能" class="headerlink" title="8.1 常用功能"></a>8.1 常用功能</h3><ul><li><p><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</p></li><li><p><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code>:往集合中添加一些元素。</p></li><li><p><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</p></li><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p></li><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</p></li></ul><p>代码演示：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class CollectionsDemo {    public static void main(String[] args) {        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();        //原来写法        //list.add(12);        //list.add(14);        //list.add(15);        //list.add(1000);        //采用工具类 完成 往集合中添加元素          Collections.addAll(list, 5, 222, 1，2);        System.out.println(list);        //排序方法         Collections.sort(list);        System.out.println(list);    }}结果：[5, 222, 1, 2][1, 2, 5, 222]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？</p><p>我们发现还有个方法没有讲，<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。</p><h3 id="8-2-Comparator比较器"><a href="#8-2-Comparator比较器" class="headerlink" title="8.2 Comparator比较器"></a>8.2 Comparator比较器</h3><p>我们还是先研究这个方法</p><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p><p>不过这次存储的是字符串类型。</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class CollectionsDemo2 {    public static void main(String[] args) {        ArrayList&lt;String&gt;  list = new ArrayList&lt;String&gt;();        list.add("cba");        list.add("aba");        list.add("sba");        list.add("nba");        //排序方法        Collections.sort(list);        System.out.println(list);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><p>Code</p><pre class="line-numbers language-none"><code class="language-none">[aba, cba, nba, sba]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p><p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p><p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p><ul><li><p><code>public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。</p><p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p></blockquote></li></ul><p>操作如下:</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class CollectionsDemo3 {    public static void main(String[] args) {        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add("cba");        list.add("aba");        list.add("sba");        list.add("nba");        //排序方法  按照第一个单词的降序        Collections.sort(list, new Comparator&lt;String&gt;() {            @Override            public int compare(String o1, String o2) {                return o2.charAt(0) - o1.charAt(0);            }        });        System.out.println(list);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><p>Code</p><pre class="line-numbers language-none"><code class="language-none">[sba, nba, cba, aba]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="8-3-简述Comparable和Comparator两个接口的区别。"><a href="#8-3-简述Comparable和Comparator两个接口的区别。" class="headerlink" title="8.3 简述Comparable和Comparator两个接口的区别。"></a>8.3 简述Comparable和Comparator两个接口的区别。</h3><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p><h3 id="8-4-练习"><a href="#8-4-练习" class="headerlink" title="8.4 练习"></a>8.4 练习</h3><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p><p>Student 初始类</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class Student{    private String name;    private int age;    public Student() {    }    public Student(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public String toString() {        return "Student{" +               "name='" + name + '\'' +               ", age=" + age +               '}';    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class Demo {    public static void main(String[] args) {        // 创建四个学生对象 存储到集合中        ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;();        list.add(new Student("rose",18));        list.add(new Student("jack",16));        list.add(new Student("abc",16));        list.add(new Student("ace",17));        list.add(new Student("mark",16));        /*          让学生 按照年龄排序 升序         *///        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口        for (Student student : list) {            System.out.println(student);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现，当我们调用Collections.sort()方法的时候 程序报错了。</p><p>原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。</p><p>于是我们就完成了Student类的一个实现，如下：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class Student implements Comparable&lt;Student&gt;{    ....    @Override    public int compareTo(Student o) {        return this.age-o.age;//升序    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次测试，代码就OK 了效果如下：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">Student{name='jack', age=16}Student{name='abc', age=16}Student{name='mark', age=16}Student{name='ace', age=17}Student{name='rose', age=18}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-5-扩展"><a href="#8-5-扩展" class="headerlink" title="8.5 扩展"></a>8.5 扩展</h3><p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor c)方式，自己定义规则：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">Collections.sort(list, new Comparator&lt;Student&gt;() {    @Override    public int compare(Student o1, Student o2) {        return o2.getAge()-o1.getAge();//以学生的年龄降序    }});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果：</p><p>Code</p><pre class="line-numbers language-none"><code class="language-none">Student{name='rose', age=18}Student{name='ace', age=17}Student{name='jack', age=16}Student{name='abc', age=16}Student{name='mark', age=16}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要规则更多一些，可以参考下面代码：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">Collections.sort(list, new Comparator&lt;Student&gt;() {            @Override            public int compare(Student o1, Student o2) {                // 年龄降序                int result = o2.getAge()-o1.getAge();//年龄降序                if(result==0){//第一个规则判断完了 下一个规则 姓名的首字母 升序                    result = o1.getName().charAt(0)-o2.getName().charAt(0);                }                return result;            }        });<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><p>Code</p><pre class="line-numbers language-none"><code class="language-none">Student{name='rose', age=18}Student{name='ace', age=17}Student{name='abc', age=16}Student{name='jack', age=16}Student{name='mark', age=16}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-Map集合"><a href="#9-Map集合" class="headerlink" title="9 Map集合"></a>9 Map集合</h2><h3 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h3><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p><p><a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/Collection%E4%B8%8EMap.bmp"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/Collection%E4%B8%8EMap.bmp" alt="img"></a></p><ul><li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li><li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li><li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li></ul><h3 id="9-2-Map常用子类"><a href="#9-2-Map常用子类" class="headerlink" title="9.2 Map常用子类"></a>9.2 Map常用子类</h3><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p><ul><li>**HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li>**LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li></ul><blockquote><p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p></blockquote><h3 id="9-3-Map接口中的常用方法"><a href="#9-3-Map接口中的常用方法" class="headerlink" title="9.3 Map接口中的常用方法"></a>9.3 Map接口中的常用方法</h3><p>Map接口中定义了很多方法，常用的如下：</p><ul><li><code>public V put(K key, V value)</code>: 把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>boolean containsKey(Object key)</code> 判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p>Map接口的方法演示</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class MapDemo {    public static void main(String[] args) {        //创建 map对象        HashMap&lt;String, String&gt;  map = new HashMap&lt;String, String&gt;();        //添加元素到集合        map.put("黄晓明", "杨颖");        map.put("文章", "马伊琍");        map.put("邓超", "孙俪");        System.out.println(map);        //String remove(String key)        System.out.println(map.remove("邓超"));        System.out.println(map);        // 想要查看 黄晓明的媳妇 是谁        System.out.println(map.get("黄晓明"));        System.out.println(map.get("邓超"));        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>tips:</p><p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中；</p><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。</p></blockquote><h3 id="9-4-Map集合遍历键找值方式"><a href="#9-4-Map集合遍历键找值方式" class="headerlink" title="9.4 Map集合遍历键找值方式"></a>9.4 Map集合遍历键找值方式</h3><p>键找值方式：即通过元素中的键，获取键所对应的值</p><p>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li></ol><p>代码演示：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class MapDemo01 {    public static void main(String[] args) {        //创建Map集合对象         HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();        //添加元素到集合         map.put("胡歌", "霍建华");        map.put("郭德纲", "于谦");        map.put("薛之谦", "大张伟");        //获取所有的键  获取键集        Set&lt;String&gt; keys = map.keySet();        // 遍历键集 得到 每一个键        for (String key : keys) {          //key  就是键            //获取对应值            String value = map.get(key);            System.out.println(key+"的CP是："+value);        }      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遍历图解：</p><p><a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%80.bmp"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%80.bmp" alt="img"></a></p><h3 id="9-5-Entry键值对对象"><a href="#9-5-Entry键值对对象" class="headerlink" title="9.5 Entry键值对对象"></a>9.5 Entry键值对对象</h3><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p><p>既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p><ul><li><code>public K getKey()</code>：获取Entry对象中的键。</li><li><code>public V getValue()</code>：获取Entry对象中的值。</li></ul><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h3 id="9-6-Map集合遍历键值对方式"><a href="#9-6-Map集合遍历键值对方式" class="headerlink" title="9.6 Map集合遍历键值对方式"></a>9.6 Map集合遍历键值对方式</h3><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>操作步骤与图解：</p><ol><li>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</li><li>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</li><li>通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:<code>getkey() getValue()</code></li></ol><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class MapDemo02 {    public static void main(String[] args) {        // 创建Map集合对象         HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();        // 添加元素到集合         map.put("胡歌", "霍建华");        map.put("郭德纲", "于谦");        map.put("薛之谦", "大张伟");        // 获取 所有的 entry对象  entrySet        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();        // 遍历得到每一个entry对象        for (Entry&lt;String, String&gt; entry : entrySet) {           // 解析             String key = entry.getKey();            String value = entry.getValue();              System.out.println(key+"的CP是:"+value);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遍历图解：</p><p><a href="https://raw.githubusercontent.com/foochane/java-learning/master/image/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%BA%8C.bmp"><img src="https://raw.githubusercontent.com/foochane/java-learning/master/image/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%BA%8C.bmp" alt="img"></a></p><blockquote><p>tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p></blockquote><h3 id="9-7-HashMap存储自定义类型键值"><a href="#9-7-HashMap存储自定义类型键值" class="headerlink" title="9.7 HashMap存储自定义类型键值"></a>9.7 HashMap存储自定义类型键值</h3><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。</p><blockquote><p>注意，学生姓名相同并且年龄相同视为同一名学生。</p></blockquote><p>编写学生类：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class Student {    private String name;    private int age;    public Student() {    }    public Student(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public boolean equals(Object o) {        if (this == o)            return true;        if (o == null || getClass() != o.getClass())            return false;        Student student = (Student) o;        return age == student.age &amp;&amp; Objects.equals(name, student.name);    }    @Override    public int hashCode() {        return Objects.hash(name, age);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写测试类：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class HashMapTest {    public static void main(String[] args) {        //1,创建Hashmap集合对象。        Map&lt;Student,String&gt;map = new HashMap&lt;Student,String&gt;();        //2,添加元素。        map.put(newStudent("lisi",28), "上海");        map.put(newStudent("wangwu",22), "北京");        map.put(newStudent("zhaoliu",24), "成都");        map.put(newStudent("zhouqi",25), "广州");        map.put(newStudent("wangwu",22), "南京");                //3,取出元素。键找值方式        Set&lt;Student&gt;keySet = map.keySet();        for(Student key: keySet){            Stringvalue = map.get(key);            System.out.println(key.toString()+"....."+value);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li><li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li></ul><h3 id="9-8-LinkedHashMap"><a href="#9-8-LinkedHashMap" class="headerlink" title="9.8 LinkedHashMap"></a>9.8 LinkedHashMap</h3><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</p><p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class LinkedHashMapDemo {    public static void main(String[] args) {        LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;();        map.put("邓超", "孙俪");        map.put("李晨", "范冰冰");        map.put("刘德华", "朱丽倩");        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();        for (Entry&lt;String, String&gt; entry : entrySet) {            System.out.println(entry.getKey() + "  " + entry.getValue());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果:</p><p>Code</p><pre class="line-numbers language-none"><code class="language-none">邓超  孙俪李晨  范冰冰刘德华  朱丽倩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="9-9-Map集合练习"><a href="#9-9-Map集合练习" class="headerlink" title="9.9 Map集合练习"></a>9.9 Map集合练习</h3><p><strong>需求：</strong></p><p>计算一个字符串中每个字符出现次数。</p><p><strong>分析：</strong></p><ol><li>获取一个字符串对象</li><li>创建一个Map集合，键代表字符，值代表次数。</li><li>遍历字符串得到每个字符。</li><li>判断Map中是否有该键。</li><li>如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。</li><li>打印最终结果</li></ol><p><strong>代码：</strong></p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class MapTest {public static void main(String[] args) {        //友情提示        System.out.println("请录入一个字符串:");        String line = new Scanner(System.in).nextLine();        // 定义 每个字符出现次数的方法        findChar(line);    }    private static void findChar(String line) {        //1:创建一个集合 存储  字符 以及其出现的次数        HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();        //2:遍历字符串        for (int i = 0; i &lt; line.length(); i++) {            char c = line.charAt(i);            //判断 该字符 是否在键集中            if (!map.containsKey(c)) {//说明这个字符没有出现过                //那就是第一次                map.put(c, 1);            } else {                //先获取之前的次数                Integer count = map.get(c);                //count++;                //再次存入  更新                map.put(c, ++count);            }        }        System.out.println(map);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-JDK9对集合添加的优化"><a href="#10-JDK9对集合添加的优化" class="headerlink" title="10 JDK9对集合添加的优化"></a>10 JDK9对集合添加的优化</h2><p>通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class Demo01 {    public static void main(String[] args) {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add("abc");        list.add("def");        list.add("ghi");        System.out.println(list);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p><p>例子：</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class HelloJDK9 {      public static void main(String[] args) {          Set&lt;String&gt; str1=Set.of("a","b","c");          //str1.add("c");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合          System.out.println(str1);          Map&lt;String,Integer&gt; str2=Map.of("a",1,"b",2);          System.out.println(str2);          List&lt;String&gt; str3=List.of("a","b");          System.out.println(str3);      }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意以下两点：</p><blockquote><p>1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如 HashSet，ArrayList等待；</p><p>2:返回的集合是不可变的；</p></blockquote><h2 id="11-集合案例实现"><a href="#11-集合案例实现" class="headerlink" title="11 集合案例实现"></a>11 集合案例实现</h2><h3 id="11-1-案例介绍"><a href="#11-1-案例介绍" class="headerlink" title="11.1 案例介绍"></a>11.1 案例介绍</h3><p>模拟斗地主洗牌发牌</p><p>按照斗地主的规则，完成洗牌发牌的动作。</p><p>具体规则：</p><ol><li>组装54张扑克牌将</li><li>54张牌顺序打乱</li><li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li><li>查看三人各自手中的牌、底牌，并按照牌的大小排序(代码二）</li></ol><blockquote><p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p></blockquote><h3 id="11-2-代码一"><a href="#11-2-代码一" class="headerlink" title="11.2 代码一"></a>11.2 代码一</h3><ol><li><p>准备牌：</p><p>牌可以设计为一个ArrayList,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</p></li><li><p>发牌</p><p>将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p></li><li><p>看牌</p><p>直接打印每个集合。</p></li></ol><p>代码实现</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">import java.util.ArrayList;import java.util.Collections;public class Poker {    public static void main(String[] args) {        /*        * 1: 准备牌操作        */        //1.1 创建牌盒 将来存储牌面的         ArrayList&lt;String&gt; pokerBox = new ArrayList&lt;String&gt;();        //1.2 创建花色集合        ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;();        //1.3 创建数字集合        ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;();        //1.4 分别给花色 以及 数字集合添加元素        colors.add("♥");        colors.add("♦");        colors.add("♠");        colors.add("♣");        for(int i = 2;i&lt;=10;i++){            numbers.add(i+"");        }        numbers.add("J");        numbers.add("Q");        numbers.add("K");        numbers.add("A");        //1.5 创造牌  拼接牌操作        // 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中        for (String color : colors) {            //color每一个花色             //遍历数字集合            for(String number : numbers){                //结合                String card = color+number;                //存储到牌盒中                pokerBox.add(card);            }        }        //1.6大王小王        pokerBox.add("小王");        pokerBox.add("大王");          // System.out.println(pokerBox);        //洗牌 是不是就是将  牌盒中 牌的索引打乱         // Collections类  工具类  都是 静态方法        // shuffer方法           /*         * static void shuffle(List&lt;?&gt; list)          *     使用默认随机源对指定列表进行置换。          */        //2:洗牌        Collections.shuffle(pokerBox);        //3 发牌        //3.1 创建 三个 玩家集合  创建一个底牌集合        ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;();          //遍历 牌盒  必须知道索引           for(int i = 0;i&lt;pokerBox.size();i++){            //获取 牌面            String card = pokerBox.get(i);            //留出三张底牌 存到 底牌集合中            if(i&gt;=51){//存到底牌集合中                dipai.add(card);            } else {                //玩家1   %3  ==0                if(i%3==0){                  player1.add(card);                }else if(i%3==1){//玩家2                  player2.add(card);                }else{//玩家3                  player3.add(card);                }            }        }        //看看        System.out.println("令狐冲："+player1);        System.out.println("田伯光："+player2);        System.out.println("绿竹翁："+player3);        System.out.println("底牌："+dipai);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-3-代码二"><a href="#11-3-代码二" class="headerlink" title="11.3 代码二"></a>11.3 代码二</h3><ol><li>准备牌：</li></ol><p>完成数字与纸牌的映射关系：</p><p>使用双列<code>Map(HashMap)</code>集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p><ol><li>洗牌：</li></ol><p>通过数字完成洗牌发牌</p><ol><li>发牌：</li></ol><p>将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p><p>存放的过程中要求数字大小与斗地主规则的大小对应。</p><p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p><ol><li>看牌：</li></ol><p>通过Map集合找到对应字符展示。</p><p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p><p>实现代码</p><p>Java</p><pre class="line-numbers language-none"><code class="language-none">public class Poker {    public static void main(String[] args) {        /*         * 1组装54张扑克牌         */        // 1.1 创建Map集合存储        HashMap&lt;Integer, String&gt; pokerMap = new HashMap&lt;Integer, String&gt;();        // 1.2 创建 花色集合 与 数字集合        ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;();        // 1.3 存储 花色 与数字        Collections.addAll(colors, "♦", "♣", "♥", "♠");        Collections.addAll(numbers, "2", "A", "K", "Q", "J", "10", "9", "8", "7", "6", "5", "4", "3");        // 设置 存储编号变量        int count = 1;        pokerMap.put(count++, "大王");        pokerMap.put(count++, "小王");        // 1.4 创建牌 存储到map集合中        for (String number : numbers) {            for (String color : colors) {                String card = color + number;                pokerMap.put(count++, card);            }        }        /*         * 2 将54张牌顺序打乱         */        // 取出编号 集合        Set&lt;Integer&gt; numberSet = pokerMap.keySet();        // 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中        ArrayList&lt;Integer&gt; numberList = new ArrayList&lt;Integer&gt;();        numberList.addAll(numberSet);        // 打乱顺序        Collections.shuffle(numberList);        // 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌        // 3.1 发牌的编号        // 创建三个玩家编号集合 和一个 底牌编号集合        ArrayList&lt;Integer&gt; noP1 = new ArrayList&lt;Integer&gt;();        ArrayList&lt;Integer&gt; noP2 = new ArrayList&lt;Integer&gt;();        ArrayList&lt;Integer&gt; noP3 = new ArrayList&lt;Integer&gt;();        ArrayList&lt;Integer&gt; dipaiNo = new ArrayList&lt;Integer&gt;();        // 3.2发牌的编号        for (int i = 0; i &lt; numberList.size(); i++) {            // 获取该编号            Integer no = numberList.get(i);            // 发牌            // 留出底牌            if (i &gt;= 51) {                dipaiNo.add(no);            } else {                if (i % 3 == 0) {                    noP1.add(no);                } else if (i % 3 == 1) {                    noP2.add(no);                } else {                    noP3.add(no);                }            }        }        // 4 查看三人各自手中的牌（按照牌的大小排序）、底牌        // 4.1 对手中编号进行排序        Collections.sort(noP1);        Collections.sort(noP2);        Collections.sort(noP3);        Collections.sort(dipaiNo);        // 4.2 进行牌面的转换        // 创建三个玩家牌面集合 以及底牌牌面集合        ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;();        // 4.3转换        for (Integer i : noP1) {            // 4.4 根据编号找到 牌面 pokerMap            String card = pokerMap.get(i);            // 添加到对应的 牌面集合中            player1.add(card);        }        for (Integer i : noP2) {            String card = pokerMap.get(i);            player2.add(card);        }        for (Integer i : noP3) {            String card = pokerMap.get(i);            player3.add(card);        }        for (Integer i : dipaiNo) {            String card = pokerMap.get(i);            dipai.add(card);        }        //4.5 查看        System.out.println("令狐冲："+player1);        System.out.println("石破天："+player2);        System.out.println("鸠摩智："+player3);        System.out.println("底牌："+dipai);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试用例设计方法</title>
      <link href="/2020/08/24/ce-shi-yong-li-she-ji-fang-fa/"/>
      <url>/2020/08/24/ce-shi-yong-li-she-ji-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="测试用例设计方法"><a href="#测试用例设计方法" class="headerlink" title="测试用例设计方法"></a>测试用例设计方法</h1><p>本篇由本人整理<em><strong>黑盒、白盒、接口测试</strong></em>一系列用例设计方法。</p><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p>黑盒测试用例设计方法包括<strong>等价类划分法、边界值分析法、错误推测法、因果图法、判定表驱动法、正交试验设计法、功能图法、场景图法</strong>等。</p><h3 id="（一）等价类划分法"><a href="#（一）等价类划分法" class="headerlink" title="（一）等价类划分法"></a>（一）等价类划分法</h3><p>定义：等价类划分法是把所有可能输入的数据，即程序的输入域划分策划国内若干部分（子集），然后从每一个子集中选取少数具有代表性的数据作为测试用例。方法是一种重要的、常用的黑盒测试用例设计方法。</p><p>等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，并合理地假定：测试某等价类的代表值就等于对这一类其他值的测试，因此，可以把全部输入数据合理划分为若干等价类，在每一个等价类中取一个数据作为测试的输入条件就可以用少量代表性的测试数据取得较好的测试结果。等价类划分有两种不同的情况：有效等价类和无效等价类。</p><p>有效等价类，是指对于程序的规格说明来说是合理的、有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现了规格说明所规定的功能和性能。</p><p>无效等价类 指对程序的规格说明是不合理的或无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能多个。</p><p>划分标准：</p><ol><li><p>完备测试、避免冗余</p></li><li><p>划分等价类重要的是：集合的划分、划分为互不相交的一组子集，而子集的并是整个集合</p></li><li><p>并是整个集合：备性</p></li><li><p>子集互不相交：保证一种形式的无冗余性</p></li><li><p>同一类中标识（选择）一个测试用例，同一等价类中，往往处理相同，相同处理映射到“相同的执行路径”。</p></li></ol><p>划分方法：</p><ol><li> 在输入条件规定了取值范围或值的个数的情况下，则可以确立一个有效等价类和两个无效等价类。如：输入值是学生成绩，范围是0~100；</li></ol><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=7938ea3701012c76&amp;url=http://s16.sinaimg.cn/orignal/7938ea37gbe187fe610bf"><img src="http://s16.sinaimg.cn/middle/7938ea37gbe187fe610bf&amp;690" alt="测试用例设计方法---等价类划分法"></a></p><p>2）在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可确立一个有效等价类和一个无效等价类：</p><p>3）在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类。布尔量是一个二值枚举类型, 一个布尔量具有两种状态: true 和 false 。</p><p>4）在规定了输入数据的一组值（假定n个），并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类。</p><p> 例：输入条件说明学历可为：专科、本科、硕士、博士四种之一，则分别取这四种的四个值作为四个有效等价类，另外把四种学历之外的任何学历作为无效等价类。</p><p>5）在规定了输入数据必须遵守的规则情况下，可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）；</p><p>6）在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应在将该等价类进一步的划分为更小的等价类。</p><p>转化为测试用例：</p><p>在确立了等价类后，可建立等价类表，列出所有划分出的等价类输入条件：有效等价类、无效等价类，然后从划分出的等价类中按以下三个原则设计测试用例：</p><p>1）为每一个等价类规定一个唯一的编号；</p><p>2）设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止；</p><p>3）设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。</p><p>实例1：三角形问题</p><p>某程序规定：“输入三个整数a、b、c分别作为三边的边长构成三角形。通过程序判定所构成的三角形的类型，当此三角形为一般三角形、等腰三角形、等边三角形时，分别做计算。。。”用等价类划分方法为该程序进行测试用例设计。</p><p>分析题目中给出和隐含的对输入条件的要求：</p><p>（1）整数 （2）三个数（3）非零数（4）正数</p><p>（5）两边之和大于第三边（6）等腰 （7）等边</p><p>如果a、b、c满足条件（1）~（4），则输出下列四种情况之一：</p><p>1）如果不满足条件（5），则程序输出为“非三角形”</p><p>2）如果三条边相等即满足条件（7），则程序输出为“等边三角形”</p><p>3）如果只有两条边相等，及满足条件（6），则程序输出为“等腰三角形”</p><p>4）如果三条边都不相等，则程序输出为“一般三角形”</p><p>列出等价类表并编号</p><p><img src="https://images2015.cnblogs.com/blog/1108688/201702/1108688-20170220180057226-567743755.png" alt="img"></p><p>覆盖有效等价类的测试用例：</p><p>a b c覆盖等价类号码</p><p>3 4 5 （1） （7）</p><p>4 4 5 （1）（7） （8）</p><p>4 5 5 （1） （7） （9）</p><p>5 4 5 （1） （7） （10）</p><p>4 4 4 （1） （7） （11）</p><p>覆盖无效等价类的测试用例：</p><p>覆盖有效等价类的测试用例：</p><p>a b c覆盖等价类号码</p><p>3 4 5 （1） （7）</p><p>4 4 5 （1）（7） （8）</p><p>4 5 5 （1） （7） （9）</p><p>5 4 5 （1） （7） （10）</p><p>4 4 4 （1） （7） （11）</p><p>覆盖无效等价类的测试用例：</p><p><img src="https://images2015.cnblogs.com/blog/1108688/201702/1108688-20170220180153398-1765247423.png" alt="img"></p><p>实例2，NextDate</p><p>NextDate函数包含三个变量：month、day、year，函数的输出为输入日期后一天的日期。</p><p>例如，输入2006年3月7日，则函数的输出为2006年3月8日。要求输入变量month、day、year均为整数值，并且满足下列条件：</p><p>1、1＜＝month＜＝12</p><p>2、1＜＝day&lt;=31</p><p>3、1812&lt;=year&lt;=2012</p><p>1）有效等价类为：</p><p>M1=｛月份：1&lt;=月份&lt;=12｝</p><p>D1={日期：1&lt;=日期&lt;=31}</p><p>Y1=｛年份：1812&lt;=年&lt;=2012｝</p><p>2）若条件1~3中任何一个条件失效，则NextDate函数都会产生一个输出，指明相应的变量超出取值范围，比如“month的值不在12范围中”。显然还存在这大量的year、month、day的无效组合，NextDate函数将这些组合作为统一的输出：“无效输入日期”。</p><p>其无效等价类为：</p><p>M2=｛月份：月份&lt;1｝</p><p>M3=｛月份：月份&gt;12｝</p><p>D2=｛日期：日期&lt;1｝</p><p>D3=｛日期：日期&gt;31｝</p><p>Y2=｛年份：年&lt;1812｝</p><p>Y3=｛年份：年&gt;2012｝</p><p>弱一般等价类测试用例</p><table><thead><tr><th>月份</th><th>日期</th><th>年</th><th>预期输出</th></tr></thead><tbody><tr><td>6</td><td>15</td><td>1912</td><td>1912年6月16日</td></tr></tbody></table><p>强一般等价类测试用例同弱一般等价类测试用例</p><p>注：弱有单缺陷假设；健壮考虑了无效值。</p><p>（一）弱健壮等价类测试</p><table><thead><tr><th>用例</th><th>ID</th><th>月份</th><th>日期</th><th>年</th><th>预期输出</th></tr></thead><tbody><tr><td>WR1</td><td></td><td>6</td><td>15</td><td>1912</td><td>1912年6月16日</td></tr><tr><td>WR2</td><td></td><td>0</td><td>1</td><td>1912</td><td>月份不在1~12中</td></tr><tr><td>WR3</td><td></td><td>15</td><td>1</td><td>1912</td><td>月份不在1~12中</td></tr><tr><td>WR4</td><td></td><td>1</td><td>0</td><td>1912</td><td>日期不在1~31中</td></tr><tr><td>WR5</td><td></td><td>1</td><td>32</td><td>1912</td><td>日期不在1~31中</td></tr><tr><td>WR6</td><td></td><td>1</td><td>1</td><td>1811</td><td>年不在1812~2012中</td></tr><tr><td>WR7</td><td></td><td>1</td><td>1</td><td>2013</td><td>年不在1812~2012中</td></tr></tbody></table><p>（二）强健壮等价类测试</p><table><thead><tr><th>用例</th><th>ID</th><th>月份</th><th>日期</th><th>年</th><th>预期输出</th></tr></thead><tbody><tr><td>SR1</td><td></td><td>15</td><td>1</td><td>1912</td><td>月份不在1~12中</td></tr><tr><td>SR2</td><td></td><td>1</td><td>32</td><td>1912</td><td>日期不在1~31中</td></tr><tr><td>SR3</td><td></td><td>1</td><td>1</td><td>1811</td><td>年份不在1812~2012中</td></tr><tr><td>SR4</td><td></td><td>0</td><td>0</td><td>1912</td><td>两个无效一个有效</td></tr><tr><td>SR5</td><td></td><td>0</td><td>1</td><td>1811</td><td>两个无效一个有效</td></tr><tr><td>SR6</td><td></td><td>1</td><td>0</td><td>1811</td><td>两个无效一个有效</td></tr><tr><td>SR7</td><td></td><td>0</td><td>0</td><td>1811</td><td>三个无效</td></tr></tbody></table><h3 id="（二）边界值分析法"><a href="#（二）边界值分析法" class="headerlink" title="（二）边界值分析法"></a>（二）边界值分析法</h3><p>定义：边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。</p><p>与等价类区别：</p><p>1）边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。</p><p>2）边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况。</p><p>分析方法：</p><p>大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部。因此针对各种边界情况设计测试用例，可以查出更多的错误。使用边界值分析方法设计测试用例，首先应确定边界情况。通常输入和输出等价类的边界，就是应着重测试的边界情况。应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据。</p><p>常见边界值：</p><p> 1）对16Bit的整数而言，32767和32768是边界</p><p> 2）屏幕上光标在最左上、最右下位置</p><p> 3）报表的第一行和最后一行</p><p> 4）数组元素的第一个和最后一个</p><p> 5）循环的第0次、第1次和倒数第2次、最后一次</p><p>边界值分析：</p><p>1）边界值分析使用与等价类划分法相同的划分，只是边界值分析假定错误更多地存在于划分的边界上，因此在等价类的边界上以及两侧的情况设计测试用例。</p><p>​    例：测试计算平方根的函数</p><p>​    输入：实数</p><p>​    输出：实数</p><p>规格说明：当输入一个0或比0大的数的时候，返回其正平方根；当输入一个小于0的数时，显示错误信息“平方根非法，输入值小于0”并返回0；库函数printLine可以用来输出错误信息。</p><p>​    2）等价类划分：</p><p>​     i.       可以考虑做出如下划分：</p><p>A、输入(i)&lt;0 和(ii)&gt;=0</p><p>B、输出(a)&gt;=0和(b)Error</p><p>​    ii.       测试用例有两个</p><p>A、输入4，输出2.对应(ii)和(a)。</p><p>B、输入10，输出0和错误提示。对应与(i)和(b)</p><p>​    3）边界值分析</p><p>​    划分(ii)的边界为0和最大正实数；划分(i)的边界为最小负实数和0.由此得到一下测试用例：</p><p>​    A、输入｛最小负实数｝</p><p>​    B、输入｛绝对值很小的负数｝</p><p>​    C、输入0</p><p>​    D、输入｛绝对值很小的正数｝</p><p>​    E、输入｛最大正实数｝</p><p>​    4）通常情况下，软件测试所包含的边界检验有几种类型：数字、字符、位置、重量、大小、速度、方位、尺寸、空间等。</p><p>​    5）相应地，以上类型的边界值应该在：最大/最小、首位/末位、上/下、最快/最慢、最高/最低、最短/最长、空/满等情况下。</p><p>​    6）利用边界值作为测试数据</p><table><thead><tr><th>项</th><th>边界值</th><th>测试用例的设计思路</th></tr></thead><tbody><tr><td>字符</td><td>起始1个字符/结束+1个字符</td><td>假设一个文本输入区域允许输入1个到255个字符，输入1个和255个字符作为有效等价类；输入0个和256个字符作为无效等价类，这几个数值都属于边界条件值</td></tr><tr><td>数值</td><td>最小值1/最大值+1</td><td>假设某软件的数据输入域要求输入5位的数据值，可以使用10000作为最小值、9999作为最大值；然后使用刚好小于5位和大于5位的数值作为边界条件。</td></tr><tr><td>空间</td><td>小于空余空间一点/大于满空间一点</td><td>例如在用U盘存储数据时，使用比剩余磁盘空间大一点（几KB）的文件作为边界条件</td></tr></tbody></table><p>​    7）内部边界值分析</p><p>​    在多数情况下，边界值条件是基于应用程序的功能设计而需要考虑的因素，可以从软件的规格说明或常识中得到，也是最终用户可以很容易发现问题的。然而，在测试用例设计过程中，某些边界值条件是不需要呈现给用户的，或者说用户是很难注意到的，但同时确实属于检验范畴内的边界条件，称为内部边界值条件或子边界值条件。</p><p>​    内部边界值条件主要有下面几种：</p><p>1）数值的边界值检验：计算机是基于二进制进行工作的，因此，软件的任何数值运算都有一定的范围限制。</p><table><thead><tr><th>项</th><th>范围或值</th></tr></thead><tbody><tr><td>位（Bit）</td><td>0或者1</td></tr><tr><td>字节（byte）</td><td>0~255</td></tr><tr><td>字（Word）</td><td>0<del>65535（单字）或0</del>4294967295（双字）</td></tr><tr><td>千（K）</td><td>1024</td></tr><tr><td>兆（M）</td><td>1048576</td></tr><tr><td>吉（G）</td><td>1073741824</td></tr></tbody></table><p>2）字符的边界值检验：在计算机软件中，字符也是很重要的表示元素，其中ASCII和Unicode是常见的编码方式。下表中列出了一些常用字符对应的ASCII码值。</p><table><thead><tr><th>字符</th><th>ASCII码值</th><th>字符</th><th>ASCII码值</th></tr></thead><tbody><tr><td>空（Null）</td><td>0</td><td>A</td><td>65</td></tr><tr><td>空格（Space）</td><td>32</td><td>a</td><td>97</td></tr><tr><td>斜杠（/）</td><td>47</td><td>z</td><td>122</td></tr><tr><td>0</td><td>48</td><td>Z</td><td>90</td></tr><tr><td>冒号（：）</td><td>58</td><td>单引号（’）</td><td>96</td></tr><tr><td>@</td><td>64</td><td></td><td></td></tr></tbody></table><p>3）其它边界值检验：在不同的行业应用领域，依据硬件和软件的标准不同而具有各自特定的边界值。如下列出部分手机相关的边界值：</p><table><thead><tr><th><strong>硬件设备</strong></th><th><strong>范围或值</strong></th></tr></thead><tbody><tr><td>手机锂电池电压</td><td>工作电压：3.6<del>4.2V；保护电压：2.5</del>3V不等</td></tr><tr><td>手机正常使用温度</td><td>-25°C~+60°C</td></tr></tbody></table><p>转化为测试用例：</p><ol><li> 如果输入条件规定了值的范围,则应取刚达到这个范围的边界的值,以及刚刚超越这个范围边界的值作为测试输入数据。</li></ol><p>Ø 例如，如果程序的规格说明中规定：”重量在10公斤至50公斤范围内的邮件，其邮费计算公式为……”。作为测试用例，我们应取10及50，还应取10.01,49.99,9.99及50.01等。</p><ol start="2"><li> 如果输入条件规定了值的个数,则用最大个数,最小个数,比最小个数少一,比最大个数多一的数作为测试数据。</li></ol><p>Ø 例如，一个输入文件应包括1~255个记录，则测试用例可取1和255，还应取0及256等。</p><ol start="3"><li> 将规则1）和2）应用于输出条件，即设计测试用例使输出值达到边界值及其左右的值。</li></ol><p>Ø 例如，某程序的规格说明要求计算出”每月保险金扣除额为0至1165.25元”，其测试用例可取0.00及1165.24、还可取一0.01及1165．26等。</p><p>Ø 再如一程序属于情报检索系统，要求每次”最少显示1条、最多显示4条情报摘要”，这时我们应考虑的测试用例包括1和4，还应包括0和5等。</p><ol start="4"><li><p> 如果程序的规格说明给出的输入域或输出域是有序集合,则应选取集合的第一个元素和最后一个元素作为测试用例。</p></li><li><p> 如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试用例。</p></li><li><p>分析规格说明,找出其它可能的边界条件。</p></li></ol><p>实例1，批阅试卷</p><p>现有一个学生标准化考试批阅试卷,产生成绩报告的程序。其规格说明如下:程序的输入文件由一些有80个字符的记录组成,如右图所示，所有记录分为3组：</p><p><img src="https://images.cnblogs.com/cnblogs_com/jackc/tc4.gif" alt="img"></p><ol><li><p>标题：这一组只有一个记录，其内容为输出成绩报告的名字。</p></li><li><p>试卷各题标准答案记录：每个记录均在第80个字符处标以数字”2”。该组的第一个记录的第1至第3个字符为题目编号（取值为1一999）。第10至第59个字符给出第1至第50题的答案（每个合法字符表示一个答案）。该组的第2，第3……个记录相应为第51至第100，第101至第150，…题的答案。</p></li><li><p>每个学生的答卷描述：该组中每个记录的第80个字符均为数字”3”。每个学生的答卷在若干个记录中给出。如甲的首记录第1至第9字符给出学生姓名及学号，第10至第59字符列出的是甲所做的第1至第50题的答案。若试题数超过50，则第2，第3……纪录分别给出他的第51至第100，第101至第150……题的解答。然后是学生乙的答卷记录。</p></li><li><p>学生人数不超过200，试题数不超过999。</p></li><li><p>程序的输出有4个报告：<br>a)按学号排列的成绩单，列出每个学生的成绩、名次。<br>b)按学生成绩排序的成绩单。<br>c)平均分数及标准偏差的报告。<br>d)试题分析报告。按试题号排序，列出各题学生答对的百分比。</p></li></ol><p>解答：分别考虑输入条件和输出条件，以及边界条件。给出下表所示的输入条件及相应的测试用例。</p><p><img src="https://images.cnblogs.com/cnblogs_com/jackc/tc5.gif" alt="img"></p><pre><code> 输出条件及相应的测试用例表。</code></pre><p><img src="https://images.cnblogs.com/cnblogs_com/jackc/tc6.gif" alt="img"></p><p>实例2，三角形的边界问题分析测试用例</p><p>在三角形问题描述中，除了要求边长是整数外，没有给出其它的限制条件。在此，我们将三角形每边边长的取范围值设值为[1, 100]。</p><table><thead><tr><th><strong>测试用例</strong></th><th><strong>a</strong></th><th><strong>b</strong></th><th><strong>c</strong></th><th><strong>预期输出</strong></th></tr></thead><tbody><tr><td>Test1Test2Test3Test4Test5</td><td>6060605050</td><td>6060605050</td><td>126099100</td><td>等腰三角形等腰三角形等边三角形等腰三角形非三角形</td></tr><tr><td>Test6Test7Test8Test9</td><td>60605050</td><td>1299100</td><td>60605050</td><td>等腰三角形等腰三角形等腰三角形非三角形</td></tr><tr><td>Test10Test11Test12Test13</td><td>1299100</td><td>60605050</td><td>60605050</td><td>等腰三角形等腰三角形等腰三角形非三角形</td></tr></tbody></table><p>实例3，NextDate函数边界值分析测试用例</p><p>在NextDate函数中，隐含规定了变量mouth和变量day的取值范围为1≤mouth≤12和1≤day≤31，并设定变量year的取值范围为1912≤year≤2050。</p><h3 id="（三）错误推测法"><a href="#（三）错误推测法" class="headerlink" title="（三）错误推测法"></a>（三）错误推测法</h3><p>定义：基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。</p><p>基本思想：列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例。</p><p>\1.   例如,输入数据和输出数据为0的情况；输入表格为空格或输入表格只有一行。这些都是容易发生错误的情况。可选择这些情况下的例子作为测试用例。</p><p>\2.   例如，前面例子中成绩报告的程序，采用错误推测法还可补充设计一些测试用例：</p><ol><li><p>  程序是否把空格作为回答</p></li><li><p>  在回答记录中混有标准答案记录</p></li><li><p>  除了标题记录外，还有一些的记录最后一个字符即不是2也不是3</p></li><li><p>  有两个学生的学号相同</p></li><li><p>试题数是负数</p></li></ol><p>\3.   例如，测试一个对线性表（比如数组）进行排序的程序，可推测列出以下几项需要特别测试的情况：</p><ol><li><p> 输入的线性表为空表；</p></li><li><p> 表中只含有一个元素；</p></li><li><p> 输入表中所有元素已排好序；</p></li><li><p> 输入表已按逆序排好；</p></li><li><p>输入表中部分或全部元素相同。</p></li></ol><p>\4.   例如，测试手机终端的通话功能，可以设计各种通话失败的情况来补充测试用例：</p><ol><li><p> 无SIM 卡插入时进行呼出（非紧急呼叫）</p></li><li><p> 插入已欠费SIM卡进行呼出</p></li><li><p> 射频器件损坏或无信号区域插入有效SIM卡呼出</p></li><li><p> 网络正常，插入有效SIM卡，呼出无效号码（如1、888、333333、不输入任何号码等）</p></li><li><p>网络正常，插入有效SIM卡，使用“快速拨号”功能呼出设置无效号码的数字</p></li></ol><h3 id="（四）因果图法"><a href="#（四）因果图法" class="headerlink" title="（四）因果图法"></a>（四）因果图法</h3><p>定义：因果图法是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。</p><p>应用：</p><p>等价类划分法和边界值分析方法都是着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。这样虽然各种输入条件可能出错的情况已经测试到了，但多个输入条件组合起来可能出错的情况却被忽视了。</p><p>如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合、相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。</p><p>\1.   因果图介绍</p><ol><li> 4种符号分别表示了规格说明中向4种因果关系。</li></ol><p><img src="https://images.cnblogs.com/cnblogs_com/jackc/tc7.gif" alt="img"></p><ol start="2"><li><p> 因果图中使用了简单的逻辑符号，以直线联接左右结点。左结点表示输入状态（或称原因），右结点表示输出状态（或称结果）。</p></li><li><p> C1表示原因，通常置于图的左部；e1表示结果，通常在图的右部。C1和e1均可取值0或1，0表示某状态不出现，1表示某状态出现。</p></li></ol><p>\2.   因果图涉及的概念</p><ol><li> 关系</li></ol><p>Ø 恒等：若c1是1，则e1也是1；否则e1为0。</p><p>Ø 非：若c1是1，则e1是0；否则e1是1。</p><p>Ø 或：若c1或c2或c3是1，则e1是1；否则e1为0。“或”可有任意个输入。</p><p>Ø 与：若c1和c2都是1，则e1为1；否则e1为0。“与”也可有任意个输入。</p><ol start="2"><li> 约束</li></ol><p>输入状态相互之间还可能存在某些依赖关系，称为约束。例如,某些输入条件本身不可能同时出现。输出状态之间也往往存在约束。在因果图中,用特定的符号标明这些约束。</p><p><img src="https://images.cnblogs.com/cnblogs_com/jackc/tc8.gif" alt="img"></p><p>Ø 输入条件的约束有以下4类：</p><p>·    E约束（异）：a和b中至多有一个可能为1，即a和b不能同时为1。</p><p>·    I约束（或）：a、b和c中至少有一个必须是1，即 a、b 和c不能同时为0。</p><p>·    O约束（唯一）；a和b必须有一个，且仅有1个为1。</p><p>·    R约束（要求）：a是1时，b必须是1，即不可能a是1时b是0。</p><p>Ø 输出条件约束类型</p><p>​        输出条件的约束只有M约束（强制）：若结果a是1，则结果b强制为0。</p><p>\3.   采用因果图法设计测试用例的步骤：</p><ol><li><p> 分析软件规格说明描述中,那些是原因(即输入条件或输入条件的等价类),那些是结果(即输出条件),并给每个原因和结果赋予一个标识符。</p></li><li><p> 分析软件规格说明描述中的语义，找出原因与结果之间,原因与原因之间对应的关系，根据这些关系,画出因果图。</p></li><li><p> 由于语法或环境限制,有些原因与原因之间,原因与结果之间的组合情况不可能出现，为表明这些特殊情况,在因果图上用一些记号表明约束或限制条件。</p></li><li><p> 把因果图转换为判定表。</p></li><li><p>把判定表的每一列拿出来作为依据,设计测试用例。</p></li></ol><p>实例1，字符</p><p>某软件规格说明书包含这样的要求：第一列字符必须是A或B，第二列字符必须是一个数字，在此情况下进行文件的修改，但如果第一列字符不正确，则给出信息L；如果第二列字符不是数字，则给出信息M。</p><p>解答：</p><ol><li> 根据题意，原因和结果如下：</li></ol><p>​       原因：</p><p>​       1——第一列字符是A；</p><p>​       2——第一列字符是B；</p><p>​       3——第二列字符是一数字。</p><p>​       结果：</p><p>​       21——修改文件；</p><p>​       22 ——给出信息L；</p><p>​       23——给出信息M。</p><ol start="2"><li> 其对应的因果图如下：</li></ol><p>11为中间节点；考虑到原因1和原因2不可能同时为1，因此在因果图上施加E约束。</p><p><img src="https://images.cnblogs.com/cnblogs_com/jackc/tc9.gif" alt="img"></p><ol start="3"><li> 根据因果图建立判定表。</li></ol><p><img src="https://images.cnblogs.com/cnblogs_com/jackc/tc10.gif" alt="img"> </p><p>​              表中8种情况的左面两列情况中，原因①和原因②同时为1，这是不可能出现的，故应排除这两种情况。表的最下一栏给出了6种情况的测试用例，这是我们所需要的数据。</p><p>实例2，自动售货机</p><p>有一个处理单价为5角钱的饮料的自动售货机软件测试用例的设计。其规格说明如下：若投入5角钱或1元钱的硬币，押下〖橙汁〗或〖啤酒〗的按钮，则相应的饮料就送出来。若售货机没有零钱找，则一个显示〖零钱找完〗的红灯亮，这时在投入1元硬币并押下按钮后，饮料不送出来而且1元硬币也退出来；若有零钱找，则显示〖零钱找完〗的红灯灭，在送出饮料的同时退还5角硬币。</p><ol><li> 分析这一段说明，列出原因和结果</li></ol><p>原因：</p><p>1——售货机有零钱找</p><p>2——投入1元硬币</p><p>3——投入5角硬币</p><p>4——押下橙汁按钮</p><p>5——.押下啤酒按钮</p><p>结果：</p><p>21——售货机〖零钱找完〗灯亮  </p><p>22——退还1元硬币</p><p>23——退还5角硬币       </p><p>24——送出橙汁饮料</p><p>25——送出啤酒饮料</p><ol start="2"><li> 画出因果图，如图所示。所有原因结点列在左边，所有结果结点列在右边。建立中间结点，表示处理的中间状态。中间结点：</li></ol><p>11—— 投入1元硬币且押下饮料按钮</p><p>​         12——押下〖橙汁〗或〖啤酒〗的按钮</p><p>​         13——应当找5角零钱并且售货机有零钱找</p><p>​         14——钱已付清</p><p><img src="https://images.cnblogs.com/cnblogs_com/jackc/tc11.gif" alt="img"></p><ol start="3"><li> 转换成判定表：</li></ol><p><img src="https://images.cnblogs.com/cnblogs_com/jackc/tc12.gif" alt="img"> </p><ol start="4"><li>在判定表中，阴影部分表示因违反约束条件的不可能出现的情况，删去。第16列与第32列因什么动作也没做，也删去。最后可根据剩下的16列作为确定测试用例的依据。</li></ol><h3 id="（五）判定表驱动法"><a href="#（五）判定表驱动法" class="headerlink" title="（五）判定表驱动法"></a>（五）判定表驱动法</h3><p>定义：判定表是分析和表达多逻辑条件下执行不同操作的情况的工具。</p><p>优点：能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。因此，利用判定表能够设计出完整的测试用例集合。在一些数据处理问题当中，某些操作的实施依赖于多个逻辑条件的组合，即：针对不同逻辑条件的组合值，分别执行不同的操作。判定表适合于处理这类问题。</p><p>阅读指南，判定表：</p><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th></th></tr></thead><tbody><tr><td>问题</td><td>觉得疲倦吗？</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td></td><td></td><td></td><td></td></tr><tr><td>感兴趣吗？</td><td>Y</td><td>Y</td><td></td><td></td><td>Y</td><td>Y</td><td></td><td></td><td></td></tr><tr><td>糊涂吗？</td><td>Y</td><td></td><td>Y</td><td></td><td>Y</td><td></td><td>Y</td><td></td><td></td></tr><tr><td>建议</td><td>重读</td><td></td><td></td><td></td><td></td><td>Y</td><td></td><td></td><td></td></tr><tr><td>继续</td><td></td><td></td><td></td><td></td><td></td><td>Y</td><td></td><td></td><td></td></tr><tr><td>跳下一章</td><td></td><td></td><td></td><td></td><td></td><td></td><td>Y</td><td>Y</td><td></td></tr><tr><td>休息</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>判定表由四部分组成，如下图：</p><ol><li><p>   条件桩（Condition Stub）：列出了问题的所有条件。通常认为列出的条件的次序无关紧要。</p></li><li><p>   动作桩（Action Stub）：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。</p></li><li><p>   条件项（Condition Entry）：列出针对它左列条件的取值。在所有可能情况下的真假值。</p></li><li><p>   动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作。</p></li></ol><p>规则及规则合并：</p><p>1） 规则：任何一个条件组合的特定取值及其相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。显然判定表中列出多少组条件取值，也就有多少条规则，既条件项和动作项有多少列。</p><p>2） 化简：就是规则合并有两条或多条规则具有相同的动作，并且其条件项之间存在着极为相似的关系。</p><p>合并举例：</p><ol><li><p>如下图左端，两规则动作项一样，条件项类似，在1、2条件项分别去Y、N时，无论条件3取何值，都执行同一操作。即要执行的动作与条件3无关。于是可合并。“-”表示与取值无关</p></li><li><p>与上类似，下图中，无关条件项“-”可包含其他条件项取值，具有相同动作的规则可合并。</p></li><li></li><li><p>   化简后的读书指南判定表</p></li></ol><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th></th></tr></thead><tbody><tr><td>问题</td><td>觉得疲倦吗？</td><td>-</td><td>-</td><td>Y</td><td>N</td></tr><tr><td>感兴趣吗？</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td></td></tr><tr><td>糊涂吗？</td><td>Y</td><td>N</td><td>-</td><td>-</td><td></td></tr><tr><td>建议</td><td>重读</td><td>X</td><td></td><td></td><td></td></tr><tr><td>继续</td><td></td><td>X</td><td></td><td></td><td></td></tr><tr><td>跳下一章</td><td></td><td></td><td></td><td>X</td><td></td></tr><tr><td>休息</td><td></td><td></td><td>X</td><td></td><td></td></tr></tbody></table><h3 id="判定表建立步骤："><a href="#判定表建立步骤：" class="headerlink" title="判定表建立步骤："></a>判定表建立步骤：</h3><p>1） 确定规则的个数。假如有n个条件，每个条件有两个取值（0，1），故2n种规则。</p><p>2） 列出所有的条件桩和动作桩</p><p>3） 填入条件项</p><p>4） 填入动作项，等到初始判定表</p><p>5） 简化，合并相似规则（相同动作）</p><p>实例1，机器维修</p><p>问题要求：“。。。。。。对功率大于50马力的机器，维修记录不全或已运行10以上的机器，应给予优先的维修处理。。。。。。”，这里假定，“维修记录不全”和“优先维修处理”均已在别处有更严格的定义。请建立判定表。</p><p>解答：</p><p>1、确定规则的个数：这里有3个条件，每个条件有两个取值，故应有2<em>2</em>2=8种规则。</p><p>2、列出所有的条件桩和动作桩：</p><table><thead><tr><th>条件</th><th>功率大于50马力吗？</th></tr></thead><tbody><tr><td>维修记录不全吗？</td><td></td></tr><tr><td>运行超过10年吗？</td><td></td></tr><tr><td>动作</td><td>进行优先处理</td></tr></tbody></table><p>3、填入条件项。可从最后1行条件项开始，逐行向上填满。</p><p>4、填入动作桩和动作项。这样便得到如下图的初始判定表</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>条件</td><td></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr><tr><td>功率大于50马力吗？</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td><td></td></tr><tr><td>维修记录不全吗？</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td></td></tr><tr><td>运行超过10年吗？</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td></td></tr><tr><td>工作</td><td>进行优先处理</td><td>X</td><td>X</td><td>X</td><td></td><td>X</td><td></td><td>X</td><td></td></tr><tr><td>作其它处理</td><td></td><td></td><td></td><td>X</td><td></td><td>X</td><td></td><td>X</td><td></td></tr></tbody></table><p>5、</p><p>初始判定表化简。合并相似规则后得到</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>条件</td><td></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>功率大于50马力吗？</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td></td></tr><tr><td>维修记录不全吗？</td><td>Y</td><td>N</td><td>N</td><td>-</td><td>-</td><td></td></tr><tr><td>运行超过10年吗？</td><td>-</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td></td></tr><tr><td>工作</td><td>进行优先处理</td><td>X</td><td>X</td><td></td><td>X</td><td>X</td></tr><tr><td>作其它处理</td><td></td><td></td><td>X</td><td></td><td>X</td><td></td></tr></tbody></table><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>实例2，NextData函数的精简决策表</p><p>M1＝{月份， 每月有30天}</p><p>M2＝{月份， 每月有31天}</p><p>M3＝{月份， 2月}         有29＝512条规则</p><p>D1＝{日期，1～28}         12月末31日和其它31</p><p>D2＝{日期，29}           日月份的31日处理不同</p><p>D3＝{日期，30}          平年2月28日处理不同</p><p>D4＝{日期，31}          于2月27日</p><p>Y1 ＝{年：年是闰年}</p><p>Y2 ＝{年：年不是闰年}</p><p><strong>改进为：</strong></p><p>M1＝{月份： 每月有30天}</p><p>M2＝{月份： 每月有31天， 12月除外}</p><p>M4＝{月份：12月}</p><p>M3＝{月份： 2月}</p><p>D1＝{日期：1&lt;=日期&lt;=27}</p><p>D2＝{日期：28}</p><p>D3＝{日期：29}</p><p>D4＝{日期：30}</p><p>D5＝{日期：31}</p><p>Y1 ＝{年：年是闰年}</p><p>Y2 ＝{年：年不是闰年}</p><p>输入变量间存在大量逻辑关系的NextData决策表</p><p><img src="https://images.cnblogs.com/cnblogs_com/jackc/tc17.gif" alt="img"></p><p>\3.   用决策表测试法测试以下程序：该程序有三个输入变量month、day、year（month、day和year均为整数值，并且满足：1≤month≤12和1≤day≤31），分别作为输入日期的月份、日、年份，通过程序可以输出该输入日期在日历上隔一天的日期。</p><p>例如，输入为2004年11月29日，则该程序的输出为2000年12月1日。</p><ol><li><p> 分析各种输入情况，列出为输入变量month、day、year划分的有效等价类。</p></li><li><p> 分析程序规格说明，结合以上等价类划分的情况给出问题规定的可能采取的操作（即列出所有的动作桩）。</p></li><li><p> 根据（1）和（2），画出简化后的决策表。</p></li></ol><p>案例分析如下：</p><p>Ø month变量的有效等价类：</p><p>M1: {month=4,6,9,11}       M2: {month=1,3,5,7,8,10}</p><p>M3: {month=12            }M4: {month=2}</p><p>Ø day变量的有效等价类：</p><p>D1:{1≤day≤26}            D2: {day=27}        D3: {day=28}        D4: {day=29}               D5: {day=30}        D6: {day=31}</p><p>Ø year变量的有效等价类：</p><p>Y1: {year是闰年}            Y2: {year不是闰年}</p><ol start="4"><li> 考虑各种有效的输入情况，程序中可能采取的操作有以下六种：</li></ol><p>a1: day+2                 a2: day=2           a3: day=1</p><p>a4: month+1              a5: month=1        a6: year+1 </p><p>\4.   判定表在功能测试中的应用</p><ol><li> 一些软件的功能需求可用判定表表达得非常清楚，在检验程序的功能时判定表也就成为一个不错的工具。如果一个软件的规格说明指出：</li></ol><p>Ø 当条件1和条件2满足，并且条件3和条件4不满足，或者当条件1、3和条件4满足时，要执行操作1。</p><p>Ø 在任一个条件都不满足时，要执行操作2。</p><p>Ø 在条件1不满足，而条件4被满足时，要执行操作3。 根据规格说明得到如下判定表：</p><p><img src="https://images.cnblogs.com/cnblogs_com/jackc/tc18.gif" alt="img"></p><p>这里，判定表只给出了16种规则中的8种。事实上，除这8条以外的一些规则是指当不能满足指定的条件，执行3种操作时，要执行1个默许的操作。在没必要时，判定表通常可略去这些规则。但如果用判定表来设计测试用例，就必须列出这些默许规则（如下表）。</p><table><thead><tr><th>规则5</th><th>规则6</th><th>规则7</th><th>规则8</th><th></th></tr></thead><tbody><tr><td>条件1</td><td>-</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>条件2</td><td>-</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>条件3</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr><tr><td>条件4</td><td>N</td><td>N</td><td>Y</td><td>-</td></tr><tr><td>默许操作</td><td>x</td><td>x</td><td>x</td><td>x</td></tr></tbody></table><p>默许的规则 </p><ol start="2"><li> 判定表的优点和缺点</li></ol><p>Ø 优点：它能把复杂的问题按各种可能的情况一一列举出来，简明而易于理解，也可避免遗漏。</p><p>Ø 缺点：不能表达重复执行的动作，例如循环结构。</p><ol start="3"><li> B. Beizer 指出了适合使用判定表设计测试用例的条件：</li></ol><p>Ø 规格说明以判定表形式给出,或很容易转换成判定表。</p><p>Ø 条件的排列顺序不会也不影响执行哪些操作。</p><p>Ø 规则的排列顺序不会也不影响执行哪些操作。</p><p>Ø 每当某一规则的条件已经满足,并确定要执行的操作后,不必检验别的规则。</p><p>Ø 如果某一规则得到满足要执行多个操作,这些操作的执行顺序无关紧要。</p><p>B. Beizer提出这5个必要条件的目的是为了使操作的执行完全依赖于条件的组合。其实对于某些不满足这几条的判定表，同样可以借以设计测试用例，只不过尚需增加其它的测试用例罢了。</p><h3 id="（六）正交试验法"><a href="#（六）正交试验法" class="headerlink" title="（六）正交试验法"></a>（六）正交试验法</h3><p>定义：从大量的（实验）数据（测试例）中挑选适量的,有代表性的点（例）,从而合理地安排实验（测试）的一种科学实验设计方法.类似的方法有:聚类分析方法,因子方法方法等.</p><p>利用正交实验设计测试用例的步骤：</p><ol><li>提取功能说明,构造因子–状态表</li></ol><p>把影响实验指标的条件称为因子.而影响实验因子的条件叫因子的状态.利用正交实验设计方法来设计测试用例时,首先要根据被测试软件的规格说明书找出影响其功能实现的操作对象和外部因素,把他们当作因子,而把各个因子的取值当作状态.对软件需求规格说明中的功能要求进行划分,把整体的概要性的功能要求进行层层分解与展开,分解成具体的有相对独立性的基本的功能要求.这样就可以把被测试软件中所有的因子都确定下来,并为确定个因子的权值提供参考的依据.确定因子与状态是设计测试用例的关键.因此要求尽可能全面的正确的确定取值,以确保测试用例的设计作到完整与有效。</p><ol start="2"><li>加权筛选,生成因素分析表</li></ol><p>对因子与状态的选择可按其重要程度分别加权.可根据各个因子及状态的作用大小,出现频率的大小以及测试的需要,确定权值的大小。</p><ol start="3"><li>利用正交表构造测试数据集</li></ol><p>正交表的推导依据Galois理论（这里省略,需要时可查数理统计方面的教材）。</p><p>利用正交实验设计方法设计测试用例,比使用等价类划分,边界值分析,因果图等方法有以下优点:节省测试工作工时；可控制生成的测试用例数量；测试用例具有一定的覆盖率。</p><h3 id="（七）功能图法"><a href="#（七）功能图法" class="headerlink" title="（七）功能图法"></a>（七）功能图法</h3><p>定义：功能图由状态迁移图和布尔函数组成.状态迁移图用状态和迁移来描述.一个状态指出数据输入的位置（或时间）,而迁移则指明状态的改变.同时要依靠判定表或因果图表示的逻辑功能.例,一个简化的自动出纳机ATM的功能图。</p><p>应用：</p><ol><li>功能图介绍</li></ol><p>一个程序的功能说明通常由动态说明和静态说明组成.动态说明描述了输入数据的次序或转移的次序.</p><p>静态说明描述了输入条件与输出条件之间的对应关系.对于较复杂的程序,由于存在大量的组合情况,因此,仅用静态说明组成的规格说明对于测试来说往往是不够的.必须用动态说明来补充功能说明.功能图方法是用功能图FD形式化地表示程序的功能说明,并机械地生成功能图的测试用例.</p><p>功能图模型由状态迁移图和逻辑功能模型构成.状态迁移图用于表示输入数据序列以及相应的输出数据.在状态迁移图中,由输入数据和当前状态决定输出数据和后续状态.逻辑功能模型用于表示在状态中输入条件和输出条件之间的对应关系.逻辑功能模型只适合于描述静态说明,输出数据仅由输入数据决定.测试用例则是由测试中经过的一系列状态和在每个状态中必须依靠输入/输出数据满足的一对条件组成.功能图方法其实是是一种黑盒白盒混合用例设计方法。</p><p>（功能图方法中,要用到逻辑覆盖和路径测试的概念和方法,其属白盒测试方法中 的内容.逻辑覆盖是以程序内部的逻辑结构为基础的测试用例设计方法.该方法要求测试人员对程序的逻辑结构有清楚的了解.由于覆盖测试的目标不同,逻辑覆盖可分为:语句覆盖,判定覆盖,判定-条件覆盖,条件组合覆盖及路径覆盖.下面我们指的逻辑覆盖和路径是功能或系统水平上的,以区别与白盒测试中的程序内部的.）</p><ol start="2"><li>测试用例生成方法</li></ol><p>从功能图生成测试用例,得到的测试用例数是可接受的. 问题的关键的是如何从状态迁移图中选取测试用例. 若用节点代替状态,用弧线代替迁移,则状态迁移图就可转化成一个程序的控制流程图形式.问题就转化为程序的路径测试问题（如白盒测试）问题了.</p><ol start="3"><li>测试用例生成规则</li></ol><p>为了把状态迁移（测试路径）的测试用例与逻辑模型（局部测试用例）的测试用例组合起来,从功能图生成实用的测试用例,须定义下面的规则.在一个结构化的状态迁移（SST）中,定义三种形式的循环:顺序,选择和重复.但分辨一个状态迁移中的所有循环是有困难的.（其表示图形省略）。</p><ol start="4"><li>从功能图生成测试用例的过程</li></ol><ol><li><p> 生成局部测试用例:在每个状态中,从因果图生成局部测试用例.局部测试用例由原因值（输入数据）组合与对应的结果值（输出数据或状态）构成。</p></li><li><p> 测试路径生成:利用上面的规则（三种）生成从初始状态到最后状态的测试路径。</p></li><li><p> 测试用例合成:合成测试路径与功能图中每个状态中的局部测试用例.结果是初始状态到最后状态的一个状态序列,以及每个状态中输入数据与对应输出数据的组合。</p></li></ol><ol start="5"><li>测试用例的合成算法:采用条件构造树.</li></ol><h3 id="（八）场景图法"><a href="#（八）场景图法" class="headerlink" title="（八）场景图法"></a>（八）场景图法</h3><p>定义：现在的软件几乎都是用事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流。这种在软件设计方面的思想也可以引入到软件测试中，可以比较生动地描绘出事件触发时的情景，有利于测试设计者设计测试用例，同时使测试用例更容易理解和执行。</p><p>应用：</p><p>基本流和备选流：如下图所示，图中经过用例的每条路径都用基本流和备选流来表示，直黑线表示基本流，是经过用例的最简单的路径。备选流用不同的色彩表示，一个备选流可能从基本流开始，在某个特定条件下执行，然后重新加入基本流中（如备选流1和3）；也可能起源于另一个备选流（如备选流2），或者终止用例而不再重新加入到某个流（如备选流2和4）。</p><p><img src="https://images.cnblogs.com/cnblogs_com/jackc/tc19.gif" alt="img"></p><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h3 id="9-3-实例"><a href="#9-3-实例" class="headerlink" title="9.3.       实例"></a>9.3.       实例</h3><p>\1.   例子描述</p><p>下图所示是ATM例子的流程示意图。</p><p><img src="https://images.cnblogs.com/cnblogs_com/jackc/tc20.gif" alt="img"></p><p>\2.  场景设计：下表所示是生成的场景。</p><p>表3-8 场景设计</p><table><thead><tr><th>场景1——成功提款</th><th>基本流</th><th></th></tr></thead><tbody><tr><td>场景2——ATM内没有现金</td><td>基本流</td><td>备选流2</td></tr><tr><td>场景3——ATM内现金不足</td><td>基本流</td><td>备选流3</td></tr><tr><td>场景4——PIN有误（还有输入机会）</td><td>基本流</td><td>备选流4</td></tr><tr><td>场景5——PIN有误（不再有输入机会）</td><td>基本流</td><td>备选流4</td></tr><tr><td>场景6——账户不存在/账户类型有误</td><td>基本流</td><td>备选流5</td></tr><tr><td>场景7——账户余额不足</td><td>基本流</td><td>备选流6</td></tr></tbody></table><p>注：为方便起见，备选流3和6（场景3和7）内的循环以及循环组合未纳入上表。</p><p>\3.  用例设计</p><p>对于这7个场景中的每一个场景都需要确定测试用例。可以采用矩阵或决策表来确定和管理测试用例。下面显示了一种通用格式，其中各行代表各个测试用例，而各列则代表测试用例的信息。本示例中，对于每个测试用例，存在一个测试用例ID、条件（或说明）、测试用例中涉及的所有数据元素（作为输入或已经存在于<a href="http://lib.csdn.net/base/mysql">数据库</a>中）以及预期结果。</p><p>表3-9 测试用例表</p><table><thead><tr><th>TCID</th><th>场景/条件</th><th>PIN</th><th>账号</th><th>输入（或选择）的金额</th><th>账面金额</th><th>ATM内的金额</th><th>预期结果</th></tr></thead><tbody><tr><td>CW1</td><td>场景1：成功提款</td><td>V</td><td>V</td><td>V</td><td>V</td><td>V</td><td>成功提款</td></tr><tr><td>CW2</td><td>场景2：ATM内没有现金</td><td>V</td><td>V</td><td>V</td><td>V</td><td>I</td><td>提款选项不可用，用例结束</td></tr><tr><td>CW3</td><td>场景3：ATM内现金不足</td><td>V</td><td>V</td><td>V</td><td>V</td><td>I</td><td>警告消息，返回基本流步骤6，输入金额</td></tr><tr><td>CW4</td><td>场景4：PIN有误（还有不止一次输入机会）</td><td>I</td><td>V</td><td>n/a</td><td>V</td><td>V</td><td>警告消息，返回基本流步骤 4，输入 PIN</td></tr><tr><td>CW5</td><td>场景4：PIN有误（还有一次输入机会）</td><td>I</td><td>V</td><td>n/a</td><td>V</td><td>V</td><td>警告消息，返回基本流步骤 4，输入 PIN</td></tr><tr><td>CW6</td><td>场景4：PIN有误（不再有输入机会）</td><td>I</td><td>V</td><td>n/a</td><td>V</td><td>V</td><td>警告消息，卡予保留，用例结束</td></tr></tbody></table><p>\4.  数据设计</p><p>一旦确定了所有的测试用例，则应对这些用例进行复审和验证以确保其准确且适度，并取消多余或等效的测试用例。</p><p>测试用例一经认可，就可以确定实际数据值（在测试用例实施矩阵中）并且设定测试数据，如表3-10所示。</p><p>表3-10  测试用例表</p><table><thead><tr><th>TCID</th><th>场景/条件</th><th>PIN</th><th>账号</th><th>输入（或选择）的金额（元）</th><th>账面 金额（元）</th><th>ATM内的金额（元）</th><th>预期结果</th></tr></thead><tbody><tr><td>CW1</td><td>场景1：成功提款</td><td>4987</td><td>809-498</td><td>50.00</td><td>500.00</td><td>2 000</td><td>成功提款。账户余额被更新为450.00</td></tr><tr><td>CW2</td><td>场景2：ATM内没有现金</td><td>4987</td><td>809-498</td><td>100.00</td><td>500.00</td><td>0.00</td><td>提款选项不可用，用例结束</td></tr><tr><td>CW3</td><td>场景3：ATM内现金不足</td><td>4987</td><td>809-498</td><td>100.00</td><td>500.00</td><td>70.00</td><td>警告消息，返回基本流步骤6，输入金额</td></tr><tr><td>CW4</td><td>场景4：PIN有误（还有不止一次输入机会）</td><td>4978</td><td>809-498</td><td>n/a</td><td>500.00</td><td>2 000</td><td>警告消息，返回基本流步骤4，输入PIN</td></tr><tr><td>CW5</td><td>场景4：PIN有误（还有一次输入机会）</td><td>4978</td><td>809-498</td><td>n/a</td><td>500.00</td><td>2 000</td><td>警告消息，返回基本流步骤4，输入PIN</td></tr><tr><td>CW6</td><td>场景4：PIN有误（不再有输入机会）</td><td>4978</td><td>809-498</td><td>n/a</td><td>500.00</td><td>2 000</td><td>警告消息，卡予保留，用例结束</td></tr></tbody></table><p><strong>测试用例设计综合策略</strong></p><p>\1.  Myers提出了使用各种测试方法的综合策略：</p><ol><li><p> 在任何情况下都必须使用边界值分析方法，经验表明用这种方法设计出测试用例发现程序错误的能力最强。</p></li><li><p> 必要时用等价类划分方法补充一些测试用例。</p></li><li><p> 用错误推测法再追加一些测试用例。</p></li><li><p> 对照程序逻辑，检查已设计出的测试用例的逻辑覆盖程度，如果没有达到要求的覆盖标准，应当再补充足够的测试用例。</p></li><li><p> 如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用因果图法。</p></li></ol><p>\2.  测试用例的设计步骤</p><ol><li><p> 构造根据设计规格得出的基本功能测试用例；</p></li><li><p> 边界值测试用例；</p></li><li><p> 状态转换测试用例；</p></li><li><p> 错误猜测测试用例；</p></li><li><p> 异常测试用例；</p></li><li><p> 性能测试用例；</p></li><li><p> 压力测试用例。</p></li></ol><p>\3.  优化测试用例的方法</p><ol><li><p> 利用设计测试用例的8种方法不断的对测试用例进行分解与合并；</p></li><li><p> 采用遗传算法理论进化测试用例；</p></li><li><p>在测试时利用发散思维构造测试用例；</p></li></ol><h2 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h2><p>白盒测试常见的用例设计方法有：<strong>代码检查法、静态结构分析法、静态质量度量法、逻辑覆盖法、基本路径覆盖测试法、域测试、符号测试。</strong></p><h3 id="（一）代码检查法"><a href="#（一）代码检查法" class="headerlink" title="（一）代码检查法"></a>（一）代码检查法</h3><p>​    代码检查包括桌面检查、代码审查和走查等，主要检查代码和设计的一致性，代码对标准的遵循、可读性，代码逻辑表达的正确性，代码结构的合理性等方面；发现违背程序编写标准的问题，程序中不安全、不明确和模糊的部分，找出程序中不可移植部分、违背程序编程风格的内容，包括变量检查、命名和类型审查、程序逻辑审查、程序语法检查和程序结构检查等内容。</p><p>代码检查方法：</p><p>1、代码检查法</p><p>（1）桌面检查：这是一种传统的检查方法，由程序员检查自己编写的程序。程序员在程序通过编译之后，对源程序代码进行分析、检验，并补充相关文档，目的是发现程序中的错误。由于程序员熟悉自己的程序及其程序设计风格，桌面检查由程序员自己进行可以节省很多的检查时间，但应避免主观片面性</p><p>（2）代码审查</p><p>  由若干程序员和测试员组成一个审查小组，通过阅读、讨论和争议，对程序进行静态分析的过程。代码审查分两步：第一步，小组负责人提前把设计规格说明书、控制流程图、程序文本及有关要求、规范等分发给小组成员，作为审查的依据。小组成员在充分阅读这些材料后，进入审查的第二步，召开程序审查会。在会上，首先由程序员逐句简介程序的逻辑。在此过程中，程序员或其他小组成员可以提出问题，展开讨论，审查错误是否存在。实践表明，程序员在讲解过程中能发现许多原来自己没有发现的错误，而讨论和争议则促进了问题的暴露。</p><p>  在会前，应当给审查小组每个成员准备一份常见错误的清单，把以往所有可能发生的常见错误罗列出来，供与会者对照检查，以提高审查的失效。这个常见的错误清单也成为检查表，它把程序中可能发生的各种错误进行分类，对每一类错误列出尽可能多的典型错误，然后把它们制成表格，供再审查时使用</p><p> （3）走查</p><p>  与代码审查基本相同，分为两步，第一步也是把材料分给走查小组的每个成员，让他们认真研究程序，然后再开会。开会的程序与代码审查不同，不是简单地读程序和对照错误检查表进行检查，而是让与会者“充当”计算机，即首先由测试组成员为所测试程序准备一批有代表性的测试用例，提交给走查小组。走查小组开会，集体扮演计算机角色，让测试用例沿程序的逻辑运行一遍，随时记录程序的踪迹，供分析和讨论用。</p><p>人们借助测试用例的媒介作用，对程序的逻辑和功能提出各种疑问，结合问题开展热烈的讨论和争议，能够发现更多的问题。</p><p>代码检查应在编译和动态测试之前进行，在检查前，应准备好需求描述文档、程序设计文档、程序的源代码请当、代码编译标准和代码缺陷检查表等。在实际使用中，代码检查能快速找到缺陷，发现30%～70%的逻辑设计和编码缺陷，而且代码检查看到的问题本身而非征兆。但是代码检查非常耗费时间，而且代码检查需要知识和经验的积累。代码检查可以使用测试软件进行自动化测试，以利于提高测试效率，降低劳动强度，或者使用人工进行测试，以充分发挥人力的逻辑思维能力</p><p>2、代码检查项目</p><p>   变量交叉引用表；标号的交叉引用表；检查子程序、宏、函数；等价性检查；常量检查；标准检查；风格检查；比较控制流；选择、激活路径；补充文档</p><p>  根据检查项目可以编制代码规则、规范和检查表等作为测试用例，如编码规范、代码检查规范、缺陷检查表等</p><p>3、编码规范</p><p>  编码规范是指程序编写过程中必须遵循的规则，一般会详细制定代码的语法规则、语法格式等</p><p>4、代码检查规范</p><p>  在代码检查中，需要依据被测软件的特点，选用适当的标准与规则规范。在使用测试软件进行自动化代码检查时，测试工具一般会内置许多的编码规则。在自动化测试基础上使用桌面检查、代码走查、代码审查等人工检查的方法仔细检查程序的结构、逻辑等方面的缺陷</p><p>5、缺陷检查表</p><p>  在进行人工代码检查时，代码缺陷检查表是我们用到的测试用例。</p><p>  代码缺陷检查表中一般包括容易出错的地方和在以往的工作中遇到的典型错误</p><h3 id="（二）静态结构分析法"><a href="#（二）静态结构分析法" class="headerlink" title="（二）静态结构分析法"></a>（二）静态结构分析法</h3><p>​    程序的结构形式是白盒测试的主要依据。研究表明程序员38%的时间花费在理解软件系统上，因为代码以文本格式被写入多重文件中，这是很难阅读理解的，需要其它一些东西来帮助人们阅读理解，如各种图表等，而静态结构分析满足了这样的需求。</p><p>​    在静态结构分析中，测试者通过使用测试工具分析程序源代码的系统结构、数据结构、内部控制逻辑等内部结构，生成函数调用关系图、模块控制流图、内部文件调用关系图、子程序表、宏和函数参数表等各类图形图标，可以清晰地标识整个软件系统的组成结构，使其便于阅读和理解，然后可以通过分析这些图标，检查软件有没有存在缺陷或错误。</p><p>   其中函数调用关系图通过应用程序中各函数之间的调用关系展示了系统的结构。通过查看函数调用关系图，可以检查函数之间的调用关系是否符合要求，是否存在递归调用，函数的调用曾是是否过深，有没有存在独立的没有被调用的函数。从而可以发现系统是否存在结构缺陷，发现哪些函数是重要的，哪些是次要的，需要使用什么级别的覆盖要求……</p><p>  模块控制流图是与程序流程图相类似的由许多节点和连接节点的边组成的一种图形，其中一个节点代表一条语句或数条语句，边代表节点间控制流向，它显示了一个函数的内部逻辑结构。模块控制流图可以直观地反映出一个函数的内部逻辑结构，通过检查这些模块控制流图，能够很快发现软件的错误与缺陷</p><h3 id="（三）静态质量度量法"><a href="#（三）静态质量度量法" class="headerlink" title="（三）静态质量度量法"></a>（三）静态质量度量法</h3><p>根据ISO/IEC 9126质量模型作为基础，我们可以构造质量度量模型，用于评估软件的各个方面。该模型从上到下分为3层：质量因素（Factors）、分类标准（Criteria）和度量规则（metrics）。其中质量因素对应ISO 9126质量模型的质量特性，分类标准对应ISO 9126质量模型的子特性，度量规则用于规范软件的各种行为属性。以下例子按照可维护性进行分析。</p><p>1、度量规则</p><p>  度量规则使用了代码行数、注释频度等参数度量软件的各种行为属性</p><p>2、分类标准</p><p>  软件的可维护性采用以下四个分类标准来评估：可分析性（ANALYZABILITY）、可修改性（CHANGEABILITY）、稳定性（STABILITY）、可测性（TESTABILITY）。每个分类标准由一系列度量规则组成，各个规则分配一个权重，由规则的取值与权重值计算出每个分类标准的取值。</p><p>  function_TESTABILITY_DRCT_CALLS+LEVL+PATH+PARA</p><p>3、质量因素</p><p>  质量因素的取值与分类标准的计算方式类似：依据各分类标准取值组合权重方法计算.</p><p>  function_MAINTAINABILITY=function_ANALYZABILITY</p><p>​                        +function_CHANGEABILITY</p><p>​                        +function_ATABILITY</p><p>​                        +function_TESTABILITY </p><h3 id="（四）逻辑覆盖法"><a href="#（四）逻辑覆盖法" class="headerlink" title="（四）逻辑覆盖法"></a>（四）逻辑覆盖法</h3><p>逻辑覆盖是以程序内部的逻辑结构为基础的设计测试用例的技术。</p><p>根据覆盖目标的不同和覆盖源程序语句的详尽程度，逻辑覆盖又可分为：</p><p>\1. 语句覆盖(SC)</p><p>\2. 判定覆盖(DC)</p><p>\3. 条件覆盖(CC)</p><p>\4. 条件/判定覆盖(CC)</p><p>\5. 条件组合覆盖(MCC)</p><p>\6. 修正判定条件覆盖(MCDC)</p><p>\7. 点覆盖</p><p>\8. 边覆盖</p><p>\9. 路径覆盖</p><p>几种逻辑覆盖标准发现错误的能力呈由弱至强的变化。</p><p>下面我们来逐一举例详解：</p><p><strong>1****语句覆盖（SC）：</strong></p><p>语句覆盖是指选择足够的测试用例，使得运行这些测试用例时，被测程序的每一个语句至少执行一次，其覆盖标准无法发现判定中逻辑运算的错误.</p><p>我们看下面的被测试代码：</p><p>int foo(int a, int b)</p><p>{</p><p>return a / b;</p><p>}</p><p>假如我们的测试人员编写如下测试案例：</p><p>TeseCase: a = 10, b = 5</p><p>测试人员的测试结果会告诉你，他的代码覆盖率达到了100%，并且所有测试案例都通过了。然而遗憾的是，我们的语句覆盖率达到了所谓的100%，但是却没有发现最简单的 Bug，比如，当我让b=0时，会抛出一个除零异常。</p><p>简言之，语句覆盖，就是设计若干个测试用例，运行被测程序，使得每一可执行语句至少执行一次。这里的“若干个”，意味着使用测试用例越少越好。</p><p>语句覆盖率的公式可以表示如下：</p><p>语句覆盖率=可执行的语句总数/被评价到的语句数量 x 100%</p><p><strong>2****判定覆盖(DC)</strong></p><p>判定覆盖是设计足够多的测试用例，使得程序中的每一个判断至少获得一次“真”和一次“假”，即使得程序流程图中的每一个真假分支至少被执行一次。</p><p>但若程序中的判定是有几个条件联合构成时，它未必能发现每个条件的错误。</p><p>例：</p><p>int a,b;</p><p>if(a || b)</p><p>执行语句1</p><p>else</p><p>执行语句2</p><p>要达到这段程序的判断覆盖,我们采用测试用例:</p><p>1)a = true , b = false;</p><p>2)a = false, b = false</p><p><strong>3****条件覆盖(CC)</strong></p><p>条件覆盖是指选择足够的测试用例，使得运行这些测试用例时，判定中每个条件的所有可能结果至少出现一次，但未必能覆盖全部分支.</p><p>例：</p><p>int a,b;</p><p>if(a || b)</p><p>执行语句1</p><p>else</p><p>执行语句2</p><p>要达到这段程序的条件覆盖,我们采用测试用例:</p><p>1)a = true , b = false ;</p><p>2)a = false, b = true</p><p><strong>4****判定/条件覆盖（CDC）</strong></p><p>判定/条件覆盖是使判定中每个条件的所有可能结果至少出现一次，并且每个判定本身的所有可能结果也至少出现一次。</p><p>例：</p><p>int a,b;</p><p>if(a || b)</p><p>执行语句1</p><p>else</p><p>执行语句2</p><p>要达到这段程序的判定/条件覆盖,我们采用测试用例:</p><p>1)a = true , b = true;</p><p>2)a = false, b = false</p><p><strong>5****条件组合覆盖（MCC）</strong></p><p>选择足够的测试用例，使得每个判定中条件的各种可能组合都至少出现一次。显然，满足“条件组合覆盖”的测试用例是一定满足“判定覆盖”、“条件覆盖”和“判定/条件覆盖”的。</p><p>例：</p><p>int a,b;</p><p>if(a || b)</p><p>执行语句1</p><p>else</p><p>执行语句2</p><p>要达到这段程序的判定/条件覆盖,我们采用测试用例:</p><p>1)a = true , b = true;</p><p>2)a = false, b = false</p><p>3)a = true,  b = false</p><p>4)a = false,  b = ture</p><p><strong>6****修正判定条件覆盖（MC/DC）</strong></p><p>MC/DC首先要求实现条件覆盖、判定覆盖，在此基础上，对于每一个条件C，要求存在符合以下条件的两次计算：<br>  1）条件C所在判定内的所有条件，除条件C外，其他条件的取值完全相同；<br>  2）条件C的取值相反；<br>  3）判定的计算结果相反。</p><p>  核心意思是每个条件都要独立影响判定结果。为什么说“两次计算”，而不是“两个用例”呢？当循环中有判定时，一个用例下同一判定可能被计算多次，每次的条件值和判定值也可能不同，因此，一个用例就可能完成循环中判定的MC/DC。</p><p>  MC/DC是条件组合覆盖的子集。条件组合覆盖要求覆盖判定中所有条件取值的所有可能组合，需要大量的测试用例，实用性较差。MC/DC具有条件组合覆盖的优势，同时大幅减少用例数。满足MC/DC的用例数下界为条件数+1，上界为条件数的两倍，例如，判定中有三个条件，条件组合覆盖需要8个用例，而MC/DC需要的用例数为4至6个。如果判定中条件很多，用例数的差别将非常大，例如，判定中有10个条件，条件组合覆盖需要1024个用例，而MC/DC只需要11至20个用例。</p><p>  下面是MC/DC的示例：</p><p>  代码：<br>  int func(BOOL A, BOOL B, BOOL C)<br>  {<br>    if(A &amp;&amp; (B || C))<br>      return 1;<br>    return 0;<br>  }</p><p>  用例：</p><p><img src="http://mmbiz.qpic.cn/mmbiz/KrjxpeiaZUP6biaQCL3MxDTWbRscbZ2VC4D0anC1ZOJXiapJZ1JNHqbJrglZbyqwJYPzP2icicC8cJBKuA9zc7Bzw5g/0?wx_fmt=jpeg" alt="img"></p><p>  对于条件A，用例1和用例2，A取值相反，B和C相同，判定结果分别为1和0；<br>  对于条件B，用例1和用例3，B取值相反，A和C相同，判定结果分别为1和0；<br>  对于条件C，用例3和用例4，C取值相反，A和B相同，判定结果分别为0和1。</p><p><strong>9****路径覆盖（PC）</strong></p><p>MC/DC被称为“最严格的标准”，但这种说法是将条件组合覆盖和路径覆盖排除在外为基础的。MC/DC显然不如条件组合覆盖严格，但是条件组合覆盖需要太多用例，实际应用中难以做到，所以排除，那么，路径覆盖是否也难以做到？使用先进的工具，对于一般的代码，实现路径覆盖还是可能的。另外，路径代表了从函数入口到出口的所有可能的代码组合，这些组合会不会出问题？只有路径覆盖能发现，这与MC/DC侧重于判定内的条件的组合关系是完全不同的。</p><p>  ＭC/DC与路径覆盖的侧重点不同，两者都有其优势和局限性，如果组合起来，优势互补，形成“MC/DC-路径覆盖”，就是真正意义上的“最严格的标准”了。</p><p>  有些程序，路径数量可能大得惊人，可用以下规则和方法减少路径数量：<br>  计算路径时，不考虑循环的次数，将循环结构视为循环体“至少执行一次”和“从不执行”两个分支；<br>  不考虑条件的计算结果只考虑判定的计算结果，条件间的组合关系由条件覆盖、C/DC和MC/DC负责；<br>  一个分支如果不可达，通过该分支的所有路径也不可达，可以让工具自动排除；<br>  当代码很复杂时，理想的处置方式是将部分代码独立为函数，如果做不到，可以让工具来模拟，即在逻辑结构图中，将部分代码临时屏蔽，被屏蔽的代码视为一个函数调用。交替屏蔽可以既减少路径数量，又保证路径覆盖的效果。</p><p>  对于一般复杂度的代码，采用以上规则和方法后，路径数量和用例数量可以维持在一个现实可覆盖的的范围内。</p><p>  路径覆盖的主要缺陷是：不相关的逻辑块会组合出大量没有意义的路径。一个函数的路径，可能达到几万条甚至几百万条。如果路径超过100条，通常路径覆盖就没有意义了。对于一般企业来说，建议用MC/DC作为统一的覆盖标准，只有特别关键的代码，才要求完成“MC/DC-路径覆盖”。</p><p>路径覆盖要求设计足够多的测试用例，在白盒测试法中，覆盖程度最高的就是路径覆盖，因为其覆盖程序中所有可能的路径。</p><p>对于比较简单的小程序来说，实现路径覆盖是可能的，但是如果程序中出现了多个判断和多个循环，可能的路径数目将会急剧增长，以致实现路径覆盖是几乎不可能的。</p><h3 id="（五）基本路径测试法"><a href="#（五）基本路径测试法" class="headerlink" title="（五）基本路径测试法"></a>（五）基本路径测试法</h3><p>基本路径测试法是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。</p><p>　　设计出的测试用例要保证在测试中程序的语句覆盖100%，条件覆盖100%。</p><p>　　在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例。包括以下4个步骤和一个工具方法：</p><p>　　1.程序的控制流图：描述程序控制流的一种图示方法。</p><p>　　2.程序圈复杂度：McCabe复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。</p><p>　　3.导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果。</p><p>　　4.准备测试用例：确保基本路径集中的每一条路径的执行。</p><p>　　工具方法：</p><p>　　图形矩阵：是在基本路径测试中起辅助作用的软件工具，利用它可以实现自动地确定一个基本路径集。</p><p>　　程序的控制流图：描述程序控制流的一种图示方法。</p><p>　　圆圈称为控制流图的一个结点，表示一个或多个无分支的语句或源程序语句</p><p>​      <img src="http://hi.csdn.net/attachment/201110/22/0_1319249204D4sd.gif" alt="img"></p><p>流图只有二种图形符号：</p><p>　　图中的每一个圆称为流图的结点，代表一条或多条语句。</p><p>　　流图中的箭头称为边或连接，代表控制流</p><p>　　任何过程设计都要被翻译成控制流图。</p><p>　　如何根据程序流程图画出控制流程图?</p><p>　　在将程序流程图简化成控制流图时，应注意：</p><p>　　1）在选择或多分支结构中，分支的汇聚处应有一个汇聚结点。</p><p>　　2）边和结点圈定的范围叫做区域，当对区域计数时，图形外的区域也应记为一个区域。</p><p>如下图所示</p><p>​    <img src="http://hi.csdn.net/attachment/201110/22/0_1319249246IlQo.gif" alt="img"></p><p>​    3）如果判断中的条件表达式是由一个或多个逻辑运算符 (OR, AND, NAND, NOR)连接的复合条件表达式，则需要改为一系列只有单条件的嵌套的判断。</p><p>　　例如：</p><p>　　1 if a or b</p><p>　　2 x</p><p>　　3 else</p><p>　　4 y</p><p>　　对应的逻辑为：</p><p>​    <img src="http://hi.csdn.net/attachment/201110/22/0_1319249288ZWPF.gif" alt="img"></p><p>独立路径：至少沿一条新的边移动的路径</p><p>​    <img src="http://hi.csdn.net/attachment/201110/22/0_1319249317bX78.gif" alt="img"></p><p>基本路径测试法的步骤：</p><p>　　第一步：画出控制流图</p><p>　　流程图用来描述程序控制结构。可将流程图映射到一个相应的流图(假设流程图的菱形决定框中不包含复合条件)。在流图中，每一个圆，称为流图的结点，代表一个或多个语句。一个处理方框序列和一个菱形决测框可被映射为一个结点，流图中的箭头，称为边或连接，代表控制流，类似于流程图中的箭头。一条边必须终止于一个结点，即使该结点并不代表任何语句(例如：if-else-then结构)。由边和结点限定的范围称为区域。计算区域时应包括图外部的范围。</p><p>​     <img src="http://hi.csdn.net/attachment/201110/22/0_1319249341p3Hx.gif" alt="img"></p><p>画出其程序流程图和对应的控制流图如下</p><p>​      <img src="http://hi.csdn.net/attachment/201110/22/0_13192494861Zxa.gif" alt="img"></p><p>第二步：计算圈复杂度</p><p>　　圈复杂度是一种为程序逻辑复杂性提供定量测度的软件度量，将该度量用于计算程序的基本的独立路径数目，为确保所有语句至少执行一次的测试数量的上界。独立路径必须包含一条在定义之前不曾用到的边。</p><p>　　有以下三种方法计算圈复杂度：</p><p>　　流图中区域的数量对应于环型的复杂性;</p><p>　　给定流图G的圈复杂度V(G)，定义为V(G)=E-N+2，E是流图中边的数量，N是流图中结点的数量;</p><p>　　给定流图G的圈复杂度V(G)，定义为V(G)=P+1，P是流图G中判定结点的数量。</p><p>​      <img src="http://hi.csdn.net/attachment/201110/22/0_1319249529m5mb.gif" alt="img"></p><p>第三步：导出测试用例</p><p>　　根据上面的计算方法，可得出四个独立的路径。(一条独立路径是指，和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路。V(G)值正好等于该程序的独立路径的条数。)</p><p>　　ü路径1：4-14</p><p>　　ü路径2：4-6-7-14</p><p>　　ü路径3：4-6-8-10-13-4-14</p><p>　　ü路径4：4-6-8-11-13-4-14</p><p>　　根据上面的独立路径，去设计输入数据，使程序分别执行到上面四条路径。</p><p>　　o第四步：准备测试用例</p><p>　　为了确保基本路径集中的每一条路径的执行，根据判断结点给出的条件，选择适当的数据以保证某一条路径可以被测试到，满足上面例子基本路径集的测试用例是：</p><p>​     <img src="http://hi.csdn.net/attachment/201110/22/0_1319249560g0I9.gif" alt="img"></p><p>举例说明：</p><p>　　例：下例程序流程图描述了最多输入50个值(以–1作为输入结束标志)，计算其中有效的学生分数的个数、总分数和平均值。</p><p>​      <img src="http://hi.csdn.net/attachment/201110/22/0_13192496769a9T.gif" alt="img"></p><p>步骤1：导出过程的流图。</p><p>​      <img src="http://hi.csdn.net/attachment/201110/22/0_13192496968T97.gif" alt="img"></p><p>步骤2:确定环形复杂性度量V(G)：</p><p>　　1)V(G)= 6 (个区域)</p><p>　　2)V(G)=E–N+2=16–12+2=6</p><p>　　其中E为流图中的边数，N为结点数;</p><p>　　3)V(G)=P+1=5+1=6</p><p>　　其中P为谓词结点的个数。在流图中，结点2、3、5、6、9是谓词结点。</p><p>　　步骤3：确定基本路径集合(即独立路径集合)。于是可确定6条独立的路径：</p><p>　　路径1：1-2-9-10-12</p><p>　　路径2：1-2-9-11-12</p><p>　　路径3：1-2-3-9-10-12</p><p>　　路径4：1-2-3-4-5-8-2…</p><p>　　路径5：1-2-3-4-5-6-8-2…</p><p>　　路径6：1-2-3-4-5-6-7-8-2…</p><p>　　步骤4：为每一条独立路径各设计一组测试用例，以便强迫程序沿着该路径至少执行一次。</p><p>　　1)路径1(1-2-9-10-12)的测试用例：</p><p>　　score[k]=有效分数值，当k &lt; i ;</p><p>　　score[i]=–1, 2≤i≤50;</p><p>　　期望结果：根据输入的有效分数算出正确的分数个数n1、总分sum和平均分average。</p><p>　　2)路径2(1-2-9-11-12)的测试用例：</p><p>　　score[ 1 ]= – 1 ;</p><p>　　期望的结果：average = – 1，其他量保持初值。</p><p>　　3)路径3(1-2-3-9-10-12)的测试用例：</p><p>　　输入多于50个有效分数，即试图处理51个分数，要求前51个为有效分数;</p><p>　　期望结果：n1=50、且算出正确的总分和平均分。</p><p>　　4)路径4(1-2-3-4-5-8-2…)的测试用例：</p><p>　　score[i]=有效分数，当i&lt;50;</p><p>　　score[k]&lt;0， k&lt; i ;</p><p>　期望结果：根据输入的有效分数算出正确的分数个数n1、总分sum和平均分average。</p><p>​     <img src="http://hi.csdn.net/attachment/201110/22/0_13192497859ZSO.gif" alt="img"></p><p> 连接权为“1”表示存在一个连接，在图中如果一行有两个或更多的元素“1”，则这行所代表的结点一定是一个判定结点，通过连接矩阵中有两个以上(包括两个)元素为“1”的个数，就可以得到确定该图圈复杂度的另一种算法。</p><h3 id="（六）域测试法"><a href="#（六）域测试法" class="headerlink" title="（六）域测试法"></a>（六）域测试法</h3><p>域测试是一种基于程序结构的测试方法，基于对程序输入空间（域）的分析，选择测试点进行测试。</p><p>域测试主要测试如下错误：</p><p>1）域错误：程序的控制流存在错误，对于某一特定的输入可能执行的是一条错误路径，这种错误称为路径错误，也叫做域错误。</p><p>2）计算型错误：对于特定输入执行的路径正确，但赋值语句的错误导致输出结果错误，称为计算型错误。</p><p>3）丢失路径错误：由于程序中的某处少了一个判定谓词而引起的丢失路径错误。</p><h3 id="（七）符号测试"><a href="#（七）符号测试" class="headerlink" title="（七）符号测试"></a>（七）符号测试</h3><p>符号测试的基本思想是允许程序的输入不仅仅是具体的数值数据，而且包括符号值，符号值可以是基本的符号变量值，也可以是符号变量值的表达式。</p><h2 id="接口测试用例实际"><a href="#接口测试用例实际" class="headerlink" title="接口测试用例实际"></a>接口测试用例实际</h2><p><strong>设计思路</strong></p><p><strong>1)</strong>  <strong>优先级</strong>**–**<strong>针对所有接口</strong></p><p>1、暴露在外面的接口，因为通常该接口会给第三方调用；</p><p>2、供系统内部调用的核心功能接口；</p><p>3、供系统内部调用非核心功能接口； </p><p><strong>2)</strong>  <strong>优先级</strong>**–**<strong>针对单个接口</strong></p><p>1、正向用例优先测试,逆向用例次之(通常情况，非绝对)；</p><p>2、是否满足前提条件 &gt; 是否携带默认参值参数 &gt; 参数是否必填 &gt; 参数之间是否存在关联 &gt; 参数数据类型限制 &gt;参数数据类型自身的数据范围值限制  </p><p><strong>3)</strong>  <strong>设计分析</strong></p><p>通常，设计接口测试用例需要考虑以下几个方面：</p><p>1、是否满足前提条件</p><p>有些接口需要满足前置条件，才可成功获取数据。常见的，需要登陆Token。</p><p>逆向用例：</p><p>针对是否满足前置条件(假设为n个条件)，设计0~n条用例</p><p>2、是否携带默认值参数</p><p>正向用例：</p><p>带默认值的参数都不填写、不传参，必填参数都填写正确且存在的“常规”值，其它不填写，设计1条用例；</p><p>3、业务规则、功能需求</p><p>这里根据实际情况，结合接口参数说明，可能需要设计n条正向用例和逆向用例</p><p>5、参数是否必填</p><p>逆向用例：</p><p>针对每个必填参数，都设计1条参数值为空的逆向用例</p><p>4、参数之间是否存在关联</p><p>有些参数彼此之间存在相互制约的关系</p><p>逆向用例：</p><p>根据实际情况，可能需要设计0~n条用例</p><p>5、参数数据类型限制</p><p>逆向用例：</p><p>针对每个参数都设计1条参数值类型不符的逆向用例</p><p>6、参数数据类型自身的数据范围值限制</p><p>正向用例：</p><p>针对所有参数，设计1条每个参数的参数值在数据范围内为最大值的正向用例</p><p>逆向用例：</p><p>针对每个参数(假设n个)，设计n条每个参数的参数值都超出数据范围最大值的逆向用例</p><p>针对每个参数(假设n个)，设计n条每个参数的参数值都小于数据范围最小值的逆向用例</p><p>以上几个方面考虑全的话，基本可以做到如下几个方面的覆盖：</p><p>主流程测试用例：正常的主流程功能校验；</p><p>分支流测试用例：正常的分支流功能校验。</p><p>异常流测试用例：异常容错校验</p><p><strong>4)</strong>  <strong>编写描述</strong></p><p>尽量逻辑化，这样方便后续的维护</p><p><strong>5)</strong>  <strong>实践操作</strong></p><p><strong>接口样例</strong></p><h4 id="获取订单列表接口（多条件）"><a href="#获取订单列表接口（多条件）" class="headerlink" title="获取订单列表接口（多条件）"></a>获取订单列表接口（多条件）</h4><p>获取店铺指定期间的所有订单列表(多种条件组合)，默认根据日期倒序排序。</p><h4 id="接口方向"><a href="#接口方向" class="headerlink" title="接口方向"></a>接口方向</h4><p>客户端 -&gt; 服务端</p><h4 id="接口协议"><a href="#接口协议" class="headerlink" title="接口协议"></a>接口协议</h4><p>接口地址：$xxx_Home/xxx/鉴权前缀/xxxxx/getAllOrderList</p><p>接口协议：JSON</p><p>HTTP请求方式：GET</p><h4 id="消息请求"><a href="#消息请求" class="headerlink" title="消息请求"></a>消息请求</h4><p>字段列表如下：</p><table><thead><tr><th><strong>字段名</strong></th><th><strong>数据类型</strong></th><th><strong>默认值</strong></th><th><strong>必填项</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>shopId</td><td>int</td><td></td><td>是</td><td>商铺编号</td></tr><tr><td>token</td><td>string</td><td></td><td>条件</td><td>设备令牌。Token鉴权方式必填</td></tr><tr><td>dateType</td><td>int</td><td>1</td><td>否</td><td>订单查询时间字段。1：下单时间（order_time）2：订单完成时间（order_finish_time）3：结算时间（shop_settle_time）</td></tr><tr><td>startDate</td><td>date</td><td></td><td>是</td><td>查询日期</td></tr><tr><td>endDate</td><td>Date</td><td></td><td>否</td><td>查询结束日期。</td></tr><tr><td>orderStatus</td><td>String</td><td></td><td>否</td><td>订单状态。不填表示所有状态多个状态之间以英文逗号分割0:已预定1:已开单2:派送中3:已完成（原已结帐）4:退单中5:已退单8:自助下单9:待确认</td></tr><tr><td>orderTransactionType</td><td>Int</td><td></td><td>否</td><td>订单交易状态。不填表示所有。1:未完成，2:已完成(3:已完成, 5:已退单)</td></tr><tr><td>payType</td><td>int</td><td></td><td>否</td><td>支付方式。不填表示所有。1:现金2:POS3:线上</td></tr><tr><td>cashierId</td><td>int</td><td></td><td>否</td><td>收银员</td></tr><tr><td>billerId</td><td>int</td><td></td><td>否</td><td>导购员</td></tr><tr><td>pNo</td><td>int</td><td></td><td>否</td><td>页码,从第1页开始，默认为1</td></tr><tr><td>pSize</td><td>int</td><td></td><td>否</td><td>每页记录数，默认为10</td></tr></tbody></table><p>消息请求样例：</p><p><strong>?shopId=</strong><a href="https://bitbucket.org/xpanpapp/api-doccuments/commits/1111111111">1111111111</a>**&amp;token=<strong>123411nmk515155</strong>&amp;**<strong>queryDate</strong>=2015-10-10</p><h4 id="消息响应"><a href="#消息响应" class="headerlink" title="消息响应"></a>消息响应</h4><p>字段元素如下：</p><table><thead><tr><th><strong>字段名</strong></th><th><strong>数据类型</strong></th><th><strong>默认值</strong></th><th><strong>必填项</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>orderTotalPriceTotal</td><td>double</td><td></td><td>是</td><td>实收金额合计（已完成的合计）</td></tr><tr><td>platformTotalIncomePriceTotal</td><td>double</td><td></td><td>是</td><td>平台服务费合计</td></tr><tr><td>cashPayTotal</td><td>double</td><td></td><td>否</td><td>现金支付（已完成的合计）</td></tr><tr><td>posPayTotal</td><td>double</td><td></td><td>否</td><td>POS支付（已完成的合计）</td></tr><tr><td>onLinePayTotal</td><td>double</td><td></td><td>否</td><td>线上支付（已完成的合计）</td></tr><tr><td>lst</td><td>object</td><td></td><td>是</td><td>明细列表</td></tr></tbody></table><p>明细列表对象字段元素定义：</p><table><thead><tr><th><strong>字段名</strong></th><th><strong>数据类型</strong></th><th><strong>默认值</strong></th><th><strong>必填项</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>orderId</td><td>string</td><td></td><td>是</td><td>订单ID</td></tr><tr><td>orderTitle</td><td>string</td><td></td><td>是</td><td>订单标题</td></tr><tr><td>mobile</td><td>string</td><td></td><td>否</td><td>会员账号,如果是会员则显示手机号，为空时表示“非会员”</td></tr><tr><td>settlePrice</td><td>double</td><td></td><td>是</td><td>交易金额</td></tr><tr><td>orderTime</td><td>datetime</td><td></td><td>是</td><td>下单时间</td></tr><tr><td>serviceAmount</td><td>double</td><td></td><td>是</td><td>平台服务费</td></tr><tr><td>Status</td><td>Int</td><td></td><td>是</td><td>订单状态。0:已预定1:已开单2:派送中3:已完成（原已结帐）4:退单中5:已退单8:自助下单9:待确认</td></tr><tr><td>cashPay</td><td>double</td><td></td><td>否</td><td>现金支付</td></tr><tr><td>posPay</td><td>double</td><td></td><td>否</td><td>POS支付</td></tr><tr><td>onLinePay</td><td>double</td><td></td><td>否</td><td>线上支付</td></tr></tbody></table><p>成功时，返回JSON数据包：</p><p>{</p><p>  “code”: 0,</p><p>  “msg”: “查询订单列表成功！”,</p><p>  “data”: {</p><p>​    “pNo”: 1,</p><p>​    “rCount”: 5,</p><p>​    “orderTotalPriceTotal”: 23.3,</p><p>​    “platformTotalIncomePriceTotal”: 0,</p><p>​    “lst”: [</p><p>​      {</p><p>​        “orderTitle”: “kouxiangtang”,</p><p>​        “settlePrice”: 15.89,</p><p>​        “cashTotal”: 15.89,</p><p>​        “posTotal”: 0,</p><p>​        “onLineTotal”: 0,</p><p>​        “orderTime”: “2015-09-29 13:44:26”,</p><p>​        “orderId”: “12345679282015092913440268141”,</p><p>​        “mobile”: “13424183952”</p><p>​      },</p><p>​      {</p><p>​        “orderTitle”: “红塔山”,</p><p>​        “settlePrice”: 7.5,</p><p>​        “cashTotal”: 7.5,</p><p>​        “posTotal”: 0,</p><p>​        “onLineTotal”: 0,</p><p>​        “orderTime”: “2015-09-29 11:37:58”,</p><p>​        “orderId”: “12345679282015092911370588273”</p><p>​      }</p><p>​    ]</p><p>  }</p><p>}</p><p><strong>用例设计</strong></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=13cc013b50102w1ot&amp;url=http://album.sina.com.cn/pic/005NDN77gy6YeJCRqFaf8"><img src="http://s9.sinaimg.cn/mw690/005NDN77gy6YeJCRqFaf8&amp;690" alt="测试思想-测试设计 接口测试用例设计实践总结"></a></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=13cc013b50102w1ot&amp;url=http://album.sina.com.cn/pic/005NDN77gy6YeJDjDFC68"><img src="http://s9.sinaimg.cn/mw690/005NDN77gy6YeJDjDFC68&amp;690" alt="测试思想-测试设计 接口测试用例设计实践总结"></a></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=13cc013b50102w1ot&amp;url=http://album.sina.com.cn/pic/005NDN77gy6YeJE0xQm92"><img src="http://s3.sinaimg.cn/mw690/005NDN77gy6YeJE0xQm92&amp;690" alt="测试思想-测试设计 接口测试用例设计实践总结"></a></p><p><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=13cc013b50102w1ot&amp;url=http://album.sina.com.cn/pic/005NDN77gy6YeJEjRd9cb"><img src="http://s12.sinaimg.cn/mw690/005NDN77gy6YeJEjRd9cb&amp;690" alt="测试思想-测试设计 接口测试用例设计实践总结"></a></p><p><strong>存在问题：</strong></p><p>如上，还没写完就有40几条用例了，要是接口参数再多点，接口数量再增加点，工作量可想而知，所以，问题来了，咋办呢？</p><p>个人见解：</p><p>1、根据接口的使用对象(外部，系统内部)，有选择的去、留部分用例</p><p>2、根据接口的是否核心接口，有选择的去、留部分用例</p><p>3、根据参数说明，及实际情况，有选择的去、留部分用例</p><p>实例：</p><p>上例这个接口，是供app、商铺后台调用的，且为系统内部调用，所以，以下用例可酌情略去：</p><p>test-E-按商铺id查询-商铺id非int型</p><p>test-E-按设备token查询-token非string类型</p><p>test-E-按订单时间类型查询-时间类型非int型</p><p>test-E-按起始日期查询-时间类型非date型</p><p>test-E-按结束日期查询-时间类型非date型</p><p>test-E-按订单状态查询-订单状态非string类型</p><p>test-E-按交易状态查询-交易状态非int型</p><p>test-E-按支付方式查询-支付方式非int值</p><p>test-E-按收银员查询-收银员id非int值</p><p>test-E-按导购员查询-导购员id非int值</p><p>test-E-按页码查询-页码非int值</p><p>理由：</p><p>这个接口是给其它开发于系统内部调用的，开发过程中，开发者肯定需要调用这些接口，如果类型错了，他们也就获取不到预期的数据，这些错误，他们肯定可以发现，所以，他们传递的参数值一般能保证类型正确。</p><p>test-N-按参数类型最大值查询  所有参数</p><p>test-E-按商铺id查询-商铺id超过类型范围值</p><p>test-E-按订单状态查询-订单状态值超过类型最大值</p><p>test-E-按交易状态查询-交易状态值超过int类型最大值</p><p>略去的用例部分（参数值超过类型最大值）</p><p>理由：</p><p>1、内部调用，参数值不是外部手动输入的，输入数据长度、值大小可控，当然如果数据一直增长，那再大的类型可能都无法保证不超出，比如自动增长的商铺id</p><p>2、部分参数的参数值是自定义的，比如 订单时间类型，就那几种，除非传错了，不然不可能超出范围</p><p>最后简化后的用例数差不多28条，如果是手工测试，对于正向用例，根据等价类原理，可以制造一条数据，覆盖多条用例，当然，也可以冗余处理，即一条用例一条数据，这样的好处就是每次的验证点比较单一一点，比较有针对性。</p>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
            <tag> 测试用例 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件程序设计原则（三）</title>
      <link href="/2020/08/20/ruan-jian-she-ji-yuan-ze-san/"/>
      <url>/2020/08/20/ruan-jian-she-ji-yuan-ze-san/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。每个程序员都可以从理解编程原则和模式中受益。</p><p>软件设计原则是一组帮助我们避开不良设计的指导方针。根据Robert Martin的理论，应该避免不良设计的以下三个重要特点：</p><ul><li><strong>僵化</strong>：很难做改动，因为每一个细微的改动都会影响到系统大量的其他功能</li><li><strong>脆弱</strong>：每当你做一次改动，总会引起系统中预期之外的部分出现故障</li><li><strong>死板</strong>：代码很难在其他应用中重用，因其不能从当前应用中单独抽离出来</li></ul><p>下面这些软件设计原则是我从一些书籍和网络中收集而来，并不完整，而且你也需要在一些有“冲突的原则”之间进行权衡和取舍。本文或许会对你的编程、程序设计、讨论或评审工作有所帮助。</p><h2 id="二、通用设计原则"><a href="#二、通用设计原则" class="headerlink" title="二、通用设计原则"></a>二、通用设计原则</h2><h3 id="1-KISS"><a href="#1-KISS" class="headerlink" title="1. KISS"></a>1. KISS</h3><p>所谓KISS原则，即：Keep It Simple,Stupid，指<strong>设计时要坚持简约原则，避免不必要的复杂化，并且易于修改</strong>。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">Everything should be made as simple as possible, but not simpler. - Albert Einstein</font></td></tr></tbody></table><p>简单清晰、功能强大是软件设计最重要的原则和目标。但是软件工程天然错综复杂，而“简单”却没有一个衡量标准，判断和实现一个东西是不是简单，可以通过以下方式来参考。</p><ul><li>让别的软件工程师以一种最容易的方式使用你的方案。</li><li>简单不是走捷径，不是为手边的问题找一个最快的方案。</li><li>当系统变得更庞大更复杂的时候依然能够被理解。</li><li>如果系统无法保持简单，那么我们能做的就是保持各个局部简单，即任何单个的类、模块、应用的设计目标及工作原理都能被快速理解。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black">**我的理解**：保持简单但不能掩盖软件丰富的内涵。即**简约而不简单**！简约是对复杂的事物抽丝剥茧、去除细枝末节显露主要逻辑的过程。就像小时候老师教写文章，要求尽可能用朴实的语言，言简意赅的写出来，但却又要避免语言过于贫乏。软件的“抽象”和它的“直观性”，其实是一对矛盾的关系，软件设计就要保证这两者的平衡。代码抽象过于复杂会陷入“过度设计”不易理解的困境；为了“直观性”缺乏抽象，长此以往又会出现大量的重复、不易于扩展和难维护的困境。</font></td></tr></tbody></table><h3 id="2-DRY"><a href="#2-DRY" class="headerlink" title="2. DRY"></a>2. DRY</h3><p>所谓DRY原则，即：Don’t Repeat Yourself，<strong>不要让自己重复</strong>。</p><p><strong>重复代码是软件程序变烂的万恶之首</strong>。DRY并不是指你不能复制代码，而是你复制的代码不能包含重复的“信息”。复制的东西并不仅仅是复制了代码，而是由于你把同一个信息散播在了代码的各个部分导致了有很多相近的代码也散播在各个地方。代码之所以要写的好，不要重复某些“信息”，因为需求人员总是要改需求，不改代码你就要“死”，改代码你就要加班，所以为了减少修改代码的痛苦，我们不能重复任何信息。举个例子，有一天需求人员说，要把分隔符从分号改成顿号！一下子就要改多个地方了。</p><p>所以，<strong>去掉重复的信息会让你的代码结构发生本质的变化</strong>。</p><p>“重复代码”有很多变体：</p><ul><li>魔法数字、魔法字符串等</li><li>相同代码块</li><li>相似的代码逻辑及操作</li></ul><p>对于消除重复的代码有<strong>事不过三法则</strong>。</p><ul><li>第一次先写了一段代码。</li><li>第二次在另一个地方写了一段相同或相似逻辑的代码，你已经有消除和提取重复代码的冲动了。</li><li>再次在另一个地方写了同样的代码，你已忍无可忍，现在可以考虑抽取和消除重复代码了。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black">我的理解：解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过重构的手段来消除重复。发现和解决重复并不困难，通过提取抽象、提取方法等措施就能消除重复，但困难的是立即行动去解决重复，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。解决了重复，经过一段时间，你就会发现，你对整个系统的理解程度在不知不觉中提高了不少。</font></td></tr></tbody></table><h3 id="3-Maximize-Cohesion，-Minimize-Coupling"><a href="#3-Maximize-Cohesion，-Minimize-Coupling" class="headerlink" title="3. Maximize Cohesion， Minimize Coupling"></a>3. Maximize Cohesion， Minimize Coupling</h3><p>所谓Maximize Cohesion,Minimize Coupling原则，即：<strong>高内聚低耦合</strong>。这是判断设计好坏的标准，主要是看<strong>模块内的内聚性是否高，模块间的耦合度是否低</strong>。</p><ul><li><strong>耦合性</strong>：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</li><li><strong>内聚性</strong>：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</li></ul><p>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><p>Java中实现高内聚低耦合的常用方式：</p><ul><li>少使用类的继承，多用接口隐藏实现的细节。</li><li>模块的功能化分尽可能的单一，道理也很简单,功能单一的模块供其它模块调用的机会就少。</li><li>遵循一个定义只在一个地方出现。</li><li>少使用全局变量。</li><li>类属性和方法的声明少用public，多用private关键字，</li><li>多用设计模式，比如采用MVC的设计模式就可以降低界面与业务逻辑的耦合度。</li><li>尽量不用“硬编码”的方式写程序。</li><li>最后当然就是避免直接操作或调用其它模块或类（内容耦合）。</li></ul><h3 id="4-SOC"><a href="#4-SOC" class="headerlink" title="4. SOC"></a>4. SOC</h3><p>所谓SOC原则，即：<strong>关注点分离</strong>（Separation of Concerns）。<strong>不同领域的功能，应该由不同的代码和最小重迭的模块组成</strong>。关注点分离是处理复杂性的一个原则。由于关注点混杂在一起会导致软件程序复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。关注点分离原则不仅体现在软件程序设计等设计方法中，同时也体现在架构设计、问题求解、软件开发过程、软件项目管理以及软件开发方法学等诸多方面。</p><p>MVC就是关注点分离的一个体现，把业务逻辑、数据、界面分离，这也是组织代码结构的一个形式。MVC的基本结构：</p><ul><li>Model层表示应用程序的数据核心，通常负责在数据库中存取数据。</li><li>View是应用程序的显示层，通常是依据模型的数据而建立。</li><li>Controller是用来控制和处理输入输出的，是处理用户交互的部分，也负责向模型（Model层）发送数据。</li></ul><p>MVC的这个设计各个关注点是分开的，这样有助于我们管理和开发复杂的应用程序，我们可以在某个时间点只集中精力在其中的某一个关注点，而不是所有的部分。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。即使需要改变，也能够清晰地识别出那些部分需要改变。如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。——Ivar Jacobson(《AOSD中文版》)</font></td></tr></tbody></table><h3 id="分离方式"><a href="#分离方式" class="headerlink" title="分离方式"></a>分离方式</h3><p>下面将介绍一些分层的思想和方式:</p><ul><li><strong>纵向分离</strong>: 如常见的三层架构（逻辑控制层、业务处理层和数据持久化层）。</li><li><strong>横向分离</strong>: 如把我们的软件拆分成模块或子系统。从左到右是模块1、模块2、模块3，这是一种水平方向的切割。这跟纵向的分离是两个不同的方向，横向分离大多是模块化的过程。</li><li><strong>切面分离</strong>: 有些内容是多个层之间都需要的，比如日志（log），在你的系统里面，界面层、逻辑层、数据访问层可能都需要写日志，这种跨到多层同样逻辑就可以考虑切面分离。</li><li><strong>依赖方向分离</strong>: 按依赖方向考虑，决定某个类应该放在哪个层次里面，或者考虑将某一层切割成多层。</li><li><strong>关注数据分离</strong>: 在组织数据时，应该尽量考虑数据本身的固有属性，如果不是它们的固有属性，那么应该分离出来。比如产品的类就不应该关联customer类，应该是用订单类来把他们联系在一起。</li><li><strong>关注行为分离</strong>: 行为也应该是事物或对象的固有的本身的行为，明显偏离原来行为的，应该考虑成另外的关注点儿分离开。比如有一个函数叫做CreateNewCustomer()，那么CreateNewCustomer()的行为就应该限定在创建一个新客户上面，给新客户自动发优惠券的动作就不能放到这个函数里面。</li><li><strong>扩展分离</strong>: 如果基于某种设计，原先不具有某些行为需要增加，可以考虑通过扩展或插件的形式来完成，将这些功能放入到插件或扩展中。</li><li><strong>反转分离</strong>: 很多依赖注入的框架，如Spring、Guice等等，这些帮助我们做依赖反转，从而倒置依赖关系</li></ul><h3 id="5-YAGNI"><a href="#5-YAGNI" class="headerlink" title="5. YAGNI"></a>5. YAGNI</h3><p>所谓YAGNI原则，即：You Ain’t Gonna Need It，<strong>你不需要它</strong>。它是一种极限编程（XP）实践，表示程序员不应为目前还不需要的功能编写代码。YAGNI很像KISS原则，因为它也是致力于构建简单的方案。然而，KISS是通过尽可能容易的完成某件事情来实现精简方案；但YAGNI是通过根本就不实现它来达到精简。YAGNI的观点是你应该<strong>为了眼前的需求做设计而不是未来</strong>。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">只在真正需要某些功能的时候才去实现它，而不是仅仅因为你预见到它将出现。- XP的联合创始人Ron Jeffries</font></td></tr></tbody></table><p>即使你非常确信将来你需要某个特性，也不要现在就去实现它。在很多情况下，你会发现或许最终你不需要它了，或者是你真正所需的特性与你之前预计的有很大的出入。遵循 YAGNI 实践有两个主要原因：</p><ul><li>你节约了时间，因为你避免了编写最终证明不必要的代码。</li><li>你的代码质量更高了，因为你使代码不必为你的“推测”所污染，而这些“推测”最终可能或多或少有些错误，但此时这些错误已牢牢地依附在你的代码中了。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black"> **我的理解** ：YAGNI 原则，本质上是告诫我们**写代码不要画蛇添足，否则就会弄巧成拙了**。编写业务代码时，不要去假想一些需求或者场景，因为大多数你所设想的场景都不会发生，而你所多写的那些代码也将会长期滞留在你的系统中，收效甚微，但却让你和团队花费了更多的时间和精力去书写和维护，更可怕的是可能会对将来新的代码维护人造成困惑。另外对于没有被使用到的代码，我认为也都应该立即删除，从而保持系统的精简，如果将来需要时再去书写或恢复，而且那时侯写出的代码也绝对比之前的更为契合。</font></td></tr></tbody></table><h3 id="6-Boy-Scout-Rule"><a href="#6-Boy-Scout-Rule" class="headerlink" title="6. Boy-Scout Rule"></a>6. Boy-Scout Rule</h3><p>Boy-Scout Rule，译为：<strong>童子军规则</strong>。美国童子军有一个简单的规则：“让营地比你刚来时更干净(Always leave the campground cleaner than you found it)”。如果看到地上有垃圾，不管是谁扔的，都要清理。这样你就有意地为下一批来宿营的人改善了环境。</p><p>童子军规则告诉我们在对现有代码库进行更改时，代码质量往往会降低，从而积累技术债务。所以需要始终保持代码整洁。不管原作者是谁，如果我们努力去改进代码模块，不管是多么小的改进，我们的软件系统就再也不会持续变坏了。取而代之的是，系统在发展的同时会逐渐变得更好。我们也会看到团队们关心整体的系统，而不是各自只关心自己负责的一小部分。而且团队成员要互助，互相清理代码，他们遵从童子军规则，因为那对每个人都很好，而不仅仅是对自己好。</p><p>关于童子军规则中所提倡的<strong>对代码坏味道的尽早修复</strong>，我也想起来了我们所熟知的<strong>“破窗效应</strong>”和<strong>“讳疾忌医”</strong>的典故：</p><h3 id="破窗效应"><a href="#破窗效应" class="headerlink" title="破窗效应"></a>破窗效应</h3><table><tbody><tr><td bgcolor="lightblue"><font color="black">如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些示范性的纵容去打烂更多的窗户。久而久之，这些破窗户就给人造成一种无序的感觉，结果在这种公众麻木不仁的氛围中，犯罪就会滋生、猖獗。——政治学家威尔逊和犯罪学家凯琳提出的“破窗效应”理论</font></td></tr></tbody></table><ul><li>“环境早就脏了，我扔的这点儿垃圾根本起不到关键性作用。”</li><li>“这个代码以前的其他人也都是这样写的。”</li><li>“反正也不是只有我才这么写代码的。”</li></ul><p>不少人会像上面这样辩解自己的过错。其实，这些说法根本站不住脚，错了就是错了，影响的大小并不能改变行为错误的本质，别人的错误更不会是证明你无错的理由。任何一种不良现象的存在，都有可能传递一种错误信息。进而导致更坏的后果，正所谓“<strong>千里之堤，溃于蚁穴”、勿以善小而不为，勿以恶小而为之</strong>。</p><h3 id="讳疾忌医的典故"><a href="#讳疾忌医的典故" class="headerlink" title="讳疾忌医的典故"></a>讳疾忌医的典故</h3><p>《扁鹊见蔡桓公》的故事，我们从小就学习了，告诉我们不能盲目相信自己，不能讳疾忌医。但想想我们自己代码的坏味道和bug，也是如出一辙。</p><p>代码坏味道或者糟糕的程序代码就像隐形的“疾病”一样潜伏在项目中，也因此形成了技术债务。如果这些“疾病”在项目初期不引起注关注、不把疾病扼杀在萌芽之中，那么后期修复它的代价也就越大，也必然会使得项目的软件程序越来越难以维护，这个项目也最终会像蔡桓公一样无药可治、“无奈何也”。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">所以，请记住童子军规则对我们的启示：**始终保持代码整洁，勿以善小而不为，勿以恶小而为之，有病早治**。</font></td></tr></tbody></table><h3 id="其他原则："><a href="#其他原则：" class="headerlink" title="其他原则："></a>其他原则：</h3><ul><li>避免过早优化（Avoid Premature Optimization）: 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。“过早的优化是一切罪恶之源。”——Donald Knuth</li><li>最小惊讶原则(Principle of least astonishment): 代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。</li><li>代码重用原则（Code Reuse is Good）: 重用代码能提高代码的可读性，缩短开发时间。</li><li>别让我思考(Don’t Make Me Think): 所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</li><li>为维护者写代码(Write Code for the Maintainer): 优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。“如果一个维护者不再继续维护你的代码，很可能他就有了想杀你的冲动。”</li><li>正交原则(Orthogonality): 正交性的基本思想是，在概念上不相关的事物不应该与系统相关。设计越正交，异常越少。 这使得用编程语言更容易学习，读写程序。(反例：CSS)。</li><li>做最简单的事儿就让代码可运行（Do the simplest thing that could possibly work）: 尽可能做最简单的事就可以让代码可运行。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢？”这将有助于在设计中保持简单的路径。</li><li>隐藏实现细节（Hide Implementation Details）: 软件模块通过提供接口隐藏信息（即实现细节），而不泄漏任何不必要的信息。</li><li>科里定律(Curly’s Law): 是为任何特定的代码选择一个明确定义的目标：只做一件事。</li><li>墨菲定律（Murphy’s Law）:根本内容是：如果事情有变坏的可能，不管这种可能性有多小，它总会发生。主要内容如下：<br>&nbsp;&nbsp; - 任何事都没有表面看起来那么简单；<br>&nbsp;&nbsp; - 所有的事都会比你预计的时间长；<br>&nbsp;&nbsp; - 会出错的事总会出错；<br>&nbsp;&nbsp; - 如果你担心某种情况发生，那么它就更有可能发生。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件程序设计原则（二）</title>
      <link href="/2020/08/17/ruan-jian-she-ji-yuan-ze-er/"/>
      <url>/2020/08/17/ruan-jian-she-ji-yuan-ze-er/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。每个程序员都可以从理解编程原则和模式中受益。</p><p>软件设计原则是一组帮助我们避开不良设计的指导方针。根据Robert Martin的理论，应该避免不良设计的以下三个重要特点：</p><ul><li><strong>僵化</strong>：很难做改动，因为每一个细微的改动都会影响到系统大量的其他功能</li><li><strong>脆弱</strong>：每当你做一次改动，总会引起系统中预期之外的部分出现故障</li><li><strong>死板</strong>：代码很难在其他应用中重用，因其不能从当前应用中单独抽离出来</li></ul><p>下面这些软件设计原则是我从一些书籍和网络中收集而来，并不完整，而且你也需要在一些有“冲突的原则”之间进行权衡和取舍。本文或许会对你的编程、程序设计、讨论或评审工作有所帮助。</p><h2 id="二、通用设计原则"><a href="#二、通用设计原则" class="headerlink" title="二、通用设计原则"></a>二、通用设计原则</h2><h3 id="1-KISS"><a href="#1-KISS" class="headerlink" title="1. KISS"></a>1. KISS</h3><p>所谓KISS原则，即：Keep It Simple,Stupid，指<strong>设计时要坚持简约原则，避免不必要的复杂化，并且易于修改</strong>。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">Everything should be made as simple as possible, but not simpler. - Albert Einstein</font></td></tr></tbody></table><p>简单清晰、功能强大是软件设计最重要的原则和目标。但是软件工程天然错综复杂，而“简单”却没有一个衡量标准，判断和实现一个东西是不是简单，可以通过以下方式来参考。</p><ul><li>让别的软件工程师以一种最容易的方式使用你的方案。</li><li>简单不是走捷径，不是为手边的问题找一个最快的方案。</li><li>当系统变得更庞大更复杂的时候依然能够被理解。</li><li>如果系统无法保持简单，那么我们能做的就是保持各个局部简单，即任何单个的类、模块、应用的设计目标及工作原理都能被快速理解。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black">**我的理解**：保持简单但不能掩盖软件丰富的内涵。即**简约而不简单**！简约是对复杂的事物抽丝剥茧、去除细枝末节显露主要逻辑的过程。就像小时候老师教写文章，要求尽可能用朴实的语言，言简意赅的写出来，但却又要避免语言过于贫乏。软件的“抽象”和它的“直观性”，其实是一对矛盾的关系，软件设计就要保证这两者的平衡。代码抽象过于复杂会陷入“过度设计”不易理解的困境；为了“直观性”缺乏抽象，长此以往又会出现大量的重复、不易于扩展和难维护的困境。</font></td></tr></tbody></table><h3 id="2-DRY"><a href="#2-DRY" class="headerlink" title="2. DRY"></a>2. DRY</h3><p>所谓DRY原则，即：Don’t Repeat Yourself，<strong>不要让自己重复</strong>。</p><p><strong>重复代码是软件程序变烂的万恶之首</strong>。DRY并不是指你不能复制代码，而是你复制的代码不能包含重复的“信息”。复制的东西并不仅仅是复制了代码，而是由于你把同一个信息散播在了代码的各个部分导致了有很多相近的代码也散播在各个地方。代码之所以要写的好，不要重复某些“信息”，因为需求人员总是要改需求，不改代码你就要“死”，改代码你就要加班，所以为了减少修改代码的痛苦，我们不能重复任何信息。举个例子，有一天需求人员说，要把分隔符从分号改成顿号！一下子就要改多个地方了。</p><p>所以，<strong>去掉重复的信息会让你的代码结构发生本质的变化</strong>。</p><p>“重复代码”有很多变体：</p><ul><li>魔法数字、魔法字符串等</li><li>相同代码块</li><li>相似的代码逻辑及操作</li></ul><p>对于消除重复的代码有<strong>事不过三法则</strong>。</p><ul><li>第一次先写了一段代码。</li><li>第二次在另一个地方写了一段相同或相似逻辑的代码，你已经有消除和提取重复代码的冲动了。</li><li>再次在另一个地方写了同样的代码，你已忍无可忍，现在可以考虑抽取和消除重复代码了。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black">我的理解：解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过重构的手段来消除重复。发现和解决重复并不困难，通过提取抽象、提取方法等措施就能消除重复，但困难的是立即行动去解决重复，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。解决了重复，经过一段时间，你就会发现，你对整个系统的理解程度在不知不觉中提高了不少。</font></td></tr></tbody></table><h3 id="3-Maximize-Cohesion，-Minimize-Coupling"><a href="#3-Maximize-Cohesion，-Minimize-Coupling" class="headerlink" title="3. Maximize Cohesion， Minimize Coupling"></a>3. Maximize Cohesion， Minimize Coupling</h3><p>所谓Maximize Cohesion,Minimize Coupling原则，即：<strong>高内聚低耦合</strong>。这是判断设计好坏的标准，主要是看<strong>模块内的内聚性是否高，模块间的耦合度是否低</strong>。</p><ul><li><strong>耦合性</strong>：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</li><li><strong>内聚性</strong>：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</li></ul><p>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><p>Java中实现高内聚低耦合的常用方式：</p><ul><li>少使用类的继承，多用接口隐藏实现的细节。</li><li>模块的功能化分尽可能的单一，道理也很简单,功能单一的模块供其它模块调用的机会就少。</li><li>遵循一个定义只在一个地方出现。</li><li>少使用全局变量。</li><li>类属性和方法的声明少用public，多用private关键字，</li><li>多用设计模式，比如采用MVC的设计模式就可以降低界面与业务逻辑的耦合度。</li><li>尽量不用“硬编码”的方式写程序。</li><li>最后当然就是避免直接操作或调用其它模块或类（内容耦合）。</li></ul><h3 id="4-SOC"><a href="#4-SOC" class="headerlink" title="4. SOC"></a>4. SOC</h3><p>所谓SOC原则，即：<strong>关注点分离</strong>（Separation of Concerns）。<strong>不同领域的功能，应该由不同的代码和最小重迭的模块组成</strong>。关注点分离是处理复杂性的一个原则。由于关注点混杂在一起会导致软件程序复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。关注点分离原则不仅体现在软件程序设计等设计方法中，同时也体现在架构设计、问题求解、软件开发过程、软件项目管理以及软件开发方法学等诸多方面。</p><p>MVC就是关注点分离的一个体现，把业务逻辑、数据、界面分离，这也是组织代码结构的一个形式。MVC的基本结构：</p><ul><li>Model层表示应用程序的数据核心，通常负责在数据库中存取数据。</li><li>View是应用程序的显示层，通常是依据模型的数据而建立。</li><li>Controller是用来控制和处理输入输出的，是处理用户交互的部分，也负责向模型（Model层）发送数据。</li></ul><p>MVC的这个设计各个关注点是分开的，这样有助于我们管理和开发复杂的应用程序，我们可以在某个时间点只集中精力在其中的某一个关注点，而不是所有的部分。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。即使需要改变，也能够清晰地识别出那些部分需要改变。如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。——Ivar Jacobson(《AOSD中文版》)</font></td></tr></tbody></table><h3 id="分离方式"><a href="#分离方式" class="headerlink" title="分离方式"></a>分离方式</h3><p>下面将介绍一些分层的思想和方式:</p><ul><li><strong>纵向分离</strong>: 如常见的三层架构（逻辑控制层、业务处理层和数据持久化层）。</li><li><strong>横向分离</strong>: 如把我们的软件拆分成模块或子系统。从左到右是模块1、模块2、模块3，这是一种水平方向的切割。这跟纵向的分离是两个不同的方向，横向分离大多是模块化的过程。</li><li><strong>切面分离</strong>: 有些内容是多个层之间都需要的，比如日志（log），在你的系统里面，界面层、逻辑层、数据访问层可能都需要写日志，这种跨到多层同样逻辑就可以考虑切面分离。</li><li><strong>依赖方向分离</strong>: 按依赖方向考虑，决定某个类应该放在哪个层次里面，或者考虑将某一层切割成多层。</li><li><strong>关注数据分离</strong>: 在组织数据时，应该尽量考虑数据本身的固有属性，如果不是它们的固有属性，那么应该分离出来。比如产品的类就不应该关联customer类，应该是用订单类来把他们联系在一起。</li><li><strong>关注行为分离</strong>: 行为也应该是事物或对象的固有的本身的行为，明显偏离原来行为的，应该考虑成另外的关注点儿分离开。比如有一个函数叫做CreateNewCustomer()，那么CreateNewCustomer()的行为就应该限定在创建一个新客户上面，给新客户自动发优惠券的动作就不能放到这个函数里面。</li><li><strong>扩展分离</strong>: 如果基于某种设计，原先不具有某些行为需要增加，可以考虑通过扩展或插件的形式来完成，将这些功能放入到插件或扩展中。</li><li><strong>反转分离</strong>: 很多依赖注入的框架，如Spring、Guice等等，这些帮助我们做依赖反转，从而倒置依赖关系</li></ul><h3 id="5-YAGNI"><a href="#5-YAGNI" class="headerlink" title="5. YAGNI"></a>5. YAGNI</h3><p>所谓YAGNI原则，即：You Ain’t Gonna Need It，<strong>你不需要它</strong>。它是一种极限编程（XP）实践，表示程序员不应为目前还不需要的功能编写代码。YAGNI很像KISS原则，因为它也是致力于构建简单的方案。然而，KISS是通过尽可能容易的完成某件事情来实现精简方案；但YAGNI是通过根本就不实现它来达到精简。YAGNI的观点是你应该<strong>为了眼前的需求做设计而不是未来</strong>。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">只在真正需要某些功能的时候才去实现它，而不是仅仅因为你预见到它将出现。- XP的联合创始人Ron Jeffries</font></td></tr></tbody></table><p>即使你非常确信将来你需要某个特性，也不要现在就去实现它。在很多情况下，你会发现或许最终你不需要它了，或者是你真正所需的特性与你之前预计的有很大的出入。遵循 YAGNI 实践有两个主要原因：</p><ul><li>你节约了时间，因为你避免了编写最终证明不必要的代码。</li><li>你的代码质量更高了，因为你使代码不必为你的“推测”所污染，而这些“推测”最终可能或多或少有些错误，但此时这些错误已牢牢地依附在你的代码中了。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black"> **我的理解** ：YAGNI 原则，本质上是告诫我们**写代码不要画蛇添足，否则就会弄巧成拙了**。编写业务代码时，不要去假想一些需求或者场景，因为大多数你所设想的场景都不会发生，而你所多写的那些代码也将会长期滞留在你的系统中，收效甚微，但却让你和团队花费了更多的时间和精力去书写和维护，更可怕的是可能会对将来新的代码维护人造成困惑。另外对于没有被使用到的代码，我认为也都应该立即删除，从而保持系统的精简，如果将来需要时再去书写或恢复，而且那时侯写出的代码也绝对比之前的更为契合。</font></td></tr></tbody></table><h3 id="6-Boy-Scout-Rule"><a href="#6-Boy-Scout-Rule" class="headerlink" title="6. Boy-Scout Rule"></a>6. Boy-Scout Rule</h3><p>Boy-Scout Rule，译为：<strong>童子军规则</strong>。美国童子军有一个简单的规则：“让营地比你刚来时更干净(Always leave the campground cleaner than you found it)”。如果看到地上有垃圾，不管是谁扔的，都要清理。这样你就有意地为下一批来宿营的人改善了环境。</p><p>童子军规则告诉我们在对现有代码库进行更改时，代码质量往往会降低，从而积累技术债务。所以需要始终保持代码整洁。不管原作者是谁，如果我们努力去改进代码模块，不管是多么小的改进，我们的软件系统就再也不会持续变坏了。取而代之的是，系统在发展的同时会逐渐变得更好。我们也会看到团队们关心整体的系统，而不是各自只关心自己负责的一小部分。而且团队成员要互助，互相清理代码，他们遵从童子军规则，因为那对每个人都很好，而不仅仅是对自己好。</p><p>关于童子军规则中所提倡的<strong>对代码坏味道的尽早修复</strong>，我也想起来了我们所熟知的<strong>“破窗效应</strong>”和<strong>“讳疾忌医”</strong>的典故：</p><h3 id="破窗效应"><a href="#破窗效应" class="headerlink" title="破窗效应"></a>破窗效应</h3><table><tbody><tr><td bgcolor="lightblue"><font color="black">如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些示范性的纵容去打烂更多的窗户。久而久之，这些破窗户就给人造成一种无序的感觉，结果在这种公众麻木不仁的氛围中，犯罪就会滋生、猖獗。——政治学家威尔逊和犯罪学家凯琳提出的“破窗效应”理论</font></td></tr></tbody></table><ul><li>“环境早就脏了，我扔的这点儿垃圾根本起不到关键性作用。”</li><li>“这个代码以前的其他人也都是这样写的。”</li><li>“反正也不是只有我才这么写代码的。”</li></ul><p>不少人会像上面这样辩解自己的过错。其实，这些说法根本站不住脚，错了就是错了，影响的大小并不能改变行为错误的本质，别人的错误更不会是证明你无错的理由。任何一种不良现象的存在，都有可能传递一种错误信息。进而导致更坏的后果，正所谓“<strong>千里之堤，溃于蚁穴”、勿以善小而不为，勿以恶小而为之</strong>。</p><h3 id="讳疾忌医的典故"><a href="#讳疾忌医的典故" class="headerlink" title="讳疾忌医的典故"></a>讳疾忌医的典故</h3><p>《扁鹊见蔡桓公》的故事，我们从小就学习了，告诉我们不能盲目相信自己，不能讳疾忌医。但想想我们自己代码的坏味道和bug，也是如出一辙。</p><p>代码坏味道或者糟糕的程序代码就像隐形的“疾病”一样潜伏在项目中，也因此形成了技术债务。如果这些“疾病”在项目初期不引起注关注、不把疾病扼杀在萌芽之中，那么后期修复它的代价也就越大，也必然会使得项目的软件程序越来越难以维护，这个项目也最终会像蔡桓公一样无药可治、“无奈何也”。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">所以，请记住童子军规则对我们的启示：**始终保持代码整洁，勿以善小而不为，勿以恶小而为之，有病早治**。</font></td></tr></tbody></table><h3 id="其他原则："><a href="#其他原则：" class="headerlink" title="其他原则："></a>其他原则：</h3><ul><li>避免过早优化（Avoid Premature Optimization）: 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。“过早的优化是一切罪恶之源。”——Donald Knuth</li><li>最小惊讶原则(Principle of least astonishment): 代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。</li><li>代码重用原则（Code Reuse is Good）: 重用代码能提高代码的可读性，缩短开发时间。</li><li>别让我思考(Don’t Make Me Think): 所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</li><li>为维护者写代码(Write Code for the Maintainer): 优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。“如果一个维护者不再继续维护你的代码，很可能他就有了想杀你的冲动。”</li><li>正交原则(Orthogonality): 正交性的基本思想是，在概念上不相关的事物不应该与系统相关。设计越正交，异常越少。 这使得用编程语言更容易学习，读写程序。(反例：CSS)。</li><li>做最简单的事儿就让代码可运行（Do the simplest thing that could possibly work）: 尽可能做最简单的事就可以让代码可运行。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢？”这将有助于在设计中保持简单的路径。</li><li>隐藏实现细节（Hide Implementation Details）: 软件模块通过提供接口隐藏信息（即实现细节），而不泄漏任何不必要的信息。</li><li>科里定律(Curly’s Law): 是为任何特定的代码选择一个明确定义的目标：只做一件事。</li><li>墨菲定律（Murphy’s Law）:根本内容是：如果事情有变坏的可能，不管这种可能性有多小，它总会发生。主要内容如下：<br>&nbsp;&nbsp; - 任何事都没有表面看起来那么简单；<br>&nbsp;&nbsp; - 所有的事都会比你预计的时间长；<br>&nbsp;&nbsp; - 会出错的事总会出错；<br>&nbsp;&nbsp; - 如果你担心某种情况发生，那么它就更有可能发生。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件程序设计原则（一）</title>
      <link href="/2020/07/13/ruan-jian-she-ji-yuan-ze-yi/"/>
      <url>/2020/07/13/ruan-jian-she-ji-yuan-ze-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。每个程序员都可以从理解编程原则和模式中受益。</p><p>软件设计原则是一组帮助我们避开不良设计的指导方针。根据Robert Martin的理论，应该避免不良设计的以下三个重要特点：</p><ul><li><strong>僵化</strong>：很难做改动，因为每一个细微的改动都会影响到系统大量的其他功能</li><li><strong>脆弱</strong>：每当你做一次改动，总会引起系统中预期之外的部分出现故障</li><li><strong>死板</strong>：代码很难在其他应用中重用，因其不能从当前应用中单独抽离出来</li></ul><p>下面这些软件设计原则是我从一些书籍和网络中收集而来，并不完整，而且你也需要在一些有“冲突的原则”之间进行权衡和取舍。本文或许会对你的编程、程序设计、讨论或评审工作有所帮助。</p><h2 id="二、通用设计原则"><a href="#二、通用设计原则" class="headerlink" title="二、通用设计原则"></a>二、通用设计原则</h2><h3 id="1-KISS"><a href="#1-KISS" class="headerlink" title="1. KISS"></a>1. KISS</h3><p>所谓KISS原则，即：Keep It Simple,Stupid，指<strong>设计时要坚持简约原则，避免不必要的复杂化，并且易于修改</strong>。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">Everything should be made as simple as possible, but not simpler. - Albert Einstein</font></td></tr></tbody></table><p>简单清晰、功能强大是软件设计最重要的原则和目标。但是软件工程天然错综复杂，而“简单”却没有一个衡量标准，判断和实现一个东西是不是简单，可以通过以下方式来参考。</p><ul><li>让别的软件工程师以一种最容易的方式使用你的方案。</li><li>简单不是走捷径，不是为手边的问题找一个最快的方案。</li><li>当系统变得更庞大更复杂的时候依然能够被理解。</li><li>如果系统无法保持简单，那么我们能做的就是保持各个局部简单，即任何单个的类、模块、应用的设计目标及工作原理都能被快速理解。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black">**我的理解**：保持简单但不能掩盖软件丰富的内涵。即**简约而不简单**！简约是对复杂的事物抽丝剥茧、去除细枝末节显露主要逻辑的过程。就像小时候老师教写文章，要求尽可能用朴实的语言，言简意赅的写出来，但却又要避免语言过于贫乏。软件的“抽象”和它的“直观性”，其实是一对矛盾的关系，软件设计就要保证这两者的平衡。代码抽象过于复杂会陷入“过度设计”不易理解的困境；为了“直观性”缺乏抽象，长此以往又会出现大量的重复、不易于扩展和难维护的困境。</font></td></tr></tbody></table><h3 id="2-DRY"><a href="#2-DRY" class="headerlink" title="2. DRY"></a>2. DRY</h3><p>所谓DRY原则，即：Don’t Repeat Yourself，<strong>不要让自己重复</strong>。</p><p><strong>重复代码是软件程序变烂的万恶之首</strong>。DRY并不是指你不能复制代码，而是你复制的代码不能包含重复的“信息”。复制的东西并不仅仅是复制了代码，而是由于你把同一个信息散播在了代码的各个部分导致了有很多相近的代码也散播在各个地方。代码之所以要写的好，不要重复某些“信息”，因为需求人员总是要改需求，不改代码你就要“死”，改代码你就要加班，所以为了减少修改代码的痛苦，我们不能重复任何信息。举个例子，有一天需求人员说，要把分隔符从分号改成顿号！一下子就要改多个地方了。</p><p>所以，<strong>去掉重复的信息会让你的代码结构发生本质的变化</strong>。</p><p>“重复代码”有很多变体：</p><ul><li>魔法数字、魔法字符串等</li><li>相同代码块</li><li>相似的代码逻辑及操作</li></ul><p>对于消除重复的代码有<strong>事不过三法则</strong>。</p><ul><li>第一次先写了一段代码。</li><li>第二次在另一个地方写了一段相同或相似逻辑的代码，你已经有消除和提取重复代码的冲动了。</li><li>再次在另一个地方写了同样的代码，你已忍无可忍，现在可以考虑抽取和消除重复代码了。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black">我的理解：解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过重构的手段来消除重复。发现和解决重复并不困难，通过提取抽象、提取方法等措施就能消除重复，但困难的是立即行动去解决重复，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。解决了重复，经过一段时间，你就会发现，你对整个系统的理解程度在不知不觉中提高了不少。</font></td></tr></tbody></table><h3 id="3-Maximize-Cohesion，-Minimize-Coupling"><a href="#3-Maximize-Cohesion，-Minimize-Coupling" class="headerlink" title="3. Maximize Cohesion， Minimize Coupling"></a>3. Maximize Cohesion， Minimize Coupling</h3><p>所谓Maximize Cohesion,Minimize Coupling原则，即：<strong>高内聚低耦合</strong>。这是判断设计好坏的标准，主要是看<strong>模块内的内聚性是否高，模块间的耦合度是否低</strong>。</p><ul><li><strong>耦合性</strong>：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</li><li><strong>内聚性</strong>：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</li></ul><p>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><p>Java中实现高内聚低耦合的常用方式：</p><ul><li>少使用类的继承，多用接口隐藏实现的细节。</li><li>模块的功能化分尽可能的单一，道理也很简单,功能单一的模块供其它模块调用的机会就少。</li><li>遵循一个定义只在一个地方出现。</li><li>少使用全局变量。</li><li>类属性和方法的声明少用public，多用private关键字，</li><li>多用设计模式，比如采用MVC的设计模式就可以降低界面与业务逻辑的耦合度。</li><li>尽量不用“硬编码”的方式写程序。</li><li>最后当然就是避免直接操作或调用其它模块或类（内容耦合）。</li></ul><h3 id="4-SOC"><a href="#4-SOC" class="headerlink" title="4. SOC"></a>4. SOC</h3><p>所谓SOC原则，即：<strong>关注点分离</strong>（Separation of Concerns）。<strong>不同领域的功能，应该由不同的代码和最小重迭的模块组成</strong>。关注点分离是处理复杂性的一个原则。由于关注点混杂在一起会导致软件程序复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。关注点分离原则不仅体现在软件程序设计等设计方法中，同时也体现在架构设计、问题求解、软件开发过程、软件项目管理以及软件开发方法学等诸多方面。</p><p>MVC就是关注点分离的一个体现，把业务逻辑、数据、界面分离，这也是组织代码结构的一个形式。MVC的基本结构：</p><ul><li>Model层表示应用程序的数据核心，通常负责在数据库中存取数据。</li><li>View是应用程序的显示层，通常是依据模型的数据而建立。</li><li>Controller是用来控制和处理输入输出的，是处理用户交互的部分，也负责向模型（Model层）发送数据。</li></ul><p>MVC的这个设计各个关注点是分开的，这样有助于我们管理和开发复杂的应用程序，我们可以在某个时间点只集中精力在其中的某一个关注点，而不是所有的部分。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。即使需要改变，也能够清晰地识别出那些部分需要改变。如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。——Ivar Jacobson(《AOSD中文版》)</font></td></tr></tbody></table><h3 id="分离方式"><a href="#分离方式" class="headerlink" title="分离方式"></a>分离方式</h3><p>下面将介绍一些分层的思想和方式:</p><ul><li><strong>纵向分离</strong>: 如常见的三层架构（逻辑控制层、业务处理层和数据持久化层）。</li><li><strong>横向分离</strong>: 如把我们的软件拆分成模块或子系统。从左到右是模块1、模块2、模块3，这是一种水平方向的切割。这跟纵向的分离是两个不同的方向，横向分离大多是模块化的过程。</li><li><strong>切面分离</strong>: 有些内容是多个层之间都需要的，比如日志（log），在你的系统里面，界面层、逻辑层、数据访问层可能都需要写日志，这种跨到多层同样逻辑就可以考虑切面分离。</li><li><strong>依赖方向分离</strong>: 按依赖方向考虑，决定某个类应该放在哪个层次里面，或者考虑将某一层切割成多层。</li><li><strong>关注数据分离</strong>: 在组织数据时，应该尽量考虑数据本身的固有属性，如果不是它们的固有属性，那么应该分离出来。比如产品的类就不应该关联customer类，应该是用订单类来把他们联系在一起。</li><li><strong>关注行为分离</strong>: 行为也应该是事物或对象的固有的本身的行为，明显偏离原来行为的，应该考虑成另外的关注点儿分离开。比如有一个函数叫做CreateNewCustomer()，那么CreateNewCustomer()的行为就应该限定在创建一个新客户上面，给新客户自动发优惠券的动作就不能放到这个函数里面。</li><li><strong>扩展分离</strong>: 如果基于某种设计，原先不具有某些行为需要增加，可以考虑通过扩展或插件的形式来完成，将这些功能放入到插件或扩展中。</li><li><strong>反转分离</strong>: 很多依赖注入的框架，如Spring、Guice等等，这些帮助我们做依赖反转，从而倒置依赖关系</li></ul><h3 id="5-YAGNI"><a href="#5-YAGNI" class="headerlink" title="5. YAGNI"></a>5. YAGNI</h3><p>所谓YAGNI原则，即：You Ain’t Gonna Need It，<strong>你不需要它</strong>。它是一种极限编程（XP）实践，表示程序员不应为目前还不需要的功能编写代码。YAGNI很像KISS原则，因为它也是致力于构建简单的方案。然而，KISS是通过尽可能容易的完成某件事情来实现精简方案；但YAGNI是通过根本就不实现它来达到精简。YAGNI的观点是你应该<strong>为了眼前的需求做设计而不是未来</strong>。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">只在真正需要某些功能的时候才去实现它，而不是仅仅因为你预见到它将出现。- XP的联合创始人Ron Jeffries</font></td></tr></tbody></table><p>即使你非常确信将来你需要某个特性，也不要现在就去实现它。在很多情况下，你会发现或许最终你不需要它了，或者是你真正所需的特性与你之前预计的有很大的出入。遵循 YAGNI 实践有两个主要原因：</p><ul><li>你节约了时间，因为你避免了编写最终证明不必要的代码。</li><li>你的代码质量更高了，因为你使代码不必为你的“推测”所污染，而这些“推测”最终可能或多或少有些错误，但此时这些错误已牢牢地依附在你的代码中了。</li></ul><table><tbody><tr><td bgcolor="lightblue"><font color="black"> **我的理解** ：YAGNI 原则，本质上是告诫我们**写代码不要画蛇添足，否则就会弄巧成拙了**。编写业务代码时，不要去假想一些需求或者场景，因为大多数你所设想的场景都不会发生，而你所多写的那些代码也将会长期滞留在你的系统中，收效甚微，但却让你和团队花费了更多的时间和精力去书写和维护，更可怕的是可能会对将来新的代码维护人造成困惑。另外对于没有被使用到的代码，我认为也都应该立即删除，从而保持系统的精简，如果将来需要时再去书写或恢复，而且那时侯写出的代码也绝对比之前的更为契合。</font></td></tr></tbody></table><h3 id="6-Boy-Scout-Rule"><a href="#6-Boy-Scout-Rule" class="headerlink" title="6. Boy-Scout Rule"></a>6. Boy-Scout Rule</h3><p>Boy-Scout Rule，译为：<strong>童子军规则</strong>。美国童子军有一个简单的规则：“让营地比你刚来时更干净(Always leave the campground cleaner than you found it)”。如果看到地上有垃圾，不管是谁扔的，都要清理。这样你就有意地为下一批来宿营的人改善了环境。</p><p>童子军规则告诉我们在对现有代码库进行更改时，代码质量往往会降低，从而积累技术债务。所以需要始终保持代码整洁。不管原作者是谁，如果我们努力去改进代码模块，不管是多么小的改进，我们的软件系统就再也不会持续变坏了。取而代之的是，系统在发展的同时会逐渐变得更好。我们也会看到团队们关心整体的系统，而不是各自只关心自己负责的一小部分。而且团队成员要互助，互相清理代码，他们遵从童子军规则，因为那对每个人都很好，而不仅仅是对自己好。</p><p>关于童子军规则中所提倡的<strong>对代码坏味道的尽早修复</strong>，我也想起来了我们所熟知的<strong>“破窗效应</strong>”和<strong>“讳疾忌医”</strong>的典故：</p><h3 id="破窗效应"><a href="#破窗效应" class="headerlink" title="破窗效应"></a>破窗效应</h3><table><tbody><tr><td bgcolor="lightblue"><font color="black">如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些示范性的纵容去打烂更多的窗户。久而久之，这些破窗户就给人造成一种无序的感觉，结果在这种公众麻木不仁的氛围中，犯罪就会滋生、猖獗。——政治学家威尔逊和犯罪学家凯琳提出的“破窗效应”理论</font></td></tr></tbody></table><ul><li>“环境早就脏了，我扔的这点儿垃圾根本起不到关键性作用。”</li><li>“这个代码以前的其他人也都是这样写的。”</li><li>“反正也不是只有我才这么写代码的。”</li></ul><p>不少人会像上面这样辩解自己的过错。其实，这些说法根本站不住脚，错了就是错了，影响的大小并不能改变行为错误的本质，别人的错误更不会是证明你无错的理由。任何一种不良现象的存在，都有可能传递一种错误信息。进而导致更坏的后果，正所谓“<strong>千里之堤，溃于蚁穴”、勿以善小而不为，勿以恶小而为之</strong>。</p><h3 id="讳疾忌医的典故"><a href="#讳疾忌医的典故" class="headerlink" title="讳疾忌医的典故"></a>讳疾忌医的典故</h3><p>《扁鹊见蔡桓公》的故事，我们从小就学习了，告诉我们不能盲目相信自己，不能讳疾忌医。但想想我们自己代码的坏味道和bug，也是如出一辙。</p><p>代码坏味道或者糟糕的程序代码就像隐形的“疾病”一样潜伏在项目中，也因此形成了技术债务。如果这些“疾病”在项目初期不引起注关注、不把疾病扼杀在萌芽之中，那么后期修复它的代价也就越大，也必然会使得项目的软件程序越来越难以维护，这个项目也最终会像蔡桓公一样无药可治、“无奈何也”。</p><table><tbody><tr><td bgcolor="lightblue"><font color="black">所以，请记住童子军规则对我们的启示：**始终保持代码整洁，勿以善小而不为，勿以恶小而为之，有病早治**。</font></td></tr></tbody></table><h3 id="其他原则："><a href="#其他原则：" class="headerlink" title="其他原则："></a>其他原则：</h3><ul><li>避免过早优化（Avoid Premature Optimization）: 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。“过早的优化是一切罪恶之源。”——Donald Knuth</li><li>最小惊讶原则(Principle of least astonishment): 代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。</li><li>代码重用原则（Code Reuse is Good）: 重用代码能提高代码的可读性，缩短开发时间。</li><li>别让我思考(Don’t Make Me Think): 所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</li><li>为维护者写代码(Write Code for the Maintainer): 优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。“如果一个维护者不再继续维护你的代码，很可能他就有了想杀你的冲动。”</li><li>正交原则(Orthogonality): 正交性的基本思想是，在概念上不相关的事物不应该与系统相关。设计越正交，异常越少。 这使得用编程语言更容易学习，读写程序。(反例：CSS)。</li><li>做最简单的事儿就让代码可运行（Do the simplest thing that could possibly work）: 尽可能做最简单的事就可以让代码可运行。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢？”这将有助于在设计中保持简单的路径。</li><li>隐藏实现细节（Hide Implementation Details）: 软件模块通过提供接口隐藏信息（即实现细节），而不泄漏任何不必要的信息。</li><li>科里定律(Curly’s Law): 是为任何特定的代码选择一个明确定义的目标：只做一件事。</li><li>墨菲定律（Murphy’s Law）:根本内容是：如果事情有变坏的可能，不管这种可能性有多小，它总会发生。主要内容如下：<br>&nbsp;&nbsp; - 任何事都没有表面看起来那么简单；<br>&nbsp;&nbsp; - 所有的事都会比你预计的时间长；<br>&nbsp;&nbsp; - 会出错的事总会出错；<br>&nbsp;&nbsp; - 如果你担心某种情况发生，那么它就更有可能发生。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
